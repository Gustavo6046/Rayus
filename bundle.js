(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * Geometrical Structures:
 * 
 *  - Point {x, y}
 *  - Line Segment {begin (Point), offset (Point)}
 *  - Ray {begin (Point), angle (Number)}
 *  - Line {begin (Point), dir (Point*)} 
 *     *used as an unit vector
 * 
 */



var opers = {
    point:
    {
        add: function add(a, b) {
            return {
                x: a.x + b.x,
                y: a.y + b.y
            };
        },
        
        sub: function sub(a, b) {
            return {
                x: a.x - b.x,
                y: a.y - b.y
            };
        },
        
        mul: function mul(v, x) {
            if ( (typeof x) == "number" )
                return {
                    x: v.x * x,
                    y: v.y * x
                };
            
            else
                return {
                    x: v.x * x.x,
                    y: v.y * x.y
                };
        },
        
        div: function mul(v, x) {
            if ( (typeof x) == "number" )
                return {
                    x: v.x / x,
                    y: v.y / x
                };
            
            else
                return {
                    x: v.x / x.x,
                    y: v.y / x.y
                };
        },
        
        dot: function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        },
    
        cross: function cross(a, b) {
            return a.x * b.y - a.y * b.x
        },
        
        len: function len(v) {
            return Math.sqrt(opers.point.sqlen(v));
        },
        
        sqlen: function sqlen(v) {
            return Math.pow(v.x, 2) + Math.pow(v.y, 2);
        },
        
        unit: function unit(v) {
            return opers.point.div(v, opers.point.len(v));
        },
        
        fromAngle: function fromAngle(th) {
            return {
                x: Math.cos(th),
                y: Math.sin(th)
            };
        },
        
        inverse: function inverse(p) {
            return {
                x: -p.x,
                y: -p.y
            };
        }
    },
    
    ray: {
        intersectionPos: function intersection(ray, seg) {
            var q = opers.point.sub(ray.begin, seg.begin);
            var r = {
                x: Math.sin(ray.angle),
                y: Math.cos(ray.angle)
            };
            
            var t1 = Math.abs(opers.point.cross(seg.offset, q)) / opers.point.dot(seg.offset, r);
            var t2 = opers.point.dot(q, r) / opers.point.dot(seg.offset, r);
            
            if ( t1 >= 0 && 0 <= t2 && t2 <= 1 )
                return t1
                
            else
                return null;
        }
    },
    
    line: {
        normal: function normal(line) {
            var cn = Math.cos(90);
            var sn = Math.sin(90);
            
            return {
                x: line.dir.x * cn - line.dir.y * sn,
                y: line.dir.x * sn + line.dir.y * cn
            };
        },
        
        atPos: function linePos(line, n) {
            return opers.point.add(line.begin, opers.point.mul(opers.point.unit(line.dir), n));
        }
    },
    
    lineSeg: {
        slide: function slide(seg, vel, camPos) {
            var res = opers.point.mul(opers.point.unit(opers.point.sub(seg.offset, seg.begin)), opers.point.len(vel));
            
            if ( opers.point.dot(res, vel) < 0 )
                res = opers.point.inverse(res);
            
            // var n = opers.lineSeg.normalTo(seg, camPos);
            
            return res;
        },
        
        corner: function corner(seg, pos, radius) {
            let a = radius - opers.point.len(opers.point.sub(pos, seg.begin)) / radius;
            let b = radius - opers.point.len(opers.point.sub(pos, opers.point.add(seg.begin, seg.offset))) / radius;
            
            return Math.max(a, b, 0);
        },
        
        normalTo: function normalTo(seg, point) {
            var normal = opers.line.normal({ begin: seg.begin, dir: opers.point.unit(seg.offset) });
            var normDot = opers.point.dot(normal, opers.point.unit(opers.point.sub(opers.lineSeg.closest(seg, point), point)));
            
            if ( normDot < 0 )
                return opers.point.inverse(normal);
            
            return normal;
        },
        
        split: function split(line, seg) {
            var n = opers.line.normal(line);
            var sgend = opers.point.add(seg.begin, seg.offset);
            
            if ( opers.point.cross(seg.offset, line.dir) == 0 )
                return null;
            
            // p + tr = q + us
            // p + tr for the line segment
            // q + us for the infinite line
            var t = opers.point.cross(opers.point.sub(line.begin, seg.begin), line.dir) / opers.point.cross(seg.offset, line.dir);
            var u = opers.point.cross(opers.point.sub(line.begin, seg.begin), seg.offset) / opers.point.cross(seg.offset, line.dir);
            
            if ( 0 <= t && t <= 1 && u > 0 )
                return opers.point.add(seg.begin, opers.point.mul(seg.offset, t));
                
            else
                return null;
        },
        
        closest: function closest(seg, point) {
            var sq = opers.point.sqlen(seg.offset);
            var atp = opers.point.sub(point, seg.begin);
            var dt = opers.point.dot(atp, seg.offset);
            var t = (dt / sq).clamp(0, 1);
            
            return opers.point.add(seg.begin, opers.point.mul(seg.offset, t));
        },
        
        collides: function collides(seg, point, radius) {
            return opers.point.len(opers.point.sub(point, opers.lineSeg.closest(seg, point))) <= radius;
        },
        
        splitPos: function split(line, seg) {
            var n = opers.line.normal(line);
            var sgend = opers.point.add(seg.begin, seg.offset);
            
            var t1 = opers.point.dot(n, opers.point.sub(seg.begin, line.begin));
            var t2 = opers.point.dot(n, opers.point.sub(sgend, line.begin));
            
            if ( (t1 >= 0) == (t2 >= 0) || opers.point.cross(opers.point.unit(seg.offset), line.dir) == 0 )
                return null;
            
            // p + tr = q + us
            // p + tr for the line segment
            // q + us for the infinite line
            return opers.point.cross(opers.point.sub(line.begin, seg.begin), seg.offset) / opers.point.cross(seg.offset, line.dir);
        },
        
        lineFront: function lineFront(seg1, seg2) {
            var res = Math.sign(opers.lineSeg.pointFront(seg1, seg2.begin) + opers.lineSeg.pointFront(seg1, opers.point.add(seg2.begin, seg2.offset)));
            
            return res;
        },
        
        pointFront: function pointFront(seg, point) {
            var sgend = opers.point.add(seg.begin, seg.offset);
            var res = opers.point.cross(opers.point.sub(point, seg.begin), opers.point.sub(sgend, seg.begin));
            
            res = Math.sign(res);
            
            return res;
        }
    }
};

module.exports = opers;

},{}],2:[function(require,module,exports){
(function (Buffer){

var geom = require('./geometry.js');
var raycaster = require('./raycaster.js');

var images = {
    sprites: {
        sphere: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FZQUFBRERQbUhMQUFBQUJtSkxSMFFBMHdEVEFOT25BN2J4QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUVGeHNyOFZtbWtRQUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBZ0FFbEVRVlI0MnUyOWZheW5WM0VtK0ZTZDkxNjN1OXZ1dGpGMk1FME00Y1BnekJBRkVsc2tBbnRKNHF5U0NCTEVUUGdZSEd6VzVBOGlFYVRWU2w1UDFtWkZOb0VKUVpGUUlrR3doU0VUa3VXZlNKbFprbWdSa0IxSERSanZoc1ZzSUI2WUVCdkdIMk8zN2NidC9wMnEyai9xcVhQZWEyT3djYmZkQm43VzllMTc3Ky96UFhXcW5ucnFxVG9TRWZoZXUvM1JILzNSaFp2TjVxSk43eThNOTJjNi9Nd0dQVVZiMjlWYTI5SmxrZFpFRmwyZ3F2a2dSMWhZdUdNRDcwY2N1RmRWYjFQUnIyclR2OS9lMnY3RUpiOTJ5U2UvMTY2VlBOa040QS8vOEE5Ly9QNzc3Ny9reUFNUHZDeDZmN1l1MjZlZWROS1dxQ29nQWxIRkFvVXFBRlVJQk5vVUNrQVhCYUFRRVNnVTBQeGRRejVXVmFGUTZLSVFBSnZlNDV2Zi9PWTk3bjV6YSsxVFcxdmIxNzNoRGYvbXhoOFl3T044KzNlLzkrK3V1UCtiOTcrNjkzN2U5dmIycmxvb05PUUNxK2FYS0tRQklwcUxIZ3BSQVZTeEtMajREYXJnL1lFUXdTSUs4RGxEWXp5WGFob0xBQ3k2QUF0dzc2RjdqMncybTV0VTlhTnZmT01iZitjSEJuQ2Nici83dTc5NzFYMzMzZmQ2ZDMvTzF0WldMZ04zcVloaUVZVTBoVFpBMFlBbVVGRkFrQjZnNWFMS2FtZWpDUVJjZkhxRUVJVWlQVWVEUWlVUXF0RFcwQlNBSzNRUmhBREtFS0lBUkFSSGpoeUorKzY3N3g4Qi9NbWxsMTc2OWg4WXdHTzh2ZnZkNzc3NHJyc09YWDNrL3NQbkwxdGJMUmNQRUN4UUJWcHI2ZWJSb0F1TkFZQTJSUk5GcUdJUkFFMndSQU5hR29BQUVGMXlRV1Y2REVEUkdvQ1ZGNUY4UXVoNFhIb1JrUXd0c25vT2dRRHBJSEQ0OEdFN2ZQandwN2UzdDY5K3d4dmU4TmMvTUlCSGNmdnQzLzd0Sys2KysrN2ZNTE96YTdmS3dwMnRndGJvdW9GY2pDWVFiZGppd29XbUFZaEtMbzQwNklMYzlTSm9FS2ptYzZua29pbzlBVlFoTFRHQkN2TDFwQ0g0ZDVFTUlhcjVmREs4RVBJNWhVYXp1cTUzM25ubnJRRGVleUtHaUJQS0FONyt2Nzc5WFhmZWNlZWJJMkpmZ2pKRmE4STRuUmU2NWJhRkx1bXFSN3pYTkFKQnhYeTY2T0FPMW9CcUl3Z1VLQnEwQ1FKQVU0V2thNEZvTHI2bzV1OUZBRWlHRnloVWZlQ0dBU0RMMkJSWVFoSEt2d2NRbU5mM3JydnVPbVJtNzd2MDBrdi9weDhZd09wMjlkVnZ2K3IyMjI5N201bnRhNnFBNU1YWGxzaTlDVjE4WkN3R2hCNUIwZWllTmQwQnRDMW9vSnZXY3VmTEFIb2lTbU5LUXdHNDJ4Y0EwaVltMEFaSUdnY0FORmtBamZRV0lva1RXdjV0L0U3ejJkRGF3QVhBd3hyQ2UwNEVuUENFR3NBNzN2R09WMy9qRzkvNGcvdVBIRGxidUl1YjVNVlh5UVZwaTBCbHlVVVRJRnJEVnN1ZExDMmdxTDlOZzFIazR3TkFXNVpjeEhMWkFOclNFc1NoMFlVbjZCTVJ0SHhoYUZOSVpFelBrTEEyb254TVBvZXVQRUxkdHpFa01CWGw1NDBBSUlHeWhUdnZ2UE5XRVhucnIvM2FyMzMwKzg0QWZ2TTNmL1A2dSs2NjZ5Vks5NnNpV0RSUmVHc0tsUVpweUpSc1dVYk1IYWhiVzdwcmJYVGg1YnFGc1YreE5FQ2swU2dxMVpQYzh3dDVnYWd3QWdBTlRmajdjVjlCVzdpelpSWHphU1JRcHA0MFdGRU1IaUg1QlRDOHlQanNnWjBZNGJiYmJ2dTdONzNwVFQvMWZXRUFWMTU1NVZWZis5clhybkQzazNMSHRVVHRqZkZiTTk3bjcvUEN0MFZIWE01VXJtRVphQnhvVFJFZzRsOFdMQUlFRWo5VVNqZlJQck1HVVlDUDEwUjdhQXFHbU5WT2x6U09RdjZBakhpdnNneFhYL2RQM05qU01ESUdZVkVnWktGWDJubTk2L3JmYzg4OUR4dzlldlIzSHUrdzhMZ2F3RnZlOHBZYjdyenp6aGZsRHNvRmJuVG5iV0U4MWtZUFFDSm5tV2hmdGFGSjV1OExRWnMydWx0WmNzY0tFckRWeFY4YTB6TlpnVDBobUVTK2hnQ1FCVTBqTXdPZHBKSHlkUnE5U3UzMjBBV0tHS0IwOEFzS1JEUWFqVUpERUJXaUpERUVZbVVHRDhJSHQ5OSsrK2N1dSt5eUYzOVBHY0JWVjEzMXVpOS8rY3Z2ZTJEendKNG1pdGE0V0lOZ1NYRFdKR04yVWJpTnUwMmFvdWt5TWdIbDdnUGpyRURTZGJjbFBZSXVnd0ZzQklkTmNnSEhUbTJUTTFCVXBoR0FMbWdTQStGRDBtZ1dYZjJPYWFZaTZFWDRuSnJoSlZQUW1LOFhDVWdMWnd4Y3NEWUV4SWdLZDk5OTkrR0llUE1sbDF6eTc1LzBCdkMydDczdG1wdHZ2dm5TMWhxZ0RWdExMaXgwaXpFYTBMWkFtL0RpU3lMcUJqVGRvdXNXWGxRbGpjc2RMcG5hWmY2ZTl5dGdOM0FCNC85Z0FibndUWFBSSVEwaU1YYXNyREtCR2UrRDhYNkJSR1M4UnlNcEJIb2VZaEFCc01qRUZxR0lKYUJTbjV2R3NzWUVxelhJZndZaUFuZmNjY2UxbDExMjJXVlBXZ080L1BMTEQzNzk2Ly8xL0dUdEJOSzJrbmlSaGkzbTdWcnNYRnV3QmJyMDJwVkx3d0pBbGlWVE1jWm5hUUtWTFRTdCtOdWdraGNaTFRNQUNVWGJBaVFXWUVsU3A2VXZ6eDBMb0JWeG96RzRmdXlJNmJuUXFrSERZV29vaVZYV0tlQmdLV05oVmhFRE5LS0lvbFdvZUlnUlBBZ1kxcnJjZHR0dG4zN1RtOTUwd1pQS0FONzV6bmN1LzgvblAvK1Z1Ly9iZnp0UUY3MXB4dTdXRW9CbC9rNk92alUwQ0JwUmUrR0FOSXlHSnZQQ3BTZFJOQTBJUVZnQlBwSEVFZ0o2aUZhSXZBQmx2cGNsRVJ3YWlhUEVFZ29FZ2FDc2RpcGpkbVBXVWNXbWdEQVVKZktYWWhTRFJhVUNuQ0tEZXlqakd0VkgxaUxLRUFJelJWd2J4QjEzM1BIUEo1OTg4ck5lODVyWDlHTzlWbnJNMmJ5M3YvMjhnd2NQM25IbjdiY2ZjRE40cHRWd0VjQUZZUUYxUVVRZ05DMWRlMGVFQTk3SXBRZkNBb0tBZU1BakwweEV3Q0lnRVlnUU9Ed3BXZ2xlV0FCOG5JY2pJaDhiWVRQV2VzRGhrQWk0K2JqSTdzamZSY0IwNVpZamNqZUhJd2pZSElHQThYM2s3ejN5T1FJR1EvMCtFR2FJY0xnSDNQbTd5UGNIeTg4aWZDMkJqR3l4aWwwUXdSbG5uSEhnNk5HamQzejR3eDgrNzRRMmdOLzZyZCs2OE9CbkR0NXc2TkNoZldHUkMrOE9NUWZjRWN5eEhRRkk1TytSNUk1QTRKcVhOaEFJQ2JnRERnY2NDUEVFVDJGNUVUMEFxNHRKNHlDZTlnQWNnSVFnU01PRU9SRENSZU5paWMrRmNrZEkvaTA2VmdzVmNBTXNKSmVlcXkyNWZqUTBHcEliRERJZjY0NEl5ZGVvNS9lQVdRQklZKzRBalBjdmQ3UUdpbVVJcDUxMjJyNkl1T0ZESC9yUWhTZWtBVng1NVpVWEgvejBwLy9tbS9kOWN4ZUFYTXpJeTk4bFA2QkVBTjNoNFJBSEFvSndCOExUNXhseTUzc0FTSU9SM0pvSUQwU3ZYUlVJOGZRUUVSQ0pzY0FlZ0V0NkFUT0h1Q0Vrb0JKd3BDZVFDTGc0QWdLREFKYWZ3Y0lSY0VEVzNvUFBINWJ2SVFJR3o0VVdod2h5Y1MyTkx6enk0L0N4SnVrQkFnR3g5RDZBNVhQRFZvYVNqNnR3SU1DRHZBR3dmLy8rWFNMeU54LzYwSWN1UHFFTTRNb3JyN3p3NE44ZC9NdHZIcjUvS3o5UUFKM3ZPZ0xOMDYwYm5iWklvSFAzUUxnRHhCQmlRSUF1TkxsY0Y2RnJGWVFHSWhRaEFRbEZ4Tnc5K2J1ODJHb1pNa1FBRXdFczROQmNHRXNYcnVGMEE1N2VCWFFiTG1PaHdTK3pRRWo5bUx0ZkdLYWNxVndnalRpTk40WUJDQjl2c0xuVFF4QmhnQUZpbGdibURndUgwenVzbG40VkhnVDc5dTNiRXBHL1BGYWU0REVid0wrOTh0K2VkL0Rnd1k5OTg4amhMWXpkNDRBQ0VZN3VnazdyMXZUaWFTQW9ONW4wdURsNE1SbVR3d0R2ZVVIRW9IVDF2TlJ3TXlJQXdBeHdvNkdJd0VIY1FBd0JrZm1hQW1SVTBUUkh2bWJlM3dFeExoS0dGOGpMUCtOMzBPMkxCSnhoS0hlL3cyVGlqN0VaUWhDOTdpUDh1ekFFQmN3RUx1bVp6UHU0TmhNMDdzRHQyTGR2M3hhQWp4MExUUENZRE9BZDczakg4dGtiUG52OW9VT0hkc0VCRjhETG5ackRXUHpRS0dBVzhPZ1FEeTVqUUhpeFZJUVhQWU40UU9FaVVFMXZZRjdnanp0UDhzN2xvb1dlQlN2WEhlWjVQMk9NRDRJNVJGb05Gemtka1NFY3lNQXlkM0NrdGNHNlFDSXhpd0d3OGhJU0E1TTRnREJMVElJWkJnQkxNc2hzaGhLemhBMWdlREVmbjZVVFU4d01iUmFVV0ozRy92MzdkN243OVIvNXlFZVdKOHdBUG4zdzRGZHV2KzMyZlFKQmgyUzhKbWlEeHZnNW9MbVRIQkEwT0hLM1pyeE9UK3h1RU10ZDZBVzB3bUV1ZExGenArV0N5M0RKaHNRRVlZbnU2c0s1Q0NRQTExVklvWkdaY0tIcFV5eFl3TGRoQXJuVEplQzgvRGF3akVIcTlWWTdQU0lYR3BnTG1uOFRXR1FJY0djT0VVQ0V3VmIzQzNvOEdWNWlmdVoxVlZINDMybW5uYmJ2L3Z2di84b1RZZ0QvK2wrLzV1QS9mZTFyQnlCcDBmQk1kY0l6UFhQTE41M3UxVEtHSWk5VXVUdmh6Z25wZ0F0Y0V3OVdUdXdocS95S3dOQ1pVWGdDT1lCeDF5UVhpcDRFM08wbzBEaHlCQnRwWU4wbklzR21NMFFNWEJHWWp3MkhsTHNQZ1Z0a1psQVdKV200RnNiSFRHQVhjSmFXWmJqM0JLbVpsU1FJelBodkxqQkxvM0ZIWmd3TVEyQjFzdUNCQ0hER0dXY2MrTUFIUG5Ed2NUV0F5OTUwMlRVMy9YLy83L251bm12VEFvSk9oS3U1MHlQZzNwRWhqVHRFS2liV0tpdlJ2OElrUnFxWXU4YnlNYng0Z1V6RmlpU3A5TkJyb1ppcnU4MjBEaENZSnk1UlNNYmR5dGdBaENWM1gveUxJRE9VeXYvVEpSdlRSODhGSHlGR0FMSFZUaVdBNUdJRjd4c29JMCszNzRnVnR1ajVuQlZHUkNEaXVXSEMwdE9zTW9WRW1TdWhDVFdJWjU1NTV2blhYSFBOTlkrTEFiejFyVzk5M1gvNnYvN1RwZkJBMDR5WmNNd0ZsWTZRUlB3SWdjSXJ5OHBVaU1ESjNlRk1oeUM1MEI3S3NMR1RGREhwQTVFWEVTTW1LL0tjQ3g2eWVxWGN5V0JlYnU0SXQ4a2xtS1hyZDV2aHhRQVlGNWtBTTBMNFhobXJoK2V3OUhJeDhZS0wwY2ZZRGh6aE5HaGphSXVvakVBeU5lVy9SNG9MaDdobnlJZ0ptczB3U2FPUkx1YjNNODQ0NDlMcnJydnVkY2ZkQUE0ZS9NejdvQW5VT2dtZTlBVHAzZ1o1TXhhTEpVOTZDL3FJMWE3aHY0M1dEM0IzSkluRTdRMm4yeHc3VEp5N0FzeXpRY2JQbVMzUUM4SGducWxqeHQ3Y3lWSVlRRmJJWGpMakNCTXVWS1Y1eVM5QVpHUUkrYmxxa1dMbDdnTVNBRmF4ZllTWkVJWkpNTDIwdko4bEJ2SWl1U3d5L1IzZXhXR1dIcUhYYzdvL0pFVVVrZmNkVndONDVTdGZlY09kZDk2MlI3bVFSV0Ftb0N0REFNUWxVVDkzdXE3Y0t0eGg0bm1SS2l3QVVCSTM2NFdXeXIwOXNLTld3bHgrb0hnYVRZaEFWdGxDZ3M1TTRUSnp6emV0Z1V6ZmZQMGNrbUROTTBmM2N0M0VLc0kwcjRpZ1d1endHSWpmSXhmVXpQTStLeERuNGJBd2NnQzVxRUp5b1RJRCtEUks0L3NySXdBNUR5RmVpQ29teWNRRCsvZnYzM1BOTmRmY2NGd000UExMTDcvcTg1Ly8vSXNNcEdVSnhMSVVrMHVZR2d5bVdUN2RiektCdVp1TG9zVndzNG04allzRXhta2dZT1R0QThXWHozaWF1SUMvandtbXlvTVVPZVNSb0hQUXRUSEk1bndPajFXNkZ0QUEwMG51WnZlSk04b0RPZG5Cb3BrSHd6Z1hFRDROSm5hOG4ybGNDUm9GSGdXV0U4TjRuMGJzbnJqRU1PbmpyQ3ZZTk9JVmFmVFVwejcxUmRkZWUrMVZ4OXdBRGg0OGVFWHZtY09iY1gyTExBSGczb0h1dzJyZE5Ra2MxWXhyc2VMWFlhUG80OXpwaUV6N0pQSURlKzA2dXRUaGFqMFlQMzNtM2tFd1d2ZlJ1YlB6T1lFd3pEb0RYOU5scG93UnlRMDRZKzE2MFFDSHU0Mkw3Y3pqblVXbU1JYTRZamVLYWw0dGZnYnpHQUExdzZGQnhKS3VacUVyU0IzYmlwREsxMHRleFZIWEV0eUVOTmdWTHRqZTNyN2ltQnJBSzE3eGl1dnZ2T3V1azFReGRtb3VVdEsyU09KdllFRVBBR3JEZlJmQUFaSU5oQ3M2MFQ1WUdjdGtLM0VrQmtaSWNvYjdLeGRBTWl0M0JFUmw3R3dwWGw1WWJjUWtqV1lzam9FNXpHSmtLN1ZBcG9vSWcySkZPb1V3dlBCem9JeEhJQ2F6bUJSTWJSM3B4VmF2YTJNbnI3d0JnYUxGTkdpNHd5d3pDTy96L211Z0s1WXNxWHZQN3hKWUZUVWhJamoxMUZOUCtzQUhQbkQ5TVRHQXQ3emxMYS8rekdjKzh4SUpSL2NzNHNBTkthUE5TbDhuQ0JSeTYxVnhDODlVQ2N5N3d4MHVuaVdZc1hzemZjb0NJVjBnNCtQQU9USGxVazRnTlJtL21mYURHWWs5aUF3eUl5RVZtWk1YNXZCWTc5Z0VkVW5heE1yRE9ZdFdkUHVyT29IcittZW5JVnU2QklZaWo4aEZZNmw2OEFzK2kxK1RTQ0wrQWFuaXRkR3crbW13c2FsY3lEeGFob1FDaHdMZ3pEUFBmTWtIUC9qQlZ6OW1BL2kvYjd6eER5b2RVa1o3cndJNjk3eHFSV29kSEx4bFZnMnJ3c2xNNEtmN1k2d1BDYVpmbU82WnlCa0ZmTVJRcXkzaENKT3NBR0xtMjVuU0NkMTJBYmdaSDR0NmxRSlg0ak1rbENVaFdVWmZZUTZ4MkZtMXEvS3hZV1FUdmlvY1ZYbTZoQVloRG8yQWtReEx4bkpxQ1hhbWkxV2l0dkU2NXA0TEw3RVRWN2l4bURXNUFoUFM1R25ZZi9DWURPQ05iM3pqVlYvKzBwZk9UdmRsM0R1T05lTmJwSWpBazlIakRoVm4zR1IrUDNodlJKSSt4bUpJeFVWSjNsNWkxaE1nNlZLOVhESlRyM1FhTmxQRlpJUXkxcnVSa01IY09TaksxZ2RRY3hHSTZ5QlhFcHM0VTFrZitLVFlUR0JpaFRYWGJ6R3pDYXQ0N0pncEhERktwL2NwRUd0Q1pqSjgxQk1Lb0NhRk1tbG1NTVVjQUpBWmwxbVdzMzJ0WDNBQVBUbVJwenpsS1dkL0owRDRiUTNnaGh0dWVGdm5SVTVDd2t0cE1XbmJvR3NEQlJJWVhDNGtHaGZEeUxERmNPOEk1TTVDeFQ5bUI4WE9yMVUveGVveTVYSjRZZ21wKzFJSE1OTE5GYmlUV0ZVSDU4NVV4dUhjUk90NFg5S3NGWEF0b1luN0FGOG9OVUVpeHZ4Y0JJVE80byt2S0dVaGtJdnc0ZmFOU3FGWWc4NTZ2WTdoU1lMRUUzcEh1UEM1WXBKVE1qRUdJamRZaGNIVzJ0dStLd040L2V0Zi82NS8rcWV2N1ZNRzRteWUxb3c1RG5oM3hxamN1VkhHNFpodlJ2cHdteVB0Q3pEOThheThSVlhnY25jWVJSVzU0WHlRTDdGaURPdmlabURGQUlHQWpucjdLRGVubjBqdlVFYmdSVmpGenRKcmVaT0lZWWdEU0ZvcWZTTjhaQXBHaGlFN1VGZFl3cE1OckRyRXVzd3RWUnV3dW4rTURHTmRidmJ3cktrTVdaa3dTMGpNbGFYa3lyeFdxaVp6b0dPa3hhZnQzNy92Mm11dmZkZWpOb0FiUDNmam0rRXhrYjE3TGpxRVc1OS84WlcrM1gyeXdvaE1CV05xN2FpWlNLQWlQcndDZkRyWmRKRjg0alVKaFBJQ1dTQVJaaUpCQTdYS3dkZmNPbEoybHN3YWR1d3d5SFMxbVFKeVI3SDY2STZkSmRrcTlJVFFMcE92QjFJeU5qV0lSZm1tNnkrUlIxUXFKeXZQNG9samtnUGkvYXd5aWd4cjVrbHdGU1lvdGpDcmhsV0NMd05pa0JWRDl3ekg1ZzRSZWZPak1vQkxMcm5raXYveVQvOWxYMGh3cDROQ0pxUHJZL1dQLzBYWmdVU0tPSWhFYWU1WnhDbmFsM0t2aXI5ZU1aQzFBU2ErUSszam80R0M5L1ZTK3ZBaVNub1VpZHJCTVFvK0dRSUlBTjEzOU8xSC9jMHFXM0NJVjRLSkFleXFvQTFpamtvN3JVUWpGbE5BNGdFeEhaWEcwdmlMVkhaUVhIOVJSemFGSVZiMUVFc0YwUkRMekhoZll0a2dnWlcwOGlvTDhVQkVuK2tuMmNqOTZRV3VlTVFHOFBuUGYvNDNuQW82NTV2SzlDSUxJell5Z2RxWm5TbGdTcThFR1NJUVNLeEFEQkJDc2lTU1Q2QURIU1ZWS1FQaDRxWkl3eWord0NDR2l1Y0hBVmpWNzMxY2JCODBMVmlqanlKd2ltTndUOWVxU3M5Um1zQ1kyVW1zR0Vqb1dGQW5FMWxBT0ZaTW9ZdXR5c2xVTEhtV2ZrTmtFRVFDN3ZnVkp0aFowNGhWSm1BRGZBOStwRjZIaGxPdmFUMUJJU2g2S1NheHUvL0dJektBWC8vMVg3LzRDMS80d3Rsd1FNM25QZHlIVW0wVVlVWnZXMlBzVnU2WGZGemw5RkZsWEdPdVRYZnVBOWdGMHpmV0VNcnRPNHNjQnFMZjJpV1VXV1BGeklXbkZzRW5pQnQ0bEVvYnJCWS93NUJRVHpiSjFPQUNUOTZobE1FK1hleEFwWmgxLzBycExOTmVHem04MFJzYXpLZ1Y4Rng4bWR6a01DSm5XTm5CbnJxUS9wM01vRWVDd1I1R2JzU0p0OG9BNmJrb1dEM3R0TlBPL3VBSHI3djRPeHJBbDc3MDVhdVRURW5PVDJtbFhzVVFCbjQzaDlEQ0lwTFk2ZWhqY1lOMStLd0ZHM2VMSVl5R1JRRkZwV2lHb2p0amhvYUIybVBkUDBPbE1COHFqcDNMVjNGY1pnYUFLU0d2K08raXBLM1hhaU9DTnA4TGdraFBOUVVlTWRoT0d3b2dHWVlsSy8xR3NQS1lJcEVLU1ZQRDRGWFZjK3hnS3l1amNVckZwckd6ZkUzczQyNVFZak4zR2FBM3N4c0hqQ3FrNkFoM1BQREFrYXUvb3dGODduTTNuTytqdHU1RFFwVVlJRWErVEJVM0lDbHZzdkwzSmNZWk9vQ1loWU1xNHhhVnkvSnhwVll1VTBJRks3a1hLSi95d1lFN1JaN3BoaXZuOTVVU3dFZmVQK3NWczVTYnFwTVNyODZkVm5aVWJkeFJ6S0JMZXFNVlJWMEdhVzRzNVpheHJlb0dnU0VOYzZrMGVsVm1waXd1S3BZN2kwTm1vM3p0bExzbDBNc1VlS0IrS2V4bGtPZ3NuMU5aSFpaMHdLcjh2R3Q3MS9uZjFnQmU4NXJYWEhYUFBmZTBOU0ZpVEVmZ0RnM0FlaTcwU08rcXVjTWNqcDRjdFRCZUpTdEJ0WFZ3MGNqOFdzWkdESmZQMGlpTEw0TmRZOGFBVmRQSGJLdjJJZDR3MXV4VHdNUEZMdU9RbFlFVW1WSmlDbDl4N1Z3TW8yQVRMQ0lMc2NVSWZTNElNejVEREdCWjJBRWlxMFZLalo4VUZ2R2lwRzJFS3BkSy9RTGlCTnFHVkJLdmpNWFFFU1owK1dsNDVwa0tUQXpBeDVrUElYNEpVazQ2K2VUMmdULys0NnNlMWdDKzlBLy84UHJhd3AzZU95MWFaeFVybUd2S0tzLzJuczJQWG14UVdyK2F3b1pHa0lzWUdUb0dSZXNGdkZhN1JtTDB4c1VLMVljN0w3aVBkaXRVYzBpVzVPQmEydnoxODB4UE1NSkFsRG9RTTMzMDJhWTFhd2R6cHhZNFRTQkkwQmd6dFUzbEVURUo2V3hoZlNBc1E0RkhFVUtsSzdSaGtHVUVneld0cGhPbk5NeXdvb2t4OUlaVkJ5aXVwSXRURUR2TDNXWUp3bzdhNXZVUGF3QTNmZkdMenhtUjF2b2dkV0NwOXpNNGh5dk5uZStZcWw2anhLL29TaE1XajJ3Q1NZZFFPTHJhaWVVVlFram5ybmFzczlvMUtvMXBnTUlSYmlNTmdwSTY1azZLVmJhQUdIekVrRmFUZmhvY0JOUFI0WWxXNzJIa1E3SENKSVBmd0lyeU5lNTRIeXhwdUZEM1p4UFV5Y3JySUZGK2VCV0xrczUyWDNFVG96aTF3aUxFVFc0eCtKQW9kWmIxalA5RHJlV1U2UmwyYmU5NnpyYzBnRi85MVYrOTRvRUhIcEFkZjdCMWpSZEFaME1HRno5MWRuMDBWOGFHc3FvUmt6T0VEQjU5eUxkRzhHUHFhRXpzcy9DQm1NOGhzaE9Fb1RJR254eEVlQmxkVmdzTHBPMFFjS3BQVHFIQW4wK09vSEo4SjdXOGsrdVg3QVphbFdXOVZFRXhHVU9qNjdmcS9CbmN2cWZDWjZSNXZIODFNUkpYdVBoNFBaVFUzV05ILzJKdXBxb3labk5LWmtuQ2pNWFM2Q3JOcmJWZ3FOamUzcGIzdi8vOVZ6ekVBTDc2MWEvc0tCM210YkhSMzFheUx4T2ZZSVNwWHhWUEZKUG9LSUFybGZlVEpTeUFpTkxjTTBnYnU0cXdtcHpCZnN2SklxNkFVM0l6c3NvU0txd1VOcGhTS3NBSEVDcDNMMVhqRjJLQmxjZ0NGR1dXWGtES1RhOFZSVkd5OUNKa2ZFckh3aEdocXpvL2hpeStzSUdUdmk1QVBOeTBaMkF5Vy9jTU1KTWdHNW5wWktmZTBaa0tjcWZiTEpqRmltYTJvZUFDamg0OSt1cUhHTUIvL3M5ZjJkRm1OTnEyVU5XNWJKdFNVNVNBS3drS0d5cFk0d0pXS2RkSGFkU0hNRFQvb0JsL2k0V2pvdGJYVmJSS1BTUEhzUlUzVUVndlZuUmZ4blJCdFcxRzZmOHdha01KdEVwc0lxd2VGdnBlZFNRWGdLdzAwc0xoS213dXFjOGpFSmNFWkw2cSt2SDVoRTBmYThVd3pGZWJJOTIrc1Rjd3pBZWg1V3loSDZDMEpPSCtZTDRBN0ZyR1RFTlhZaE80b2JNTzBSazJ1M1ZFR0piV3p0dGhBSmYvRDVmLytCMTMzTEhyd1NrQ2pZbkNUNS94UFJFVTB3MUFRMHZ4UkJlZW1BQ2ovZG9KMGpKTnNpRHRXa1drSWJQMVlSRERoUlJ3eEZvZ0dhTVU3V3REQ0VCREtKeU1rWm9WYXhkZThuRWFoTEJLdHlyRGVwV21Zaldwd1FOS3BlN2tEUGlaMXVvaHZzZmFyYk8vZElMTklhQmxBY3pIUzh6YWlLbU4xdk9Td1kxU3IwLytKQUVnYXhTbEkvQkFOK0lETDljZm8zblZMSER5N3QyN3JyMzIyaDhmQnZDTi8vcU5TNzVscFNBTW5vRWZnVURmS0J3OVV4SlA5Nk1EQzFoV3BqQVhFdUVKN3JTU2d5eDlTdlhWTXdOd1Q5ZFpjWHd1SGtaS1pKWFB5VW9kckQ2YU9rcHVQWXluWkNDZW5ta3FlSVVHSmF4RHlNNDVQY0dXOGRIQmc4bDVFS3lOT0E1Tm5nRFlLZWdZY1g3bTZ6V2tRcmxJZUFqeGhGRWlockdQY0NVc3RTaVdqL2huUnhrWjFDY0dYUHFnNG5XbGpxclVzemJhQXc4OGNNazBnRzk4NDJYZnJtS2NLakNIYWs5QVpUSGtXdDA3Qk1ZTFIvN1ppZ1BYNUFjMlBubDRGbDZ5ZzV2eXJ0V0hLVUtvd0phTnJoOWh0ekZKSFM4dVhhYVlvOUkyeUE0UG9DYkZRKzNvL0EwYXI2KzAreVdwbXU2VzRhTHkvd0hNaE9MV1dCRk1KU0RaMlRBUzlIaE80QmREdUZMekExYXQ1MUhFRW1ZdElIem9JUUFiMDBhOGhtd1lpMmM5Vy9MTWZKQkIyZGpTaVJHQUhnYnJnYzFtODdKaEFGLy8rdGVmL1hETGIrWnNhU0lXOEtyOUVYVDRUQU1uK0tpZnM1aERlRGpaT1FJeXR6aysxWkJqWG9KQ2tmSUtza0xRQ0Q1VFZKNDdXVDhaYnJ5a1lhdjZQME9SK0dUN1JvZmFTQm1GN2pYckEvWFVUcy9sRktUT1hIemRYMWlwMk94RXJ2QVdGc09kRjZnSzFyV2p5c1RjM2NYeEQwOHdLbjVHYjB4bUVTdDFNWHN2MTRXdTBrc2FrZ2F1N2lMdnFjZGtLSDMyTUlEYmJydnQxSWYzQURHa1lJWklBU2o3NmNZTHhTU01ITTQzdVRPVUNQTlJzT3FHcVFEZ20wK2tLbzdWRHJJQkxHZVh6aFFIRlB0WFdRSWx1V01HMzJ6K2RFZ29oWi9KUUVyUnhWV3BKbElYbVhuNkdCeUJ3WXdQRHFCSUc3UFpUMWhBVWp3M3kreGhETkltVTd6cEprTk9OdVZvTm9EeWRQc2xuQkdXaVZjc28yVkdVR1ZnSjlLUGVpNnJ6SUNkeDJIb25uaHVlM3Y3VkFCb1gvbktWeTY4OGNZYkwvMzJvOFE0Z3IzT3o0a2NnNmFhRTdJV2JXaHNuVXB0ZWcxS0ZHZzA2Skp1V1RpSXVZa2dvRWtvY1ZTclJIQ2VYNDZIRlEyZUNUQm45ZVhFTG5BcVYyT2JPRWFIaklqbTVCQTJVTlpjWU9IUkw5VTdXR1BkcEpJZ3JkazgxYjlJcTJEbm5ReVJVZFV6TVA4dW1EOExyYVNlcHl4SDJQdmdzNW1FblNTai8xRmpkbHJWZFJ6SzV2cGZVZUxEczdHQ3l1eGxQV1lPTHFpTzkvVndpZnFGcXNxTk45NzRpZVh1dSsrKzZEc3BSNnYxcW5teWcvbkVDOXdkVFRRWlB6UmdjWTV0eTRsZkVnN2JNb2psRU9id0FGcFNvZEtZbTRzbVpiclFjRnpnWWhCWGhGcnlET3JaWUJJMGdrb0ZYZURheU5mTGFDdXJ0YkxJMlVBUkJ2VWxKNEh5aXJzREtwNlRQaDFaYjRoa0U5MDVoN2dXcFR3Q0dxdUR3bDdpcERCYjBkZDBJem56bVBJdzVEaWJuSkpRQzEyREpkamdtV1BIUjMyam5pTlpTODBoR1VYdGptRlN6czdtSEVXYjRhWHhkVGpWSk1ld3dRRzBJWjFqTDRNS2JHTVg2YUZEaDE3NGlGcEl6RWNNeW15YmVYdTFLVEczamxYSHJHVVpmQkJGVlVsenFucWpaRjJUZWNwQUl6N0hxY2djK3VBbGp1QUVzV0I0aVJWSll6S1ZPQU9YVlFsN2hBVEdjNzV1NFlFNXhHTE9Bc0NNSkV6N1ZncmlGZEUxcXA0clFjb1EwNFp6L29ERFdKcU5VdEZHUHUrNkI5Qjlzb2doaVlHTUhWSFZqRHRCWWJYUVpYZVdsRmFpdElTbENlZ1p2cTJURkxMQVpyTjVvZDU3NzczUGZDVHJINnRTY0JWOGFzb1ZvbFEvR0ZYQUhsV1BwdmdwcWptREZLakZiSTJ1bW4yUkowV3cxTVNQUVVyRVNQbEFBY2hRQ0NGbUQ4R1FhZ2RielNhbkhrTzBLRk1xWHVRUXhTc2VhNkdHRDFLbWxORlZUSEtrV2lsZ0E4Y1VQdkVkRFNOVnRjUG9kVEQzZ2Nnc045QUFBQ0FBU1VSQlZEV3NHTTZLMlM2c2YzRDZHUmN4ZXlobmhkREMwV3R5MnRBS2N2NWd6eUZVYml4VlN3M0g2R05Pb1hkLzVuTFB2ZmVjK1VqN3lOeFh4NlZZZ2hNWmc0d1VLdWxhUEJScWdHMEJpeWVMSnU1d1U3Z0V0dFFSYUdnR1lDc1hTeU9sNXNvWVE5RVV4RFJoYU5QRUlnWENOSVdaSVBDVWFEQUZsb1cwcmxENnpabDdCUUd5U21kUXRKd3dLcm5neXRpYkNwNjIwZ2RVeGJLTlZ0QmhSQ29EOEZZc3I1NUdxWFp5U3R3Z1NlZktDRmdZQTZqQXVRbVZCUTN1MkdRTXJoQUl2T1YzaWRXQWlOS2xpUXhqRmg1OVU1bVBWSFd3NWpCSmhpTUxPN09kZE5KSlY5MTMzMzI3SHVGa1dZZ2t5QnJEbURsak55S0hJV3ZqeUhZRkQyZmlqRjdPMm0vVm9pMk5DRHpCR3NOVnh2aTh0dU1BSmdHbmJkZUlGR3J5Wkp6SXdVWFdVblF3cEJiWWs3U1lKblA2cG9xc0d0em5Dc3BLV1RUR3pZaGcwbEp6TWdjOGVPakVxb1ZOYXBnVTVXMkZBMlVVUW1ZbXdSbEdPNUVhamNFeEFhUE1KdGtxRkUyV2hqT01pcGpKd1lXam5EeG1xaVR0bWVwR2Vyak5aaE50V1phcmp4dzU4b2duVGFubUlqb1hWN1JCeEJQWkMvZzlULzRvSkEvbFFRb2hrSllMQzVWNXJvNkE4L1FUVU5YNUsxcmdhRFZuVjFlWlJoM01sRmxFTFd4ZUZxbE1vQjYzTW82aElvT01Nd2FxdmJ2V2RxRHc5VGdXTG9sekQxZXY0SmprS0ErV3hzOUpmMEY5QVdTMXNGVnJ3ZXhZbXZhaG1CVXF6amdRSFNYcXFya0l3NUtTYTZuNlNYcXVhV3hPZ3FabUtJUUNmZE9saWNqYmUrL3lpQ2NLUkl6UjdPSUxkMmFtZEhWcVYzQWhoRk9VVzQxQWJWeElsUjJ6Ym5KMzBFdHdPTE5JRm1PYVZNcUg4Wmp4QVZjR2xQT2ZwM3A0elBDbngwSk00Nm5qWldZcGpDa2h1NHRyMldTVkJoWDZ6bSs2Z3o0T2lUSDRZVkRWWXdCMG1Vc3Q3a3pYcHA2eFpPamdkWnVOSkRuSWREYTdWR3FaYmx4Z0lrTmNPakpWOVRrMmg0WlU3ZkRqWElJQXpFeVh6V2J6eUJkL1ZiZ1FhNURXSVpieitzTUZhSmw2dFVHTnpzbWNhUXVKSVVDK2V3NkdCbnpKOGxZZTVaSVBWMlNkdTZFalpPRjhRY3NqWWdWQXRQazZrZmRWbll5Z2wvQkxGRkJPSXFuU010TSswYkg5V1hlZ1I5Q1lsQ0VpUGRxUXJQdkVHVkl5UEV0ajlQSU10Y1VWQW9PNWpuRzFZem80RzFQWWRBN1JRTGM2ZnloOXc3S2FCQkxWSnltVzZYSkpyYlhSNVdjSWFqM2RQYlJSdjBodlVBYXV4ZTJJdElpNCt0SE9sY2tITytmdTU5dlBvMXQ0Z3NhY1daUFR1VVk0cURLdERzOGVxZ2dGeDcvbnYvTzRseGpmZzBlOUNHTm1McG9tM2dBRy8xN2oyVGxDZkV6WnJQTURoQmRXZUViUVZMOVU3U0hmSzFZVFFpcmpaalBpSE00Z3dSbEVPLzJGeTZwVENxdlJOcHlyTkkrU0N6Yk8xQnpBS2lYRUdDZFhRTEdZU3RHWXdsU0dKSTlhVkIyVDBWd3N3MmM0UkRIVFhaMDRoTFN4TkFDUDJnQ0dJZkRxamd1ZlJ5SU1OeHNQbXBFUDFHRUxHUnFDNS9xMEFuRmpNbGppZ2ZTVVBKQWhBcEVBSWMvNXFVc2syUEVhd3ZDQjhUT0pxd290TzRZcVRSWndHQTJSdEU4RVJXL0IxMXRWQ0lYeGRoQ0hTQUhvY0NnN2h2L1RZOVFRcXlxSnJCZy8xcW1IeUVXS0IyR3pTalhXaktaaTRkQnNuMjUralQxU2lUekZMeE5Zemg2Sjc5b0FCQldqbVo3eDJKYkdWWmFRZVZSYmkzRjYxencwS1dua1NyOThSZjhXUUZkT0FWR05zZXVGTHFpT2VTdXdKNlhuMWdRNnVtWS91ZHNybTVqNGd3ZEFFSkVQeVhHQnY2SDJqVlV0WURLcXZrT1F3bEp5MGRPWUVyUUt6ckZxcnFtcDVSSVlhZUdZQnhua0RWY2piQVo0WE5IU1EyMmtxd1lidHVvUDJUeG1RK3k2RmI1UWFCT1I3OW9EdExxc2RXZ3paajFBSkUvNnJNbmVkZmh5Y0F5TThnaVZRQjczQW8zaGxHdFJjOXdMeFo2cnNES1BjdkhCKzQvZGo5WDByUHEzQWkxa0h2UmNpeTlqRERTbUNQekJhZGtxOWN1Z3pSUVJZMXpNWUI1OU9wUGhOV2hNamxYUklPYjBVTWZPdG5WTTFlTU9ucUFVeWtORE9OSlFHcTRVOFRWQlkxU2FFZXZyNGJQcnlRTnRXWmFyM0YyK0d3UElPa2U1ZTU2K3ZiN3dMYy96aVVybmlNcWxlQUhKUlJRb3o5amoyWjRTRTErTThDRTVrVFJXMDdObGtpTEZDd2dUcUpxZnBsaTdhQms4ZmpXTnpqSXlGME93czVWODFUbyt5dHBWbTRGbk04eEtUU3dTc3l3KzkzWnlBNlBLaU1FUjVJa2tXRFduMVBSaTRwOHhwejVWVEJwVGIrQ0QyUEhWeE5PWXhTdVNZUmx5TEJWTk1sdm0zRDNhOXZiMi8vS28wc0NIeGdLZXBiYzY2YUpTTUw3Wk9tcDFoSTV5dlpLcUd0UTVQUUZFOHdRd08xSzJpcysxK09tMjZ3eWZvcjhHMWhxRFN4T1J5enF2cnJmdEdCaGxCL3UyeXIzWGg3cFpTY3hsUmVRTUE1R2hBWENzNXZwV2YxNzFRYm5zMEREcW1BUXlsVDBpTWp4SkZiZksyNkRtTDJvTm84d1BJcEhVTVhnSVJoRStxSE1XK0w2VDdhN1VKZEI3ajdabno1Ny8rWUVISG5oTUk4Y2pDNjZabm1raDh6Wk81VlR1M0VMZ0E1bXJBaTFEaEFSbkRyTUZ5M1VldXhyVTRvbE9nc2V4a3dDcU1CREF1Qi9xZ3NxWTRiRERyOGVRaE1VRWxCd0toWlhDQ05WbEpPdURKRGdVYTBmWmxvS1dBbTJZOXcyWml1SEp6eFZKSXdQRVZYT01zUG0vS2lWcHNERjIrSmltS3BHVlU0YWNBb2tLbmZNWFZtUVVaTDQzTXp2YTl1L2YvejhlUG54NDEyTXhBT0ZaUUxyS0FqSVAxYW0yR2VlZkNFL1FiUE9jZ0RxMlBSZ0N0TksyR0dsZTAzWE5QVEZGdVVtTU0zWmkwS3N5eHF2SG9Jb3JkazkydEFRWmsrUnlUQUZBck9UcGc1eUpTZlRFbWlUQ1NsMFVuRTBhazFLdWFXTlNJM2FHMFFRUG81RFJjVlNIWWhRSElZTTlsQ3oycUF6RmR0cVRZZGFUWmZSZlBGaFRFQzZrZ2F1KzVJZVgzYnQzM3d0ZzMyUHlBT3lMSHVweEVSWmJOckJseVJxQVR5R0ZlU09QSURBVE5LUytUalM1bmVZS1ZZTkZ5MklHREQwYWxxVUdPQWtMT2NsMDFlK2tjUjV2Y2VPcUxLcndPSmR4WUpVQjZoQmJFSTNjZU0wUGp0UTJhTTBLNE9IUXdmZGZES3V1cW9KcjJqaVBpcTI1bnNKeE50bFg2ZUlqbTFBK1JpSVBTNnV4dVkxWVVVd0h2QkNUK2tkKzNrNzE5T2lNVXFqa3hBWGxkSE8wbEppTDFneUYzS1I1cm9PVko3MjNIVGh3NE4vY2R0dHRUOE5qdktYckkzSW5nU050S2NqRndzN3F2Tjd3Z1JYU3l2TUE2RUdyRDFSUHRtNGRXMWx1MDBqaVNOYlp3M3B5cXN3cElUb0tLckZTeHNTWVVWaXk2Vm45cTFHeG5HT1VCd1hOa3REb1ZLMVB5S1BvNkQzRzdoeEV6MnFnWkdrV09Hc1FScExINi9sM3prV1MxWFEwZFptak5ZSmdPZXBRaTVtV0RnSHJhbEpLK0p4eGpBQmFhLys0N04yNzk2c0FYb1JqY0ROek5EUVlIRzFwSEtlNjhNTVZTNlhRTUJpb0ZSY0RaQUY2WUZrTXdES2JJVVRITElMVzJtZ1ZDZ0JiU0NYU0VpMTNtSUxqYVlNcEtUOThBK2NDQ2oyQTh2TGxBWS9wZVlwaFRKV3RpN0FzemRFeEFLSnpONVZwREpKSlVFZkMrSEFQUGQ4TDVXWENnZHFsNUhHU1JVMVNSeWtJU0MvakU1ak9rZm53NGhZeVliVVZXRFFOTlBOa1NsZHFhbFdaelNzbHRwVjAvNkxUY0pmbHBLOHVwNTU2NnQ4RGVCV095UzNWUWNJQm9abmVwWkxXbW9HenBPR2k2WUpoOUg4R1dmS2lkTThTYzgyVkwzNTlJR2xwWEtTTWpkYm4vZHc4dFlnSWROVnhTQlVrZ1dTVEdEMEJ5VWVra1NsYnlsTlowRGptWXg0ald3V3VDbStqeHpBRWpRTWNFUzFsNG56ZFVlcUxPYUVrWE1rYjVLSVlmKy9FTC9BYWZ5dXJpZWtGYnNkTWRlb3pNU2FRZVhnZVdWOE00Q1pyTGk0N2V5ZENPWnBQRlJhT3JXWHI3NWRUVHpuMUV6aUd0eDBITGtWMnVNQUVDNnRhaldkcktuZHdJWGp2aG82TVpaa0YxS0lhbWpZWUFzcXhMcUdLYm9MbWx1Y0lnMktMcFRFRU9KcmxQQjZKZ0xZRWY3MUt4NVloYURTYWtNOHdGb3RFTkdYcVdteGRIbG5ua1VKWWtIRENxbmdUYWZHVWZ2RkVWRlY2Sjg0WDR0d0VsV3ovRW8yU2VsQmN5cUZWSW96Zm1KMVJFWWpHelNDVXJ5dkc0QXNUWDRsekdIODBlUW9selcwOTZmVHczSXk3VHQ3MUNZa0liRzF0K1dQaUFoNmNGYlE4N2J2cGd0Ynl6TjNXR3BvMnRLVkJKUCt0aTJCcExUVUd1dVQ1dkEwOE96aFA5bDVhcW9JWHJUT0RCU3JMdUoveXVaVnNaRnNXaWxFMHk5T3JFOFNsdFJXYldOekUvRGt6RkozOGhwU0tPTEdJSTdqVGlwQ2k0b2lwclJpcmhvcEJQY2RxVVlUS0hhK1VkaHhnZ0IzcGJEYk84cjJYb1dyVitXTXltY1JkM2lZWGxWZ3FYNitORXZOYWFRejJWa1Q4M3UvL3ZpNEFjTnBwcDkxeisrMjM3enRtWHFBT1d0UVVKb3EwY1Z3S3d0QWsyNjhVQ2pkS3NHQXdGU3cyV0hTMEpubFFwRHRjbFUwTkRCbStPaW1CNllkS3k1TTFtTk9MQnpRbzc1SUdSVTRGRTJvVGdpVmE4SWpaVVRQblFkWEJneTNkQk5FczBVTU9DRWJRbTFYZld4UkJoWnhqUEhMMFF2dEN0RjZkVGlVY0NhV3FoM0l2WXptYzNjYlFXVndxRHNvY0k0dENPTlExTVk0RUFoMUNXWjZ3cEcyZVJtTVJlZTFGSVUzdUFZQ0Zod3pjZlB2dHQ3L29XSVlDZ3pGOXlVVmVhcUNEdGZ4d0xVT0N0RWFCcEdEcERtdkthZUlabzkwRDNoYkFITTBCYnlrZmE1RUxtQzdjRTFSS3RvaXJDSU1NZ09aUTBaekVrWUVuczVHZUx0WlJSOE1uTzZic044aDBtem04QU5Kem5MelVZUlU4ams1R2s2bU9FWElzWXpIbkZzNDFyTzRseXRpWXAzdDBUaFlUWmpROGxCb0o0c1pRekNxWGk2QnhWSC9paHdZMW0wUzNDdENwbkI2SFlXbGVZK29hbWdpMlR6cnA1bWtBWjU3NUtkeDAwekUxZ0ZTY2RHQnBVRFQycStVd0NWbm91b3lHSWtnUjZaS3MyR0pJZkdBR2w0YWxkOWl5SktpMDlDRGhnR2xIV0I0cHIrNHdzcEJpRFNFOTZ4T2h6SU1wbWdwSzJaanVDZHBBK3BWMTVIYnVQTGd5UFpDeWRPVXJIV0dIb3ZINGxod2NLNk9vRmV4L3JDeWdxbkhwd0tqbUdkb0c1cThXQTZnNWdGaVdNWmpUZStLRVZzYkV1b1N3WDdORzdLVURVemFDWm0rQUVKektPTjdPY2ZMSit6ODFET0RNcHo3MU9nQy9pV044QytRWVBrWFN2T1lPYlFZekJXQm9EVEJwYUQxNzhGV3o1ZHBDNlA0TjBRVmRHcmFrbyt0V3JwRjFSQk9JYjBHVlE1MWFBa0R0NU1vclpZdEE4MnhhOGREUnlxMVFvQWtuZUNxbFdJWXVRc21pNUJ5RGN2bFVBVWtySWllcmZ6MWs1WTdaTUlzT0ZkM0JJSXJTL1h1SFFORlhwNlg2Nm9oYldBMm1VcUQzeEh4REQ5ZlJzVUE5NXlrSVZVclZtNUJabDR5bW1SVE1aT29vQnNRU21SUkVZTytlUGRleEdKYnZldi8rL2ZjZk9uUm9GNDdEVFJaQnc0TFdjcmNtU0NRb2JBa01Fd2dLb050b0M2QllvQTFZWk1uN2EvNHMydEEwbGNnUWdrdkpITDhKUWFRb3NBZ2FXcEpPTEJhMUFRSUJhRU1yZlNJU2tPbEM5WkxFVkJDVXRuRUZzb3FzU21FclI4aFE1NmpPTnJSQmcyUEtzYWx2RU9pbzBPcGdubVVIWXg1OGJ4S1RLRU5naWxHSEpqSVEwdWpkVnRvSWxNWkZCenRHd1JZZzdjaDcvL0M5Snc4UEFBQlBQL3ZzbXc0ZE92U2k0MkVBWXc0dVAzVHpsdWxJNDBsYkRnZ1dXQUFOSGI1UnlGYlA5alBwME5pQ2VVLzZ0eWFGVSt0dk1LQzFIR2dwaG9VcEpBakVvbEVPRWl3NnRlcjlNM29USFJlMEdTK2R6bjZDNEx5ZlVpUUhpYU5rbEpPdURmRThwbWJVRjBCbDBVcHFYdWNpb1ExZDRKcE1US0NubzJvSG5UZ2dzd0FqMlNVa3Q1Z20xK0ZjSlJjamJTd3RzNVdPZkcrb2Flb09uSExLbnB0cWJhWUJQUDNwSDczcGkxODhMZ2FRakpvTm1iTHFuT2tIYld3SU16UlZkTXZtanVnT2EwWmF0RU1YOHZxZUpFMzBEVnlXeEFNOStTUVZRWGRCSzQ2OTFMRklyeU9SOGJJMVpXOWVnOENHTjNHZTNBa09mUkRvTEdOTFZkZlNUU3NvMXpLbVYySWpMZ2RKN2FvdmxKSkFJT2ptZzE4SXpMNEFZY2dURjNnTE5BNStHc3JwRUhSaldiYzNhaWJyRER4S3hLalFCZ0JzRExJQTZBSG41MVBKc1QxN1RqbmxvMVBmdVZLaUhHcys0RnRwQ0xPaFpFSGJRcnJvdG1CcENpeUtCUXB0TTdjWEtOclMwSnBBcFRGRXBGdlhCV2l5QmJSRXRhcnNBMTRXU3RFRm9vMWxaM1lsdDRXOURia3ZHMlZzcVUxUWRpYW4ycWhKTVl5S1VocEVVNmpIN0x6QjdEZ2FuSUd5N3QreUpiMk1wMVErSlQ4dkQ2QVVhUWdiWllWSVhldHNJeUwva3NLQkZVWFJWUWlJUnRLSVFMREV0REVJemRHdFpCRng3YlhYNmtNOEFBQ2NjODQ1LzNqenpUYy85M2daUUIzaDJzS3lPN1hsTUFZVG9CblFCZGdXd0tVQjVybW9ZYkRlRUlzaHZFR2pRNXJDKzVMZHlKd3dsMlhFSEZvSlpET0tVbnVvTFJjenJLT3BzR1lBbmxaTzZRZjVBSlVFb3p6SVBPdU92SHBoYk1SZ1Q3Z3Fhd3lzQTBoTjg1SUc2WkZ1T3pSbkJESjlWTFhSM1pQRVg2TW1Bck04SGgxZEt1dklUbWtldDhxeWNSMWlsWjVVZlFQRU1zNUFrdFdnVFpFMmp0c0pFWng2eXQ1L2ZOaEJrZWVjYzg2ZjREamZ4cWd6Snpid0hITFFlZmFaR2NhNWZRN096a2ZQNzVaSHZQUTZkTEgzUEQwamNvanl4b05ERkRySDNCb01IZDA2WiswYWVzK2hEdUdHamp6bDB6bDRHWkdqVk13N091Y2h1bk1zamVkUXhqNk93YzMzM0t2cjFqamF4Y0VobXB3TzR2a2V2ZGZuOW5IMFREWFNCcWVnZ00rVDQyOXNIQ0JoYnRoWUg3Ti9UZkkrMWp2Z2pnNWdZMWswNjU0Tm9kVUZiWnZPcWUwQjJBYjc5NS8ySnpzbC9yRlRLblB5eVNmM0kwZU90T050Q0trV1pqZ1FvRzF0b1lrUXlXZWN6bDREeFpJOWFHaExTc0pieThFUldKSnlscWI1SFEyeXBCcEdtU2xJMGJ1QzFlOElESnVPTHFHU283Y2hKWk5SWDI1b1UxMWM3SjZtcEt0MEdNb09KTW4rT0RRWnNTSHJJZ28wenk0bmNJZU9waFNDMDlJTGFzRkh6VlEwQjFyTDhHb1BsdG9MUitrbExtQ1dRVTgweXVEWmVtY2Z2TzZETzd6K1E2Umd6Mzcyc3ovOWhTOTg0U1hIMndEeVRPRkFMRm5jaVkzQnlQS3B0akdLRmhESXduSnZaMk5CZFFkWkd3ZUdtMlJzVjFPZTE1T2dxa21ETjZQZ05JK3hVNEFsMUlCNnp0SlJNcENkS1ZzcjlVZTUvTWJCZk1wTzZPbzJOaDJEb2thbDBIUjBFRld6NjVoK1huV0Jhbk9uaU1NdFVLU3dWYTJpNWdWYUhkc25VNC9nSlluVEpMMDh5KzdtZ2REa0d0UTNxVGRpZyt4VHpuanFweCs4RHQvS0FLNyt3aGUrOEZkNEhHNFpKanNrRnFBNW1yV01hUWlZTG9BNkdoSUQ2R0k4cVN3Z3NxQjNZRkZEWjIrQndoR3Rxc2haUGxhV2ZKdm56dTFCb29RaURPVlpRdHFFVEZ0NnBUd0ZUVWJPSDlvaFhVZGphY0NvR1JBRU9vRWN6eTl1RGMwdGhSN1NXQXRKb05ranVmcW1tV1UwU2NEWHZaVExUQTg5SU9yVU1IQjB2cVltUVZrYUZoRllueWVaQXB0TWtkbFVhMUlIVU9vUTBEejF6S2RlL2RBdXI0aUhMTXlCQXdkdXVlV1dXODdHNDNRVEJacHVwU3R2aWZxYnNHcElhZm15RUoyM2JBelVscTY5aUNKUlBrWVpFdWhDMCtXelV0amFRT1dOUkE3WTRwN2tUNExISFBtaTgyKzVYTWhLc096b2FKNDlnano0bXB5OWtxdVFHaUxVYWp3TUFhREtnR0hWSEZ0dFlaVXpRT2NZVzVWVS9qYlpPZE1JSVRsQ0ozU2xyQUtsYVpTc3FlRFV2YWZjK3NjZitNRFR2Nk1IQUlCenp6MzN2YmZjY3N2LzluZ1pRRGE0OUp3WjRJQTVlL3dYRmdnaVVzdFc3bmxwby9teUs0VW0wVmhCWkFkT2RRQjc1TUxSZFRibTdLWU42QTJ0QlEraDVPS3hNQVUydE9SaERKd2R4UGd2MUFkR0pPT25ISWVqckZFRTFiMURJYTE1N0UwUERJbDduVHFhcVVZYnlsOG9DU1VPNFpESWVvRGxHRlJLdXhzZ2ZiS0RuTlNXUnRHaDJuSk1MN0pTR0JFNDY0ZCs2TDNmdXMvelczZ0FBRGpqakRQdXZ2UE9PL2ZoY2J5cEFxb0xaRm5Rd05yL2twQm9XVnIrRGFDbUFGQnFEa3R6SU5xd1NQTDZVR1VkUEhldXRBU0pMUWNLb0dsTkNXT3FSTVp3RHFnb3NVanlES01YcFlaU3FhWTRRejJiWDlnb290REVGeXpsRG4wZ3BoZkFvSUtEWW8xcWM1c05vVTJSdFF0NnArQjlRd1dJeGtNMGNreHZOR29HeVI5SXFZT29oOSs5ZTgraEQzLzR3L3UvNVRWL3VNVTQ3N3p6M29mSCtaWURrQjF4dENQTTBOMWduSUhUeldCK2RLUm80UWJyZmN6S3M0MGhlb2ZiQmtjOTA4TE9OTlBORUVjZHdmdUhHOU84VGtsVlg2VjhPYksrY3hSdXp0cnJtY1o1d0t6RGdtbGZkSmc1ekhpU3QrZk1IdTg5NDcxWmp0UU5qbTd2eGtNakxMVnNZNXk5STJJREh6UCtrWU9lbmEvQm1iOVdaeWxaNTRBdWgyR1Q2U1VIVXZzWUQydm82TEJ1ZVByWlo3L3Y0VHU5SDhZRFBGRmVZRENHclJwTDJ2aDVGcEsyb0NwWVJCRk5zb2UrdFl5WFpBYnpNVG9rNmtJV3NVbDVBQjAxK1BYT3o2SVN4N2NnMDh5YTU1ZWw1UFFBVVNxajBSOHBRd1FhTzRwSmJIUWhVYVNVZVVHcVdOUXl6TER3VTQydHBWRXN6RkdIVkNObStsaktvUFFPaWxBZlZMQ3dIM0h2bnBNUC9kbEgvbXovdzNyZGI3Y1EvK0pmL012MzRBbTQ1ZXo4bmllNldSMmp4am41UGRENzBTU1BZcE5hUW5kWU4vVG9lWElKcDJkM00vaW0weHVRdkhGRGJOSUQ5T2c1ZDUrUEJ3a2VzOXpGZVhKMzd2NmNoRnU3UGQrUDk3bER3enJDQXAzMzcrR1Q1S3BUVnptbk4wbWxIQmNmeHFsZGZSN0hZOUZobXo1SXFweitaVHlwTE1aQlZCdDZLck1zUWNNQ1podWU4cHJlN29lZjhjUHYrZmF6SHI2TkIyQ1I2SlpiYjczMTdDZkNFR3IzNkNJUTNVWnJZRTBnSjVVbGFxZHVNSVdBRUN4b0hGU1Z4RS9WRDJSMEx5dTFoMEJMcFZLUlJhTi9VZEdVdTVCMWhKcFJnRFpvbW9FVmdzUlc4UWF0Y1ZpREVJZ3kzb3ZtT1FuVUtqSCt6NGJUZks3eUVpU2tmUFpJWlArbmpDYVhHalRWUmk5Ull6YVQzdXIwMC9mZit1OC84cEduZjd0ci9CMTdBbi9zeDM3c3JiZmVldXYvL2tSNUFsQlVJdEZITzFZZUxLYUlabU8yOEtZMXFBbTdFb1IxZ1hTeHdxNGxsNWJUUWlNUTN0QzBZd09CdGx3RU5RQ0xqbzRkcVBEWTIyVDNvczRkVW95RmRRSkxLK0pLVS9HcmxJb2IraGcrQmZic0c4VWNBYVRFWGRtMlRSbDc1L0d6SWdLWHJGaEdwRUIwM1EzdDVBTTZjOUVtUFUvZVliaDYxck9mL2RidnVNbStrd2NnSUx6K2kxLzg0a3Z3Qk41a0plaElDcGtjQVdmOVNjc0tuclRHSFYvNVBtY09aOXBBcXJneHpuTEdRZFB4dmRLMnhnVnFFTGpxbUJJNFJDSDBNTUt6ZjlIWUZoYjFmRDZtY3BXRXJTam1tdDdSVnQwOWF4Vnl4QlJ5VkZPVWlZNGVwQ0JsN3NFaFd1d3BiS2llUk1FNXovemh2N3ZtMm10LzZwZ1lBQURzM1h2S2tjT0g3enZwaVRTQ2tqZW5iRndoclkweGNDVU5WNUpFNEh3QlJRT2FZbWxUNGFPdHBwbHdKb0draGgvMEJqVlVRZHQwNFZBdUdKU3RacXZ4Y2dTQnlScm1FS3djZWJjZWswTnlDVDdtRlNXRDZFQXM1VHlHZ0tUNkFndVFWdWtZN0JLdXVReGdhcWpENElDOWUzWS84Qi8rdy8veGlOUmQra2d2L290Zi9LTGZ3Uk44cXk0WTg1bjYxWG04M1RyTURKc2U2SmFnTHN2UE9XdS85ODVEbUh3Y3ErcE1HNTMzTSt2WVdLYWVzS3BTWnZvV0cxYitMTlBQQkk2TzZEeXdxZk9RSitzNW9hemJmSitWUm01c1ZCS0RxV3FlRzdGSndPZzl2eUpUMUFoRDcwdzVDZkEyMk95NEJwRW5STUEzSE9Wdmp1Yzk3L21QZUswZXNRY0FnT2M5NzNrM2ZQbkxYMzRSVG9DYlVGNjhOTEJxS0tQUzE3VHRBSHR0TmFzQXNuYjNNZ2dqSVpDYjl5UDF6Qk5UdE9VNDJpS1paRFgrdmdSM3lubjNNdlI0TmZxZWN3VXhaeG1WWkV4VWtrOGFrMm1UZWc0c3BJSmpIRllRcWpsSXN5WURpbUJSaWwwcFd2bVJIL21SejMzNHd4OSs4WEV4QUlwSDd6dDA2TkNlRThJSXh1U3h4QUNxcWZRVlo4bTRaY3VKVUZBS3lmSnZsbmRqTEk1eXRtMHVmTEp3Z1RxclFFYlR4OEkrUTlhVFo4WUF3SnV1QmxOUnNEck9MaUxxMTREWFRLVFZ2SUo4aGx6a2tmTkxGYlJXa2pTMnJvM3F0SEVJcGdRV1diQjMzOTdEZi8xWGY3MzNVWVhWUjN2Ukw3amdnamZqQkxuTkV6UjV6cDV2ZVBxbXcyekRzL2V3Y3UwWk5ucmwyTVVOUkNlcjEvUFVyWjdocHNLSzl6eWY2R2lGQUlwRnd1anFMVElVZEV1MmNKT2hvVnV5ZnNhdm8yUUVPOThUd3FhUXhEYXdtT0hMdW8xempLMk9mT05ad2RZNTlqMXNIRTJ5c1Fmd3duLzV3a2U5Tm8vYUF3REErZWVmZjgxblB2T1pTM0dDM1VyOEljT1Z0MVZJVUxSV0NMK05YTHhwZGh0cGFlckpCQTZtYlpYM2E5VUp4cEJxWkx2WHdoRTRXcGxEdHFTaE9ZYzNWTk5ZRFRPaERvQ0Zuem9xUlZmOUZEa1JwVGdDaFNwUEUxT2xSb1JpMEVXQmNQekVpMy9pMnZlLy8vMlhQUzRHQUFEUFAvZmNnLy93cFMrZGp4UE9DamkwU211Z3BFQ1dMQlExeXJPYjZqeXFwclZVOXJSTTZXcDIwUnhaUy9Gb3RYcU95V1p0akpMSjhqTlBOb0V5b0xjSHVkYzB3TldJb0RRazlnck81ZGRSR0lzcUtHRTFRaStBVlZVSkdvcHpYM0R1cHoveVp4KzU0THU2WE4rdEFWQTM4TFZiYnJubEFFN0FXeXZpcHlIVnhHZ3pkd2VCSXcyaVBJWHl2Q0p0TWdpZTZ0UklHVnJxK21NY05hUTVBSnZhZmxWWjU2d2MwOFlCMkJ3TnFycGtyTmQ1THBHMjJWVUVCYlRtLzlWUTZwcUNUcUpLM2NjczRXY2NlT1kvLzhlUC9jZG5mTmVwOVdPNXlDOTk2VXVmZGZycHB4ODZFUTBnRHhpWjZhSmJIK2Z1bWhkbXNDRzZORE5zckFTZWdiQ2pUQnQ1bjI0NDJvR2p4QllSaGsxc1lQMG9BcDJ4MnRBN2NjY200QnZHOE0yR290WkE3NXZ4UHZKa2RyNjNlbCtiVkNSbnBrb2hiQ2NXZ2NIc0tDeXl0bkhhVTU1NjZJS1hYUENzeCtRd0g0c0hBSUJYdnZLWHovdjR4Ly9QR3g3NW9STlBYR3hvVXNHVkpKQUtkUUE2MDhnaVhHcDNjNWRJYThuMHRhcnZLNTlxVEFHZyswKzlvTGNWNTEva2ZoMU14U2tpdnBwWUw3SmtwMHlzUEVMOTBhZm9WQ05Kb3RQMzd6dHkwVVgvM1l2ZitjNTMzdlNFR2dBQS9OSXYvZEtGSC8vNHgvL20vdnZ2MzhLVDREWVhPMEdlcm42WHYwbzFiaFdNVkhOT1FJdXRuR1ZZUWJ4cGFndHBGRW5mMXFJN0ZBdHhRWnBSZGh0VGowaGNBWlYwNlhWbVhnRStueWxlSGdyR2dacXEyTHRueitabmYrWm5mdTdkNzM3M0p4L3p0VGdXQmdBQXYvQUx2M0R4Sno3eGliOThzaGhCMGJOUVdYbUEzTWZSMkRqS2ROODFPWUVHSUZyRzhGYWtUMEVBWlgxaE5ZU3F0ZElRckJvMnEvcjRvRUNzem1xazUvdHc4Z2FESEtZK1llOHBlemMvKzdNLyswdnZlYzk3L3ZxWVhJTmpaUURsQ1Q3NXlVOSs3TVFQQjk4Q05MSmpXUGlEa3RDUmN1MnRzZ3VtR3RvRzJGUnA0SG1xdVpxTHp0QUJyTTQyS3ZQZ1dZQWxCRVVKUWpNVE1SVnNPV0RxV0xDa0ZGd2RUem50S1VkKzV1VXYvKzkvL3ozditlUXgyd1RIMGdBU0U3enl2TC85MjcrOS9xNjc3dHFISitGTmlwbGJwWHBLeWpneml3d1Zyb3BsVEFHcUIxS1BLSmtFVnFFb0IwQm0xUjZ0aGczcVZBZmhvZWNxaEFaYTZQanIwdytjZmVqQ0N5LzZxZC83dlhmZmRFdy83N0UyQUFCNDdXdGZ1M3pxVTUvNnlxMjMzbm9BVCtxYnJOSkRJTENWWWt5dDVsSE5LU09xRFAwcm1WaVRxUU5BY2c5ZVloQm1oVnAxaG9VLzh6bllIVDRlZSs2NTUvN3poUmRkOUt6ZmZzYzcrakgvaE1mREFFYng2Tnh6RDM3NVJDU0x2dXU2UXhFeXVlRGFzaFBGQ2M1MGZkOEVEeFVOQmhmZ0xERUo1LzFxWlJLeDd2aVZNY0xtSjM3eS9FOS83SzgrZHNGeCsxekgwd0FBNENkLzhpZXYrZXhuUDNzcHZzZHVVbkt2M01xajdWczFZL3lpaWpxMFN5VXJOeXdpL3dBQUFxeEpSRUZVaVRWRnBPWUxxOWJzL3EwVWRLNFlQNmppNG9zdnZ2YlAvL3pQTHp1dUgyUU9kVHgrWHovM2N6LzN1bjM3OXQySDlabngzME5mMUd0a283aElpTFJvVFdLN3RWaTJsOWplMm82dDdlM1kzclVyZG0xdng2NWQyN0ZyZTFmczNyVTdkdTNlRmJ2MjdJcmR1M2ZIM3QyN1kvZmV2ZkhjNXp6M3Zzc3Z2L3gxajhmYVBDNEdVRi9QZWM1emJ2aGVOWUtIR0FWN2RrUWttclJvalY5YkxiYmFWbXh0OFd1N3hhNnRYYkc5dlIyN3RyZmpvb3N1dk9IeFhKUEgxUUFpQWk5OTZVdXYyck5uejVIdkYwTjR5RmRETkVoSWsyaE4waWlreGRPZTlrTkhYdnZhMTEzMWVLL0g0MjRBOWZYOGM4KzkvdnZXQ0I3MGRlR0ZGMTcvUkszREUyWUFFWUdmLy9tZmYvWFRudmEwVzc1ZkYvNzV6My9CTFpkZWV1bXJuOGcxZUVJTllCMFdUai85OUx1L1h4Yit3SUVEZC8rcmYvWHFxMDZFYTM5Q0dFQjkvZlJQLy9TN3ZwY040Y0NCQTNmLzhpdC8rVjBuMGpVL29ReWd2aTY4OE1JcnpqNzc3TytaMFBEYzV6NzNsbGU5NmxWWG5Jalgrb1EwZ1ByNnhWLzh4WXRmOElJWFhML3JwSlA2azIzUjkrN2QyeSs0NElMcjMvQ0dOMXg4SWwvakU5b0ExbDh2dS9CbFZ6M3ptYy84MHJJc2ZxSXUrdmIydHYvb2ovN29sMTd4aWxkYzlXUzVyc2VkQ2o0ZXQ1ZS8vT1ZYM0hycnJhKys5ZFpiejd2MzNudWYwTkx6NmFlZmZ1U2NjODY1NlJuUGVNWkgvK0l2L3VKM25telg4a2xwQU92YnExNzFxaCsvL2ZiYkw3bmpqanRlZHNjZHR6LzdycnZ1UHRYTWpzdTQyMlZaNG93enpyam5yTFBPdXZtc3M4NzYxRmxublhYZGRkZGRkK09UdXFieFpEZUFiM1g3bFYvNWxRdnZ1ZWVlaSs2OTk5NFgzbmZmZmM4OGZQandtZCs4Ly81VEhqaHlaTmZSbzBlM2V1L2k3dU96czdrMGxtV0o3ZTN0emNrbm4zeGs5KzdkOSs3ZHUvZTJVMDQ1NWF2N1R0MzM5L3YyNy92RW4vN3BuMzd5ZSsxYS9mK25PdDVOQTFlTDNRQUFBQUJKUlU1RXJrSmdnZz09","base64"),
        bucket: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEQUFBQUF3Q0FZQUFBQlhBdm1IQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUVGeVlidldqZWd3QUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBTUdVbEVRVlJvM3NXYWY2eGwxVlhIUDJ2dGZlNjdBOE56cHFVV0FsWFNsSlNHZHhPUVdFTlQ5SjlLVFdzMFRkVDRURTJHaUdrN0l5Rm9hZ3cydEVsckU3VXlBNGpWMUdqaVB5UDlvLzdSNmxoUVdtbWNpSzNSOUwwR1FyV2dMVWdyTUV5aE0vUGUyV3N0LzlqN25IdmUwQ2tNRkhxUy9mWTkrNTRmNjhmM3U5WjMzenpaMk5qZ3BSNi8vNTRGVjExR3ZPMG40YUpyWVBlcklaOERKRUFBQXpzSko1NkdiLzQzL1B2OWNOODl5SHMvOXRMZkxTL1dnWTljditEMUZ4RUhmZ2xlZXkxc1B3bGYreng4YVFQKzh4dncrRlBJc3lmcnRlZXV3SVhudzJWdkpDNjdHdDZ3Z1BOK0dJNC9CcDgrREVmK0Z2bkFuMis4Y2c3ODFlOHM0cVozd21zdWhVOS9CdTcrTW5MZzlyTjd6cDAzTG5qSE80aTMvUXFFd1YxL0JwKzk1K3dkT1dzSE52OWtFVDkvSlh6OGMzRHR6UnZDOStHNDc4NUZYUGNoK09iWDRQZCtGN254TElMeGdoMjRkZitDWDNnejhjUngrTHVORjUveTczVTgrUitMV0x3RmJ2c0E4b3MzdjdEbjZ3dTU2TGJmV1BCelZ4TC8vQkQ4MkkwYkw0dnhBSysrWWtQdStrUDQ3ZHVKSTRjVzhYMXg0R1B2VzNEMUc0alBQd2ovOVMyRWwvbTQ1c0NHM0xvZjN2TlIrT3NQUGI4VHordkE1UmNSRzErSHg0L3pza1grOU9OZHQyekluOTRJTngxNmlSejR5L2N2UWdVZVBZYmMvSWxYeHZqcDhaVy9XTVNQdkFuT3Uvck14ZUtNR2ZpRDl5N0lDZjd2R2ZoQkdBL3dtZnVSM2NDbmJqa3psTTdvd09xYytQWkoyT3BmZnR5ZjZlZ04vdWJ2NFdmZmNwWVErdWl2TDloN0x2SHNGcnovNHp2VHQ3NitmZ0h3SnVCUzRCTGdJdUFDNEh4Z0QzQWVjQTZ3MHNRRVZVeXdCWndBbmdHZUJwNEFIZ2NlQlI0QnZnbzhjUGp3NGNlbjcvdWo5eTA0OE5QRUp6NkgzSERIYzIzTjM4MnJMaEY5Z1dMSSt2cjY1Y0Mxd0RYQWp3TVh2NGhnNWpiT0JWN3p2UzVjWDEvL0J2QkY0QXZBM1l2ZGZPVmZIb0pMWDBzMFpmWDhEb2hBY2ZqeU0ydGZBcTU2aFpGemNSdnZBdGg0ZHUzZlhuZHNremRlK0FJaHRMNisvdVlITmpmdk4yQnRiWTNOelRWK2tNZmEyaWFQYlc3eXk3dmh2a3ZXZnVMdzRjUC91c09CSTBlT0lBZ2g4SkVQZjVpdTZ5TGxSTmJNWisvK21RYnBPVEJyOC9UemRIN3VXdGNKOHpuTVpzdVJNK1BhN3QxMXJLNHU1OVZWdVBkZTJMZXZyaTBXRDZBcWlDZ29LQ3I3OSsvSDNTdUVjbDZpU0pNaUFvcHd6ei84VkRNbXQySTF6S2QvMWduRTgzaFBTa0xPUEdkTW5RRlFYWTZjbC9OdzdjTVBYNGE3Y2ZubFh3ZFZGRUZrU1lXY2N5SkNFQUVSYlo0S2IzLzdGOGhkeDRNUHZwNnZQblJsTXl5ZFp2anNOT1B6Nk55WmpKL1BkNjVOSGFqR0J4ZGZEQ2RQQnBkYzhpMSs5SFVuMFpSQXUycWpwdXFBQ0VTUVUrb1FDUWdRcWQ0SmlvaWdBb3UxLytHS0t4NGxwMFRPTTU1NmNwVi92UGVkbkRxMTJxQWlNQmFJT2xJQzFSZ2hjN3F4dzJlb2h1N2FGWWhzY2RWVlgrVENDNVMzdmpYWXUyY1BzMTI3a0RRbmR4bEJFQlg1dGV1dmJ6WUtRU0JIang0ZDB4RUVIN3psZzVGU3B1c3lLU2R5eXVSY1IwcVpuTFdkZDZTVTJsb2lkWW1zSGJsTEpFMlRleEk1SlhSNFprcDE1RXpLbWF6S3lzcU0yV3lseml0emRzM25yS3pzWWo2ZnNXdGxoZGw4anFvaUlySnYzM1dZRlVveDNJMmNja2FvblRwcUZrUkZvbVpBbGxrUlFScVpoT1hhUUxBa1dqK2pxTzRja2hUTmFlZTZDRWtFVmEwSkpCQ0VyVk9uT0dmWExzQmJtVkZVRTJuV2thVkJuVHFQSEdqMkU5R2FnTkp3cGlOaDJuSTkxNmxEdzlDSlE1TzVqVFE2cklncUtTMGRFdEgyQWtFY0pGaXU1MEFGWmltaGFjRC9BSGZRQVNJcFZ5aG93eGZ0THl3TlpPUklmWkNPMzdFalUybHdTQ2ZPNldsT1RqT2tncElRNE5peDQ2TkMweVNrU01PMThxdnZmamRMWkZRcHB5bFhQRmFTcGgzZHVFYTVSb09Ka2FvRFg5dDVpOHo0NEhaZVV6MUVXZEJVRFU4a3REazFPSUhVUW5EOHFTY3FsRlVnSUtSQ1l5eWNyVllNNGEwWlNFdVMzbnJyUWJUbWYzbmhhRXpMemVuUlozTGQ1QnJSRmdBUlZKWTFYRk1OZ280QnFYQUtncjNudjZwV1JHUTVLOVdUQWY4STBkN2RTRndyb1VjZ1lrc2p4cHNtS21xSThtanNBS0hHRHhwY1lDekhUSXFBanVmYW9LVWpYeVNFMWRVOVNLbzFYclRWUmhkSXk2Z3prRmdnNTVUR1dxNFJ1QStrbldhQWtiampBeVoxZi9TU1pVWnFBWGp1ZmFvTkhrT0dBR25FRmhYbXN6azRSQVRoZ1VlZ0tseTM3enJHaHl1SVZ4dGFCb1FJSjJvWmFnU0pKUlJHZ3lmWkdHMmZScmxwZzhINFdsVGJNNGUxaENCanNVZ3B0ZmhVUjdlMnRwalA1d1NCTnhMRU1wN1ZrcGdFSktmV3NQTFFaSlNEQnc4UkxrUkFoT1B1UkhoalZOMmRCSUZFUUZpTlZyUktIdEdDMFlKQzFLc2pKbDI3bll1TTg4Q3hpT0N4eC80WER5Y2N3Z1BjUnhCWFJNU3l0S2VzZEtsMlQyblZRa1N4S09KaG1BY2VqbHRnWVpnN2VEdjNtalYzSjl5aE9ldm1SRmp0TGQ2TWJaQ0lDRHhhMDRubWpEdUJNelFrOXlDSzQyNEVSdkhsZDdFRHdrSFcxdW1DZ3NSWUhhdUI0cWdZTG9KaGlDb3VpcnVqNHJnTDVvNDBKOHg5TEt2ZW5Cc2NkQjJ5VUExM0tyNGpncEFZL1RsNThnUjc5cXhTM01obVdERis2NmJmWkNpa0E1M2FrOUFJeDgzdzhFb2VLb0hjQ21hR1dZMkV0K3ZNQzI2T1I2bEdoK0ZoWXhZcStaeUEwU21QbWhFbjJ2UHFpeXBKS3lhcm84SGV2YS9DSS9qT2QwNVF6T2lMQ3l6N1FJdzVxTkpEU3pHS0ZidzQ1bGF4RHR4MisrMjRPYVU1WVZiRjA3QldTb09PT1ZIcTkrWldyelBIU3FuR1dvV09HYmdiRmcyUzdrUjduNGUzYkxUWm5XTlBINk9VbmxMNjc3cFRHMUNZelJwV0p3KzJGdkZpdlVpU01HdXQzeXFNTEF4MXdVMHhFVVNOTElvWHg5V3dVTVNsY2lVTUQwSERpYUlnaG90aTZxZ3Fab1pxaFdXSTRHNnNyS3h3L0psdjEyQ1Zmb1RMWUhtRllqM0pWbXhNeklCYnQ0R2tJTDFCS0VtTUlpQ2xFdDJvOVZ3Y3JOUk9hd0ZTcFBLRHdKSWhybmd4UWhVTFFWeEpEVzV1aHFvUUZwaVVXa3JOY1hGKzZMeFZuajF4Z2orKzg4NlJOeEduNXdCeUtYMHRaOFNJdy9DS2FTdWw5ZzZEWHFBVE1GSEVtcHhRcDZnajBualNnNUZRclZHMXdsS0M5SWFndUJvMUprMUdsS0Jvb2ZOTWNVZXNLb0d1NjhoZEZzWVN6WWlVVVRrRHVUUUlEVjlXWWpVY1c0OUlsYlBtaXZSVkFZWUlTcUcwN3FJaGJZdWxpRnVGbGxxVDg0b1VSOVV4SzBpVDZ1WmVJU2tLUlJDTWpPRHRKNTFhY1pRZFdyL3hjN3FrVmdwV2pGS01VZ3JGQ2xhYzRzYkJnNGZhdXRHWFFuR2o5NEwzUFgwanRwbTNlN2F4MGpmeTFzSmdidlRENTk0cStjMG8xdU45WHd0SEtaZ1YzT3I3Kzc1ZVczZGRmV3NWTWFrL3kzSWNFZVRlckltNTFqTTljQ3BHelIwckprQ0lnRGM0RkVDMHRIMXQzWjFXVFc5Tkd2Y3RNeUNobUVBeHhvMVNsUklGTVNHRzVvUFFCUlJaWXR3SFdFLzZYcTNBcmZ4V0VwZGhnejgybUlISTRVRmYrdnFTdm00OHV5YndxcHhkYnVaRnJIN3MyZkVib09zMmxOa290ME1HbFN0RWxLcE9Ka2FuY09nZ0l1UlRkMzJ5a2JlTnRzMGNiSTJBWEVvWk5jaklnMVpTdzRLK0w2TkNaU0xxc2pnOUt3UTlnYUROY00xVjBFM2xkR0VvRkZVcjlSMUVYN1ZVRlpJREFodzA0MEJuclNrT05qR1EyU2Q5T0taOUFKQ29BZ3B2MWNqcCs1NElSNlFqUEJBQ0Y2Ky9DY1UyUk4xUDlPRVF3WFlFWFFqUkxXdWV1MWZIM1VFNnNyWFhTNVVUT1hMdEdSNVlkckk3bmxJTDVJQ2RZUjY2ZHR0MmxsTDFobHNsc3cxenFWMzEwS0dEV0c5U0dqbjdmcHV5VmRndTI1VjBqWGg5S2ZTbHAvUjE5cjZuOUQyOTllMit2aGFKN1o2eVhRbGE1K1g5WmJ2ZzI0Vys3eXQwVytVWkhCbGdOR29xR29TUVphRWQrc0d5cERyYmRvcm9aelZpN2Y4SG91M1lxdXl0MGEzM1Zoa3RFWVFJMGZmTDV3MDZxVWtHeSswZDJiRkltRG9sbE9SSmp2N1QwWjJHeDFEbW00M0RiNk5tcFFsVEFYeVV1bE1IK3UyKzdnOGFjdkNlN0U1SU1MTlUxeVNUSXBCWkVOSUJnZzFTMld0QmNIY3NkNFNEdWRPRmdUdHFTdWVKMExwOTlKVEgzZGdnd1hjNDR6RTJ0bHlLalR1c0haN2k0ODJuVHZYTVp1RGhHTWJNbllpdTRuQm1PT0FDczBhMldUalJWV3dQaG5nNEtXWjBUWm5teUxpQjV5QjNHWGVuUzQ1YlJwSTF4ZXFUN0ZXTzFZd3YrWlhOeXFRVEQ5VmdlWk1IM0hISEhkeHd3d0d4aUFnUG90U2RXczVPUkc3M09kSE42THpDMGEwU2N0aXF1bWVTVlFNN0R5STVuZ01QeGR6SUtXRXBrWktSVW1vMWYxSVJtOHdaN0dPWmdkWUhKaHAxM0JONGpBWnNuOW9pdXlOUm80VlVpVHc0YXVha01OeG1OVk9wSTdkN3JRU3hZcmgzb3dTM25PbkNLSjd4WkJSTncyK3Q4c2dqRDQ5YldSL2cxd2c5d0dnNC9oOEZmbnlBcG1tb0lRQUFBQUJKUlU1RXJrSmdnZz09","base64")
    },
    
    tex: {
        brick: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FZQUFBRERQbUhMQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUhEeElZbjhzaDZBQUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBZ0FFbEVRVlI0Mm95NzZhOW4yMzNtOVZuRG5uL0QrWjM1MURrMTNMcFZkN2J2amUwNFR0enBKSTJkeEoxQUIwUmFhUVNLaElSQVNQd0hJUG9sRWtKSThBcEIwK0lGUW9KQUI5SW9DYkdoMisya0U4Zlg4Ylh2WExkdVRhZk8vSnYzdkNaZW5PcnVCS2tsbHJTMXRkZGFlMWhyYTYvOWZKL24rWXIvL0J2M2dxdFgyT0RZeUhMT1Z3WWhQYmNPRHRuT1l4NU41OWpXTWg1b05pS0RGdkRCWEhKVmRVUXE1K3BudjBxeU9lSDlQLzBKZTUrOXp6dmppSEdxUUdsdVREYUlzd0hycHNKNWoxZVNSMmNuN091Q2lRNzBBVzYvZEp2alJoSnN4V21iMEFmSDhjVTVmK09OKzN6NjVBbE4xN0VoZW43dWxRTis4dXdFZ1NOU2t0SG1JVklZTmlZVHptWVZ0cmRzSmhHZjFvRm5sd3UycENWVmlyMWJoMXhlVEZsWWlYV1dzUlprdi9udjhlMC8raTVmbjcxSEVucEVsdlBxM2piSWxNYjI5TTRSQjh2bUlPTjRYdEVhai9LR0xCa2c2aW1qelRGYVNWUTZRQ2pGbzJjWFRKdUcxZ2JxZWNsWDd4K3dzWHVENzM3eUdldTJaMytZOFpYREFhTHI2V3lnelliODJlZm5xTDdrL3EwYjVKSGlZamtqbGpsOXVTYU5CM2dQcis5SG5LZ2IvTWMvT3VIQjB4TVNiL2pGcE9GdnY3YlBtd2RiQ0NuNVpGNno3QnhidzVpNjdURUJvaUNadFIxWDUxZThOaDZ3a1VUa1k4Vm50ZVNQUHpuaGpYUkZqK1QxbCsraWgwM0hxSmdnbEdTNHQ4WDgwU1d1cVNCMEdBdmVTRUpTc0doNmxFdklsV1NVOW5SZGhGR0MrNGYzR2U3ZjRQM3Z2VThVUEsyUkNDRVk1VEc5TmFnQVBsZ01sbFJtdkxSendIcTlRa1lTQXNoNHhMT0hEeGhuS2JzN093enlGT0tDeWY0dDRzc1pEb2xvRzVaMVR4YkZqUE1NcFJUTDVZSjEwOUpVUFVtQVRNSkFhKzRNQktaTE9acGtLQzFwbXBJMDBtekhLY0o1WXRYeE83LzNEem5ZMjJYUEZXUlc4LzJQSG5Gbk1DQk9OVjF2TWM2VDVSRTZLVmpIZ2NaM2RLZG52UFhGZmFMRWMxR1dXQjhJOVFWdmYvR0xiRzRNdVpxdmtkNXgvNldiYkc1dlVLMm5hQ0dJbGFhYVh0SHREMmxhUjJjc1BTVmIvWkt0UWM3Sm82ZlUxck9aRnhTVG1LMmRNYU00cDdXV3RCQkVmKzFYZWFuN0V3YjdOeEJOaGZud1hjNjd3SDBQa1lTdTgwUlNZSHFQOGhhTm9Pc2JwQlhzREhPS1FxR2pnTkdDY1FiN1k0VXpNUXBCcERUYXU0WVFETnBKNXJOQW9neEpwdWhNeHpvWUJvbGkxdFU0SXJMSWttbEJWSHI2S0dJOG1KRGtHNVN0NTJvMjV5V2xzYWFqOVpLTlFVeFFtcWFycUwzRGVZRjBMY01zWVJVVm5LOHZLYTFuWS82Y01oNXg4dWdwWDdqN05rZXYzT1ZoL2VlY3JoWU1kby9JcktWWkRubFdWc1FvVmsxTEdra3Vlcys2YWxuVkhiZDNoaFJ4VE4xVWhDaEJDM2h3c2NTSGdMR0c1YnBsdnhoUVJKcnhKT09OKzYvdzd2ZC94RmRrdytaQThmWWJMNk1qUldWNityN0ZlcytpQW05cTZ0S0Q5eVRTWWM2ZXNtd2FsbWxCOElIbTRvckZzODlwUmNyT1JrSmpIS0dlc2VvMGpiZHNUbkpHM2hPVmptWGQweHNIUWZEbytSVzVGK3hzYjNCZTExZ1R1TGk0SWhFU0VSeTFLSEVlZ2h4eVVuWW9vVmpPcDVpNlpyVnVPYThjVDV1U1FhTEpCNHFMbGVIWmJFVWNDYVNFUEUvSkJPalFZTEIwdlVESkRJbmgzdDR1T1EybWQ0UytRYi83ZEU0eHlwRkswUGNWVGl0aUpVbG1raWlTSE43Y3d2WWRiYlBtZ1kzSnRDVFRLVmtVc0xiaCtLTVBNVW5HeWNrcHg3NkNRdU5DNEduZE1Sa1A2RHkweGdBUUVaQjRabVdEYVdzc2t0T2dtSFV4Rjh1U1I5LzVObi8wdllqV0JZb2tRbS9zRThjeDAybEx2NzVFMnA3Ym93RkZMTEdtWWxhM3pHWTE3NjhzU2lxa2xGUjlqNWVTdW01eEFWVG91VHJyMmRrQW9SUTdSN2RvTjFkY0xoYzg4SE1lWGptcW9PbmRCVjdFUkNvbUVCQXFFTG1lUGlpVWxHQUNUL28xSW5Tc1RZVVVJR3hNV1FvVzAzT2F2c1Y3c0wxRG42NndIcnEySVNBcFJrUGs4VlBTT0NaUmltWFQwVFVkSzNISzA2c2E3eDBEQ2ZWOFRiOVlFMmN4bmZQSXE0YUQvUi96cGJkZTVUdi81RStvMTJ2R2RjMm5zemxQeXdZRTlMNW5uR2tTcVpDMXd3YTRlamFsYnp2dTdFNWdiakErMFBzbDJqcU1CeFhBNFVtekdQMzdKNDc0WkkwRWVpQUhqSVJoQkZMQ3h1a1p4V1NiOVhLRmRoYXBGTnY3dDFDK1JJZ0JrNThhNEZFWUdmT1BUaXIrY3Bub0pTc0w3c1Z4K3VJZUhvZ0E4UGl6MDMvZXp0bWF2MW9lOFA4dEJWTWtVQUNMRjlkTHpxY0VvT1ZmWHVRbFNCdzcxUW5mL0ptVTUrY2wvL1h4QmVMRnRRelFBZW92bmZQUG5sTzhlSGJ4b2wveW9tME43SDEwU2VtdTZ3R2tnS0dFU01GbER3RVlNc01BV2x6M3FjTjEvZEV4T0FVNFdEY1FXTk1CR3BCQW5NTGU4aC96bi81WHY0bnBEVlF0U3dlLzkzak8vNTh5dVRxbE10Zno3LzRsZlhUenluMldiWU1JZ2pUSk1FcHlmbjVCbHNZb0lVaHlnUTRaQ3g4b2lnS0NKMjJCT3VXWHYvRUxiQjdkcExHR3pkMDlwZ1JNMHdHUUp6RlJsaEZtYzRvaVJ3cUI2dzIwRFVKWW5FNGdnTzlhZEpwaHF4S3NCNlZRNHpGdU5nZmhYOHhxZEQxamlhWVRpaUFFdlpCa1JVbzdYOUwwN2ZYYnNRYThoQ3lGN3NVcjhRYVVKaG1OaUxYbTRLVTdQSDE4UXJsWWd5b0lNbUNIbWlqTzZjNm5PQ1ZBQ25TUkU4cUczZ2VRRWovSVFXaE11YUNTQ2lFRnUvdDdJRFd5dDNSVmhmY1dxZ3Ezc1VHYXhNVFdFd0FyQlZvcE90ZmhRNkNaTFNCS2VCSnBKbHRqaEJETXJwWmtVWVRyZXhwdlVWS3lOUnlRamNhTXBXSnZNbVlxQkUycVVBUmMxVUlJMFBlTURyWnd3V09NQUNIUVFwSW1ralJOQ1UxRDhKNDRUbGczTlRMUzFMTVNuQVBoRWIvMVc3OFJVdWt3MXBLT01sNzUwcy94RjU5OGhqSWRna0JHeFRpZjhPeXpSemp0RVZKeDc5NTk5bS9mUmtaRC91UTdmNFNLQllPREd4alRFVXhNQ0o2Kzdsbk9ycGd2bDl6WUhKRWtLV1ZydVRoL3l0N2VEcjFWMXdQd2d2SFdCdWRuVTA0dXp1aU5ZL2ZXSFdhelM4VHlldG4vNXN0SExLdWFFWWJPV0t3UHhKRWdWWUtUZWMwZ1Z2Z1FpTFdrcWp2aUpDRUlnWktDcWphTU1zMTRQR0dReHFpaVlOSDJQRnExTEpZVmhNQWJSL3MwSWZENXlYT29ERTRJZHU3ZXdLdU11dW9KM3JPNW5WUDFnY3ZMQlhjUHQwamppRUdSa3hRVFBueDR3ZWZMQ21ON05nZUtYLzdhWCtQcTZna2JSWXdRZ21XNTR2REdOcDgvT3FYdmVwNCtma2ExV2pDU210M2REZUpJNDVCRVBXU1J4UFkxSVRqaXRPQXdsWHo1OVZmNUJ4OThRcm51eVd4RFpSM25WeXVzODd5Nk8ySi9NaUpKTmJNUTBWckx3OU5Udm5uM0Jrb3BiSkJBd01ZUjA2YWoyRC9rY2VWWVZTMG55eHJ4bjMzajVUQmZWRlE5akFjRHRpWVRIaTNtTkZWTElPQ2Q1ZVpRc3p2ZUlNOHpPdXNvaGVTOTV5VVg2NHJDZTZRSWpOSVlGUUsxN1JFQ0lsVlFxTUF3VjJ3VkdaR1VDQkhocFdVMFNLazZTKzhEclJIc0RRZDg5T1NNOXhZdHRaTWsremU1L2VYWDJYbjNENWd0SzM3cm5TUE9xeUczam5hNTZLN29uR0dZeGd4anhmZmZmMEQ5N0JUbkF6dVRNVlhmOHRQM2JsT25PYzQ2anA4ODVzNzkxeGp2YlNJUWxPdU95QmxXY2NMMCtJeTY2ZG5WSGNYdUFSZmxra0dVZ0JRYzdvNEo0eEhMc3NNNnoyQ3l5ZW5walBKcWhZcEJoTUNXOEJocCtONkhaL3kzSHk4eExuQm5kOHgvK1hNSFhKUWRSa2tBQnNxek54d3hLMXRNRU14WEpUMktnZmFZemlKRUlNbHlDbHVUcFJHRHRNQjZTVGVZTUQyYnNiR1JNYThxckhIczVnTHJRVHFGOFlFaXNsUlZ6OEU0NDRPcmx0NEZCcEhrM2xaRUpTWGpQRWRLV0hlT3owK3ZjRFl3VnprbVNsaC84ZXZvc2cwc3lwN1dPZ2F5cDNFVnF1blk4TmQvUStFZDRXVEJZRFRBTlJVaUJPTGVjOVN0R1BZZHk4VWNGMkR6MWdUcEJFUG44U0dnWE05c1hWTHNiQktjeFlyQWVKQXhTUVFoUktnRXZJZkpWc3JINXpPV2JZbnFESzd6L09BSDcvTE9MLzBNV2lxc2MvVGVjdjhvSjhrYUhsOGFGblZEWFQ1bThvWFhVTDFodExPTkZJSklDVzZPYzRvaWc2ekFTOEZMeVNzTUVrbDdkZzRJb3VFSTJWUU1jSFNaSWtzeThza2VvbThwMnByeDVoaVV4RHVIWHE3WjNkeEFKeEZkTWlRdUd6Q094ZkVwcmpQSUhNYmpBdU1WNzN6aEhWeWtPVG9ZTWIxOGo2WFRQSDF5VE9rRTMvcnlTd2pmY3pES2lhV2tHaWVzaVRIckJXZWlwK3d0SC8vNEoveXJYMzJEV3FYTVZ5VzFEZHpienBCRllGVlh5SHFCOHBhbWRvUVFrUmVLZ1JKTVM0czBIcnprL2tpd3RnSG5ldVRHRnI2cEtTL09jQWlLV3pjeGx4R3RpTWpTSWEyQms3TTV1dmNTcVNOa0VGek5sa1NURFVUWkllTVl2R2UyWEhLMHY4SHNjbllOc3BSa2EzT2JZU0VoR2xQa0dmakFLUFQ0Tk1MM0RVaEpsaGUwdHFkYkwxbFhhd1FCM2FWczNEbkUySTRzeTlFSWlraVFlTWQ1citodFMxQ0NiLzdhci9IaytKelVTT1lob1pFRlU1R1NOUzFYamFIM3NEUGFaS0E5UjV1YjJGZ0RnUWNQbnJEU0VxMEYwY1NUYUVXcW9iV1dyTzlZOVo3TlRMT01JWldHbzV2N0NDR1luMTFTVzBjODJzWmZMVUFKcXZFbUt0ZHNxQUdqSW1jbEk0cnhoTm1xd3hWRGZHeXBtaEpWR243eHJaZFIyVDJpalUwZWZQUWhpeTdRK1paMTNiRnlpcXIxNU5wUmpBUnhIUEZ3YWJIZG10YzJoNXlzTGhET2N2LytQYnBWeVkvS0ZmMzVLVXNEUjVrampSS2VyaHVrc0pqZzJSNE5VSzBoVGhPMERGeGVWdGk2Wlc4anArazdlbXN4TW1YZEdBWkpSanIyZEM2UUlkZ2FUbmd3aHlqWm9CT1cyL3Q3cUcrOWR2UHY5cUZIYWNHdHZRbTE4WFRla01xSUJFblhXdnA1alZVQm5LYXpGaWs5MjFuTTVtU1R0WGRZTGFpZEpWS0NVUktUUlJGMVk0bXpESTlpTWhpUzVUbkZlQUl5NHJJcWliT2NOSW1JdFdMZGVnWWIyM3o5SUdWN2xQTnIvOEcvejNmKytQdk1uMzNHdEt6NHl0RUdPN0VnOUJXdEU4Z1FLSmR6UmpzRFpsZHoycllEYXhsdmplaGF6K25hRUhwSDF6U0Vkc3BrTkthN1BHTlpOV1I3dTlpK3h5NUtyQlJFeXRPblExUmJZVWNEc3EweERIS3lQS2FiTDdCeGdsU0JGa1Z2UFZYVjRyb0dJU0FZejdMdGNONno4OVZmWlAvV1RSNS84aG1qNVhPR2UzdThjbnVQdmIxTjNyaXhqWE1CNHoxVjEvT2RUNTV6OHZBUlAzTnZpNUVPakJKSmttWDBTY0s4YWdtbkM2YTlaL2ZtQWNYQlBsT1ZvcS9PYWF1ZS9jMGhUaXVzRUxpZ21QV0JwdXFJK29hbVhORFdOUmRYS3o1L2NNeFFDY0pnZ3RVWm5ldVkrNGdmSnZlSTl3OVp5Wmd2Zk8xclNJbEFBa0pBckdNa1FBalhld0VJU1NRZ2xxQ2xRQ0RwbmNXR2dCUUJLYTRacVVDZzdnMjlEZWdYUVZRa0JBb1FVaUdFSWxMWDZEbUVjQjBDZW8reG50NEhMSTV4RXJFL3pOZ1lEK25iRnVjYzFubU04Mmc4QW9kOEVTSWxXcUdsUUlwQUZLRHZMVXBCckFTWlZzUXFFS3lqN1IzT0dwU0FXQVlTTFVFSVF2QUU3ekRHSWdSb0xVQ0JFd0luSlNoSnJDT1NSQ0dsNEhxRTRFUEFXWWMxQmdFb0lhZzdROTkzT0dkeHp0TDZRTjg1bkxmNDRPbWRJd0JhU0NRQ1l4MnpxdWZCVlVta0lOVVFDNEZCZ1BNWUxTa1N6U2pQRUVJUy9JdG9JbmljRHdnQ2dtdkVyd0lra1NTV0Vpa2tpWmFrRXJ3UHVBQlNSK2c0SnZpQUpXQnNqL2Nldkx1T0dMU3QyY05paGNNMlBWM2JVVVFweGhxc0VOUXlzSFZqbTBtV1VEWWQyZ0c5d3l0TGE1Y01rNEIxbnVXcVozcXlZdnZPRGw1QkhrbVNQQ0ZWZ1VRR2hQY0kweE9HT1NGS1dWVWxkUVhESktlczFrUzZaVFRab0ZHUzU4ZlBxWnFHeUR1Q0R3eXlHSjBvR3BWUkpEMHEwbXh0SDJGTW9FOHlpdFdTeEhzMlJqRnFuR0djb2xyT3NkWkNvZ21yRmNXdEl4SXA4ZExTV3NOQ2E0YXRZZFgwM05nd2hPRUFhVnBFQ0JnSHJTN0lYemxFNXdLckZLNEhhWHVzYVhDckpWaEhQaGl3c3BJOGpsZzBLOG9yUjltMzlGMUZ1dXg0OHRFbFRpcWVpOWM0M04wZ1R5WEdlYXEyNGVUSzQ5c0dtZVRFUXRENW5yN3F5Sm9sYi8vTm55UFNDVGMzSTZhWEsvUjZTUU1vcllnRUtLR3dlWVlVZ2xGZU1ZcHk4a0dHelk1d3puUDYrU1Y3V3hrMzc3NE1vK3NRY1g0VjZOdUtOL3FIM0E2Q0U5Rmg2em02TFJ0UytZSlA5djMxM2poa0hDR0VZQ2ZwV1Z4ZU1YbnBDSlhuQ08rcDZoVmdtRXpHUkU2aVpNVGhqVDNNWkllcjgwdEM4RXhHQlZuZm9KVWlUaFVTTUVyeS9QbHpYRkRZdGlXT05LTmJDVnRGU3VVOXk2cW5FNXBSbmhMSEVkdURqRmtJSkZGQW1KbzRLR0xYWEgrQkNkU3pDbDJYRExkem5CZU1zb1EwdGx6WWhONDd2SFdrd3VLU0hEa1lNaTRTNmc2eWtlUFphc0hsd3djWUY5aiswbjJpZ1NaT0Jxem5jNHoxaE00d0hPZDRyMmdFbUtDSVlvM01ZckppaE8wTkxsd1RMTHVqbExOR3NGeXRzY1p3WXp6azZlVVZiNzV4ajFHYTRMMWpzVjR6MEVNbXFlVGVTd2NjYlF6eFZqSmJHYVFVbURqRkxzN1kzUnFnTDg0SVFySjJCY2N6UjVFbjNOMjRTYW9FMWd1NlprM1Z0VWdDdGxxUkp6bGJXenVZS01ZR3o4NUdRMTBaOHVHSWhYSVliMEZadGhKTDZtRlNIck9xUE4xeWlVNkhFVTVjeDlHNmR3Z2hjS0dqblBjb0NkdEZ4dFpraDdQak03SkJSaFJKdXJaak1ldHd4cEVKRFVweGMydkU2R0NEOTdLTTJoaHN1NktQRTB6VFVMV09SRUhYVzVTS01FM1A1R2dmTFFVUFRxOFliZTFobktXczRkTDBYSDN5T1oyMVpLSW5DWTV5WGJIeUdTNVNkRnBpQlJ4ZlhDRjhZR1F0cm5GNEtTbTlSS1VwUmRmalEwbnNMVUluekdZTHZITjBTWVRMYzF5YzB4blAwZDROYXVNeElxSmZsb2pJVW8zR3RGMlBQbi9PWUZJZ0I1dlhTMmNVMEVvenppS2F2UUpyQTFYWDBWMDhKOXJOZVhwK3dXWFY4K0NUaDl6ODFtdTh0dk9jdUNnNDNDajR5ZkVGZmQzaUVoQWg0aHV2YlBQRFI1NzUxUnd6M0VBS3dmTGlqRHRIZTV6V05jOC9QNllYa3R1SGI3Q3VsMXhkenRoOCtZaXRQT1ZwSFdpdFlENWJJb0dtOTlUTmdpeFltaWpDQ1hoMlV2RlQ5Kyt3TXBhVGkwczBBUkZBUzBYdk9xcjVpcTZIMmVVVS9hanNLY3VhQUVnWENOYVNDY1Y0UEVJUWNGak9Tb3ZMQ3FJZ1NaeWtFcG8ydGp5Zk5UaXU0OUpvWHJPN1hYTFJhL29BdnUrSXRHVjVOV1Z2WjV0WUN0YlZIQnNFYVRIZzRueUpFcEoxMHhPVlQraXQ0K1dOTVVzWjg4dGZlSXYvNFhmK0lUOTZQTWQ1eno5NWRJa0pBaGxySEFvbG9GMnU4T3VTclR4bEkwMElCS0tURmN2ZUk3UmtNTXpST2lHbW9LNHF1cTZqdHcyVG9rTXh3M3ZQWmIzQWVjLy8vVkdMaWhRN281cFZkNEcxSHQ5N1RoNWYwUG96YklCMUZ4amxDWk5Nc1ZyWDlOWkNINmpiSGhjNVJwc1NQOHJabkl4NDlQNEhuTTlXSE56YzV1RnNRV0k4dTZPWVB0T2Mrb0JmTEFsOWpjb2lWcG1raUJXRmlRakJNVDFmOHVwQTB3Yk50RXRvNVlBNzI1THgxaEFiS2FZWFU2cnpLeTdiYTJ3eG55M1ptUXd4aVdEUkNwUlMzTHozTWxNVitMTS8vZ0hMcGtXSWdOUUplUnFScGptM1UwZnRGSThlUEVEc2E0SnpYRk90TDdodUM5elVvTlYxeGNZQWpsZHdaMXVTeGRmUzQrTnBZQkgrS3NkOFdNQnhkWDErLzRKSGoxKzBCYUIrQWVEKzJSYUFFdGdFRG5JUVFXQ2ltRi85Ty84V2YvTGtsRC8vZ3ovNEYxeitpeTM2Uy9mTFh2RHkyUXNPZm5jTVdzS1RHV3pIRUFURURvb3hQSmhlaisxT0FYZTJFeDVmZEx4MGxBQ0J6NS8wZEE1ZVBZREdnZkZndlNCTkF3R05GSUhhT0pZMTNMKzFSVlhWeU9CcDY0NnRTY2E4dHR6K04vOWQwczFOL3JmZi9iOTQ5ZVRIN0NTT3hseUR6YjRKZlBYVmJUcDNEY3lLS0hEVjlOVHprdkhHaUVnS2Z2ejVrcnN2VFNoWEM0NjJkeWpTaUNySitPRjduL0dWVnc4cGNEZ0N6M3RveXpWQkQ3Rlc4UCs4ZjhidG9XVHBQZWZWQzhZOGhzbjJtTWNueTJzUS9rSW42WUROUEdOdmI1L2hhTUFYZi9sWDBCZVRQYnhwd1FkVUhPT01nMGh6dFRGQ1NVVlQxendDNnJqak1sRWdCWjNzWVVmaTNEV1NGOEV6R0F4WWppZXNMeTZ3enNHNklvd0hqUGIzcU9vV2F6M2RiSUdNRk1OQnd1WmtENVNpZlBpUU9sS2NGd1Y3KzdzVVNjVERxbWE4TVFGWmdLOWV4QlFKdm9qeGFVb1FndEJiR3U5UVNVeVdKQ0FFejcybnFVcnlsN1o1OHZRRWxPTG8vaEY1a2ZKMC9RQ2NZeEhuVERkdmtOL0orUGF6QzV6ejlCdWVLTkxNOG9SVlhXRng1SWxBWkFWYUJMeHpxRkZDbGJSOFBPMkkwZ1BBb3hKTDdHSnUzVC9pN1owamhwdWI2Q2pqSDlsTkJwRkdKOWUvVm1MUHgxVU9VWUVQam5xK0pOSVpOVFZET3lUU212UGhrcitvRTZvdTQxNXhCeDFGL09URFQ1RmhpeE8vUTF1M1dHZXBPbytYQmZnQ2dQTHVrSXVxcFRNOUtybFdtMVNXOExTcVlEeEJwU2s0VDU3RVNHTkpKaHZjZU9zMU5uZTJxRTJQL3R0LzY5ZngzaUh3Zk9HTjEvajArSVNMMHd0TTZGQlNzVFUrWUpRcHppL21xTmdScVlnaUczQjJjVTdRaWxWdjZlcWFleS9kaDlVYVJJMFBucE9MR1dWNXdTOTk4OWZCUW04dFY2c1ZuMzc2R1gvajYxOWo3L0FtbnNBSDcvNklXQVYwZ0ZmZWVwWE4zVzA2TCttTnhsbFlMbWFvRU5DUjVQWFg3N0YzNDVDa0tEaDdmc2J4NDZlQVkyZHpURjRVTkhYUGUrKy94ODE3ZC9uOHd5YzBxeFZLV1A2ZHYvTmJmUGZlZTlSMVF6bTlZdmZ1UFg3OGsvZVk3TzJoRUh6MW5TK1RDckRlSVBMQnRheThXckM1dThPeng4K3hwdWUxMTc5QTN4dU9qNStnQ1VqaG1Zd3o3ci95Smx0Nyszenk4QUdyMll4M1hydkg2L2Z2MGpjZFdTenhQckIvZUlPTDh5bXRrQ2locUJlWDVFbkdyVnUzeWZPWUpFMTQ5UGlNdmlzcEJnbkw1UnJ2UGErK25pSDZucC83K3M5UTlZWnl2VVIySFJiRndlRStTWklTSzhXalR6NWhkMjhIcEVCcGhWY0pzNnNUbXE1bGZqR0hBUC9hYi93S24zejZHYk9UVTk1NSt4VnVIQjd5WkZZaS9xTzM3NFpSMmw0dkZaRm1RY0xXZUVnUnpMWEFRb1NJRFdzZlVXUUZFa2x0V3JhS1RiNjdzanp3a3VBQ1AvLzFyNkYvLzMvbDdWM0JiaEh4SjUvUEtFM0wvYzBoNDJGS29pVWZYYXg1UG12WnlSTFFra0pKQm5sS2xDWk0xelZPUm9RQW5Zd3hRakNielRFaGtPY2p0cEtNMjFzREhzM205TTV6VVZzU0JEY0dFZnNiQTJJbHVWaXU2RTNMUnA3eW84L1A2WnpoU3dkamZ2N2xRLzduRDU1UWQ1YldDOXFmL1Z1ODkrT1BlSXVIMEJ1K3ViZEwzUnAwcExGS1lwemo0ZWtWdzJGR21tWFh0cTRzUVFBL2ZITEo2d2U3cEpGQ3haSmwxVUNjTXkxTE1xa1lEb2VVNVp4VjA3QlZqQkJJYmgwZVVQWWRlMGN2TWNoVG5weWNzRG8vNFhZbUdPUUpxZGI4NEdRQnl6bDcyd1hQVjRiV09MN3orVGxyQjkvNDdYK2JmL3dQL25kc1dmTGJiKzV6ZHpObmtCZWtrVVRFbXFlWERhUE5pR1VYNkt5bkxrdXFMdEM3d00yQnB1a3R3aHVjR3VGMFFPSElZOFZWSGFPVDJXUHV2SFRJS05LYzFnMWowU1BQTGtueWhDQmdVUWIyajBhNHZnZC9yYmluYmN0MHZXTFRLb2JGYld5aytOUHYvaGx2TFdiVVJZWk9VbDdkRk16cWlQVnF5amplSmlWaEVzSDJUa1lrQTliMjlOYVRtSmJjUUJRbFZHMlA4NEVvRzJDRHA5V0NFQlNEWURrYXBIUkdzNWNsZU85cHBrdnlTTENoRXFaWDF4ckZNQmE4UE5SSTJiRnpkOExLT2pJVm1DMnUyTmVCMm9PS1kvNTRlczdqcDUreDI4OVFXQnB0bU0wclhybTFRK3NpaklNZDVSaDBOYytmUGFjbnNQZnFJU0pPZVRWeFpOUEhaQkdNaWdIYlFCQ2UxeWFTMW52V1ljVnllY2xobHJFWEJXend4UFVwRzE3UlB2NFFwd1MrTEVtc3dVVXBxVktNRXNFYnV3VmxGaml2T3JvUTBRYkp2SEtrV1lMT0NycFZSMS8zSkI3V1BxS3VLL0pJY1RNYnNqR0lNSTNCOWlreWVOS3VwcXl2ZVF1UkRiazlUTGhjV2ZiR0NlZkxGWEdha0dxRkVoM3FWMjRWZjFkTERRSE9WaVYxMVRDS1lwSkVFY3VJeWRZMnE2WWhvSmczaGxYbmNEN1F0VEJLQ3ZvN3I1Rk90dmpvSngrdzE2NDVIRWdHT2pESWgxaWQwcnVJWVp6Z2djY25VMHkxWkhOY2NGVTFWSTFCZTBFeUhHRjd6NVgxVk00em42OHBpZ25EN1gyeVBPZmR2L2dKcjl5L0M2Wmx1VmhnMm9idFBPSGV5M2NaSlRIZGFvcXpIU0lTakJKSWRVUnZleElaa0RKaE1reVpWd0dMaENoQ3Zmd1ZqbWN6a21aRjdlRHR3eUYzOThac2JBeTRhQTJWQzZSYUlpS05TalFxaWJDckpYRVUwNnhXM040Y3NWMFVaTU1jcnhSRzVOQk1FYUZEalkrbys1Njl6UTJDNzNDK0o1R0tUSUNTZ1JpUER4WXBZdHJlNDV5aGFYczJpeGdySWtvWDJJNFVrMFR6c0hJOG15M1p2M2NQWDFWSUxmalduUW1sRStqb21xSGN5RElhMDFNWndhVnhHQUtqQkI1ZkxGbXRhbDdhR2JLVHg2dzdpMjBiMm1aRjhHQ05aYjFhb3VOaWc1QkdkRXFnOHhobkZIRmVrT1k1U2dsT1RVY2lCVW1hc0xJV1p5eXoxUklmRDlqUkhhcXJVQVEyRHJkWlBKL1RCZ2hCb1pVbWx3Rnl5WG5aWUlYQUppbWpKQ1dMTWdaUlF5SkFPRVBYTklBa2M0cFVhRTVDNEdJMlkrQXRSUnp4dFhmdW8rdExoRFVjRFF3QkVLMmhuWit5c29KbFBNSktSMnhiZXBHeFdxNHBVbzMwZ2VscXhjSEdEcHREZ2FnRGRkQlVzeFd6NlpTd25DRUM5RzZEelZITU1tZ3U1aVdOOHh3T0JzVEtVd1pMS2oxRU1jZlRGVHZqRFVRa2NCcDBwSWdJbkpWTGhsTGh2R0FTS2laYTRhdVNWZDlqWEtBdUd3NG5ROUlzSjFhQ0xvMFEwUURaZXdLT0ZwaldMYzRudEwybmNpbENhTkx4RHBQT2N6RmZVUlF4MG1VVUcyUHF4cktiSmFTUnBOWXBUalVrdnViTjdURkZyRG1aR2NiakFsMmtOQVl1SzRNMUFlOHRvN1FnQkEvV0V6dUxWdXNPSHl4b3lWZ25PR1hKdGd1S09NSmFUN3V1cU91YW5mMGM2d3pXQjJ3NklvMWlYSkFjM0gwRjRpSGYvZDZmTVZvc2lQWTNHUThTMW8zRmVrdVU1OHptVTNycmlLeUExR0pjeCs0a0ozaFlyMXZhdGlJeFBkdWpBVkpKbGg0NkQzN2RVd1pEbkZpbXl5V0pUaGtPaDZSYTBvcWF4S3dwa2hHZGtUZ1JtQzBiOWlkakJ2a1FiOHRyTHJ3b1dGY2RtNUdqaWpYTk83L0syNjkvamYvK0QvOFE5SURFVzViV0VIeUtzeDAzeGdXdENRZ3BLSnVlY1o0UmhHUmU5OXpZR2lPMFpDMWJXaUhJNm9yV2E2VHZPSjJ2NllPZ05BSGxCWTBLOU1aaW5jY2F3eE1idUxzdGlOT0lVWjd3OU95Y1RpWk1CZ214RWxnZmMxeDJCSm56VTEvK2FaSkVjL3E5UHlXS0pSKysvNWlmdnJPTjlCSnBBNGVEbk5wck1KN1BIbjdPd2Q0R1lWVVJoZ1VpS0xUT3VUbnFLWTFDSndHdkZNVkFjemxkRUh3TjRSclB4Rm1FdHFGaVFrYUNJc1FEMUdCRWJ3Vi8vdmd4dllOOE9HYXlOV0lZUnh5TUFyMkg2YXJscy9Ncjl2Y21ERXpQWUR0bS8zQUx0MzVHMlhvV2xTUG9tRFNPbUhZOVFnWHdZSU5DZWtkcmUzelRvUkY0NHdraWtJMUdxRndUS2NFUkVUT1J3bXBCYVJ5amVJaUlOL0QxaXE2dDZBWFVmY1ArOWo1eGxqR1NDdkRrMnJPb0xRZmpHQ1d1alpXNzJyQnVIQWM3RzlTeFlQeldGL24yVDk3Rm5UMW05b0picU5veDg3cGkzZ2VNa2tncDhFM0RaQkJSWkVPU1dEUHNQVEpXekMvWEZMSENTOEdpYjhraWpRd0tuWTV4TGxCVmhzZ0hEbTdza1BrbEFjZEtnUllLUVV1S3BlMWpKa2MzdUx5NlJBbVBFcEp4bHFCMVFUcSt3WGMvZXNLMHFubDZWU0lpelYvL3hrL3o5TDMzYUpZem5zOHozcnE1aFIzdG9wVGlNQmphdWlIZjJHUFpLNWFOcFZxdHFEdUx0U1ZhSk9Sb0xJSkNld1lDck8wSnpqRmR6dEVxVm9ySHFCMEFBQ0FBU1VSQlZLZzRRVWN4NmY0bWp4ZExwQWtZbmRCNVI1Z3ZTRzNLWEVocTEyRTlOQ1lRSlpLTDVaclBQdjJBK1BJVVlTWEpZSWp5am5YVHNEdU9tTGMxeWt0QzB5QzlvMGhUVm1XTjdzTzF2MTlDNXkyTFZZVjBuaWdrUkJJeWI5ak5jcjczNUJtMWc1M3NnR1haY0g5L2w5cFlPaCtZTnBZSmtzWXBaREJFQkdaMXpTSTRYdDBZY2JhcWFaMW5WS1JZMzlORmV3UXAyVHJjWTNSeS9sY0lwaWhKU1NZN0pQTWw2b1dQejBTT2k5bUtPMGN4a2ZMYzN4Z3huV3pTTlMycGFVbVZwSXhqbHFzbHc1MDlUcDljMGhoTEloeXBnT1hGSmZlMmh5U1I1c09Wd1ZRTk90OUFaVEd5YkZDTE9YM2RzakNPUkdsSU02SnNCN0c5dyttN1A2U3NhOXhxeWUyWFhxWVlEZmx4MTJKTkIwYWdUVWQ4L2hTRVlwQ09TSWNqd21ERTlQRXh4amhBSTFWUE8xdmpZNDNSa3JhcW9HL29wRWJHS1RxSnliVkdGNXM3akFiWnRjWFlRYTR6a2xqUnY1QmlTK3ZRc1dhckdPSkxnZkVCNzJvMHNMTzl5ZDE3dDRoSFkwNmVQa2NxY0NGUTloYlYxRFRHVXBxRzdjMFU1K0I4V2lHOXUwYnhiWXNXRU1VNSsxdUN0aE80MXVPQnJsL1JHY21ydC9kWTloNGZQSWZiUS9KYzgzemhhWTJuS0RRWHJXRjZkY0xOblUzaStEcmNLVFMweHVMakRHczhqNllOVGpwbXgxY01obU0rL3NGUEdPUVo1Qk9vNTFoQXFJaXo2UW9oVTNxelFvaEE3eHhGcHFsbkN6cXA2TFkxejQ3UGFMcVcwYWdnalRWZEg1RFppR1ZaWW9KQjRvZ1RoUTBSWjNYRG9FOFpLMEdFSTBwanJzb1ZsK3RBTUlGNE5FUnJRVnlNaU9LSXB3dEhQN3ZpUmxjeUdtK1NaZ015QXJwYjg4ZC8razhSSWtMcmhNckE4YnBoSlRSQndDQXJDUFdLYXZHTXB1ckF3WGFoYWRjQlVjUjRWOVBVNGhxZ1Job1hMS3Baa3NhU2kwYWczNzFxYUU1TFhQQW81VW5qbURpQWt4NkI0SFRaWWV1V1lyaUdTQkZKU1NRaUdoZXdhd3V6TllOc3lOUFRTM2Jya25PZDhxeTJSS3M1WFcrd3ZjTUlrQWpPVmcyaGRyeStteExIMTY1ZEZaWTRIU085b2JMWEhvTWdFa3pkVXRWemJBalVlL3RnUU52QVNlbHhMcERLaE1UMkxPWVZUeGNsbVJiZ09pYVI1SWZuSFZYVkVvSm5XbGt1TGhwKzVSZU8rTmw3Vy96OTFaTDFhczdldlh1Y1AzcUE4cFlQbjgvNTgwOGVzemNxR0dReHNaS1lya0ZLR0JZSnJiTTBsMCtwbWg3aExjZDVTYUVFZlJ3enJTMERBYU1pUmthYXE2YWhWNUsyZDV5ZkxZa1Z0RlhMMGZZR0Y0c0c3enh4bERLZmw5Umx6ZFo0aGRLSzAwWWdqZUZpdFlFWEVnbW9TSE5TN0RHYjF6ejgvcDhCZ1I5Rk4vblI1UXhralBFQkxUNUFvR21kSVFzR1F1QmduTEpUWkloRTgzUlY0OTAxejE5SGNQcnNsSmQzdDltMGt1TzJSZi85VHk2dXpmQkNRRzJ2MTBYeHdpQWZYaHk0QU9mdFA5Y0xyaDBIaW9NZCtNMmRBL1p2SEhGNDZ6YTJLdmh2ZnZJSnB1dklzZ2p2Sk9XcWd2YXZ1dEwvc0haNFkwRENjR05NbGhWY3pXZE1OalpCQ0dheks0SnQwRW9qcFdSTFMzeG5XWlRITDdDRXg1VVZEQWJROWlERHRYR2xHSkhyYStOR3BCT2tFRmd2Y1RKaDJlWThTMit6NkF6SHo4NVpOUldrQmM1NS9vK0xHdXNUd3FJaUh3U1EwTFVkMjd1N3JPYzF6bnY2MWwxL3VWSEVqaGdTeHhHKzlTeWFtdkVnb3pydkNBR1NaTXo1ZklFM2p1R29RR3VGdHpIWlJjb2d5bkI0cHV1S0VBU29NZjZzQXl5OVY1aTY1ZFVzWVRqSUVVS2lSam52Zk9WbitjUC84WCtDM1VPd2hyLzMzbk5JL2tYMmdrNXo2QnU4QkY5ZFcvSzM5d28yTnlOc0NCVFpFQ1hnNG5MTytld002UlZGMjZLMFlqU2NvRjk3K3lzTWl3SXBGZWVYNTZnb0pvOGladVdLWUN4RmxoSEZNVzNYWVZ0SDhKYWJOM1lnaWJsNzR5YVo5ZGl6T2Z2REVUSkxtRyt2Nk5xT25mMU5Sc1dRZkRMbXovL3A5N0Y5eisxYk44aUxBZHQ3Ti9qdzQ0L3BtNFpoRkhIbnBYdk1WbXVxdmticWhHTHZKazFUYzJOdkQ2RUU1ZXljN2YxRGpvK2ZRZWR3enJIejlnRTZqdm4wMFNNVUFRVElJRGk0ZVp2cDJSbkN0dWhJY1dOM2s0dUxKYnQzWCtQZ3paL2k1U3psMXNtVUI0K2ZrZDQ4d2h1RGRZNjY3YkY5ajVRZXBTT01jUlN4Smg5SmdnalVaVTA2R0dLYWtwMjlMWlRTekdZclhIZEY2Uk5NbkNLa29EV1dsNDVlSm9vVWQxOStCZGYxdkhyN0FLOGlMdVpMbkxXVXF4Vmx2ZUwxMTE3bDlPeVN2dXVSU2NhVFo4Zk1UNTd4MjcvMXIvTkwzL3pyeUhpSXNSblNXMzcwdzcrZ2JUcktxbVMwdlUxWnJURjl4N2dvT0Q1K1J1dEFiRjJ2QUJ0Ylk3d2VjblYxU1JrRVNraHUzWCtINWFlZklkcUdiSGVUSkUzb0xZaS85eHZ2Qk1PMXdiQnFLNkkwUndUQnRITjAzbkZqR0xPbDROMkhaN2gyUlJzQ1AvL2FuV3Y1T0VucHRVQUpHRXJKZkhyRndpazZDMXNiR3h5a2d1UFNjdnI4bkxPNjUyZmV2TVBkZTBkTXB4WGZlL0NFZFdONGJiL2c5VHNIUEwveXhCc1pRUVQrdTIvL2lCL1BQVi81NnRkNC9hM1grZVVkeTN1WFM4cVBQNmZJRlZKcGZ1RmYrUmF6WUhnNlhiQjBDaFhIUk5hd3NYdkFKeDk4eWx0dnZjVCt3UjZmZm5iTWNqSERHb3MxaHVlZlBlV1hmdjF2OHNtVFl4YXpVM0NPTjk1OGswWGRjdnpKUTc3MFU2K3p0YnZEaHg4ODVPenFqQys4ODJVMmQzZjQ1T09QS0R5Y25SMlRLRTh4eUpsc0hmRGhvOGVjUG42R2p6S2lvbUJ4Y3N6YjB3ZVl6akw5K0dPV0tIN3RXejlQdjJwWSsrWmExb29LVWhXNHM3L0w1NWNscTZhaktCU2ZYbFJJMXpNdUVweUZ5NmJuY0dzREtYTkdneGhqRGI3cG1LdUUzLzNvQ1gxditUZSs4REwzZGtlYzE0YUJxVEhPOCtycjk3allQK0M3UDNqQXkwY2pvaWppamRlL3l2L3llNy9QSUkweGt4RlNLNDZmWGlGKzl6ZS9ISmFyR2IxelhNMHJSdU1SMFhEQ1lqV243SG9pRzNqOTdpMCt1cGdSdFNXMTlSeU9DNWFyQlY5NjgwMnN0ZFNkcGRDV2dFSVVRN1NPcUt1ZTgrV0tzM1hKM1V5eTdCMzNYOTZoRUpLcUdIRXlYYkdzT2dhSjV0YldGazFWMFp2QVJkbnluL3lmN3pMejhPWlgzdUgxVjI3eEg0cFRSSkd6N2d4SkV1T2RwemR3ZW55Q3pqTWFJVEVoVVBVRzN6dk9wek5HV2NKV0ViTzJIbWNsejh1ZVJFbTJ0T2ZlMXBqM24wOFpGZGQ1Z0R0NVRDY1R2UEZFaVNmWG1ua2RpTFNpR09jTXNvakh6MC9ZVENSQnBvenlhMEluRHA3M0w1ZWthYzdWVjM4ZFBacndSMy80YmI3MCtaL1NkeDNiS3JEdVBVV1I4c1Y3TjhsaVJmQ0JwN01WV1pUdzBzdDMrUFREUnl3YXc5MDdFNFJRQkFlWGl4TGpIRTFkYytmR1BsVmRrVFlWS01VYnI3L0M3M3h5aXUwNjFsM0gxeVlKdTZNQm41eFBTYklVRHh4dUREbGQxL3pnOFJrcEZ1L2htNi9lb0c5YjltL2Y0Yis0ekxsWTEzend5UU8wQ1k0Z0pGSUZwQlNJRUZCYVhpZEl3blZpb2ZVa1NpR0ZJQk1DVGNENWdQTVc0eTNPV3pybjBUb21WaHFsTlVwNWdveHdYbU44WUJBckVxbnBuY1VMMEVveGlHTUtGZWlkUlFmd2VGUncrT0FJUVZ6THpFbEMxdldZWHFPRFIzdERyQ1I5MHpIMkxabE9hSUxCQVgza3FIdEhsbmkyTTBzV2VjcHdqZkpWN3pET2NLZFFITWlPTTFxR0loQXJ5YWFFcFhjTThvaWhza2hoQ1VLeWsyclNKSkFxUXlzNmNoOXdVakVXbGhpSWNPaXU1cUp4dUxZbDNnajByUVh2Q0M0Z1U4VlFYM01memdmRXRZOFRMUVZhQ3J4eENCRlFBdkFCcVJ4ZUtJSVNoUEFpZHpKNGZIQW9QTjRMSWdVcVdJUnc1Q3BRS0VrTWFHL1FMaWFMSlNNTWxYZnNhQmc3QTBwU21CcG5EUk5ocjNNUHBhQTFEbjFabDRUaEFSNkZVelc1cmhpTXRubXc3T21VWVh0a3dSdmV1akhtMmRNRlpiQVkyN0c3T1dSNmVVSXNGRUlJOUdETWNHc1hFM0lNc0hWN3pMTmhpZXdlc0Zhd25jVk02NFRKalFOMElUQ053SXFPZGoxRlJ3SnBNNXlLMGFsaWV6aWtLWHR1M2JuRnpzNE8vYU9QS0hKTHVlcFlWZ0VsQkUxWklUUWt0Z0VDSGtqUVJLa2p0T0NibHI0WGJJMEhMS3VhMjZuOGYrbDZrOWhKc3NTODcvZVcySFBQLzc3VVh0VmRYYjF5ZXBZZVVqTkRrYUtISHNveWJCaTZHUGJOZ0FYZjdadDVOM3d4WU1BbkE0WmdTQllNMGFabGJ1Snd4TkZ3T0RPY2ZYcXZxcTdsdnkrNXh4NHYzdk1obStMRnltTmtKaUl6SXlOZXZQZDkzKytqYWgwaGtxUEZnc05CZ0JEcjVJNG5KR1BmRXZvTzR6UU8yQmxGQ0J4WmtWUFhnbTRjNFZtRDE0c29paFdWdGVBMGlWQ2tTckY3K3liOS9VTWsvNHJyeHZIdXdSaHJXMW9oNlhkN2RCS2ZvcTZ4VHREcjljblRqR2NuSnlUZEJCMjNWSzFrZGo2bE00aVpGd1hHckIxSUx5OHVVRGpHV3pGN0hSOXJNOGF4eitYbEROazYybmlIcFF3UmZoZVorRlE0UHIxYWtBUURkamMyR2FnVTExb2EyOUNOTkFXYVRoTFRzd3FLQ2gwcXVEeC9paEdTNitGZFZwTXJIdllhN25SOUNoOWVUSmE4ZlBHY2I5emVwQmY1SktGUEVvUlVwcVVzUzNUYzRpdUpWZ3BzZ3l4V1dDdndSeDFvb0RHTzVPRWpOcmJITEU3T01ES2h2Sm9qakVXaWFHUkVsb0lrWXp6ZVp0RHI4VHZ2M09PcDJtUzZ5UGp1ZDMvSXNEM25xNi90STYzQk53WWxCQzcwb1c1cGxjQVp0N1pydHdaaEpXR1E0TnNHYXgyMWsyU3R4SGNHVHdDZXdEU0tVaWtpMXlBa3JJcUNqWDRQcVR5TUYyTXNoS2JDYUpCMWpXa3NUa2xVa2lDMHd5VmRuTE1FZVlIMWZLcGE4YXVQbnpGSUxYVlZrTmN0dlRDZzMrOVF0QTRwQWFsSnV0N2FHZVZDcXFLa285VTZBQ3ZoZXJVa0RoVlJHTkpOTXdwbktPWUdHMGllUFQvbXJZTjNlTGk3d1prUzlMd1Y0NzBSZGR1U0xhZk1oVVZyaWJtNElsU0NwcmZCOGVTU1h1U1RWeTNPT1Y0MjBJc2NJeVg1NXUvK0F5N3ptbW1lb2dmZFBydTcyMGdFbjE3TnlUcWFwOCtlSUtTSFFMQzNzVWN5R2pJdFY0eDBCMm5oYkRMaGNIZDdmWEM3UFNKUFVaY05icGtSYm0yRDB0akFveE5VM043ZllSajVERU9mZG5zVGl5VXpIbFVoYVF4SVB5RmZMZkdOUWVvRmllL3h6YnNiL05YZ0hmNzVuMzhIbXkwNWFsZk1yK1lFeWtPM0JnSHJKRzBZNGp4TmxaYzAxaEhFQVJLUHJtdklWbE5hMDFKWExTQVJZYkllMG94bFVoaDYxckhkaitnSGt0eEovTjZRVkVqc2JJNFFRSGNFcnNLRkR1Y3N2dWZSbENYS1FsQXZrRUlnTGZpOVBzMTV5ZDNiV3h5K2VwTS8vOE9JRjR1TXE2eGhvd3RTQ0M2eWdsQ0g2NUNKRUtoR2NtTjNtK3p5bXBlekdYWHJ1TXBxRG9maE9wbFVXMEtwMlQzYzRlVjh6aXQzOXNtYWl1TjVTajBjc2VGSmpwWU80eHpwYWtXZExVZ2J5Vys5OHdiZEpJTGhGci84OFk4SmxLVVo3Q0FSNUlzVlpWM1RYczVZemFjMHlzZldGYnFlWDlMdDNhVVQrR3pFT2ZuRmdpcHR1VHlmVWprWTlQdnM3QXk1c1RXa1FpT3hkRG94VjlNcnJKYVVXWUZVQ3VjQzBralQxUW1Gc1d3MUpVT3ZZdWxyN0xMZ05EK2p0ekZnZUxETmFqbkdsQy9YNDZvb01HVk9yQVIrUGFkcEpOMW96TDIzN3JQeC9nYzBLdysxbUZMVkZVS1ZKSUdQRUZEcEVDVWMwclZFb2tJTENUYkdrdzRuZlR3VklhV2xzUUZ4QXZwejk2S1NHaEZJVGk2dnVURWVvdU9RMERtSVlxNVByK243YXUxSklLT3RhcHEyeGJRT21TNkpQSTJ0U3J4UUk0UWs2SFhoYklsV2d1T25ML0NUTG9lM2JsSjkxbU1ZQ3B4V1dOdmk2cG9zS3pBV0JJN3A4U1YzYit4QnAwZFFXNVJwNlJ0Tk1abXgrRHkyYllWa3Z4dlNkem16cWtKV0ZaUFpuRG8zcE1WcXJhU2FsaGVuVTI1c1JJeGpuMDgrZUI4aEJidmJZM3F4WWhURnJCZTJMYk91NEd4bDZVWUI4OXJRQ0Vkdk9FUjNSM3VrRnhjMFNwSlZscmpYWXlZcWRwUWpjNUszSHo3Q2EzTmk1YWlxQ2ltZ0NDT0t0aUdmTERDZGdFR2dpQVloT3V4eThvc1BXRFNPK085OW1jQnJzQjJQN0hMQ3NpalpGelZiT3gyYXRLR2FYMkNxa2hhSFg1UU1BaER4R0ZySFpMYmdULy9sSDVMTjUwaFRNdlFhVmtWTkU4WkV5cUNGd21sSllXb0czUWlQdFpOSWk0YkcrY3puR1ZYVmduTkVYczFPTjZReEZnTTRKK2dIZ3IzYjJ4aHB1Y29MTkpLa0MxbzVWb3NsRGtmc2QzRU9zalRER0V2WDFRU2RoQWFMTkMwU2dhZ1ZVZ2xrYTdoSVY2eWVmTWI4Nm9KSGtXU1lSTHk0dUtadURSMC9CdTJRcmtRcHhXQjdqUFFrRzU3bVhBWFViVTNSVEluRGdLM3hBTDl0S1UzTDZmUWEwWlJFeXFOb1d1cTBSaGRMWWdXVFZRWkM4dFczN2pPSVErcDBpWlE5YW1QeFBJOVFTYlIwTFBJMXJjU3BrTTBrSWNidzh1eUVlU000T1Q1R3o5S0NUaFNCRkd4R2tzZkh4d1FPTm51Q3FvVWhVeGF0NW53eFI4czEyTWs1UlRmcU1PeU9pVi8vT21FUThPSVhQMk5MUktqRHUwU05aVFV2Mk4zYTRXSjZUdE9BYXdYTFNjSFJwRWFzTGtqOEZ0ODZXQzZJcUluOGdIbVJVUnJEUEZ1UmQyK1NqSWJvSm1DUWg1eXZNbFNha3NVV0tUUnhJc2t0VkZSRW5pTlVBcHlnYktBeUdsRVhHTmR5UHA4VCtSczRXZEsyRHRGS05vU2dsWUtMMmZwbWJqdnhZQ29JUklVZXhsU3RwVmltT0cyeHhtTGFsbVUycDdjNzRtS1NvNnYxY3ZTQnFxaGJpUkNTb2Q5QldjMzA3SXpEcm8vdldxSkFvWTFFdXBMV2FoS2xrY3FSMW80ZkhtWDh4cGZlNWxDRUdOT2diTTZPMXRSTnlmRThwVEdPT0xCNERqWUN5ZEY4UmV1QXhuQjNIUFBtYnA5V0NENDluL0xoc3drUE5qcHJwM0JyYWFRa0NEMnNhQW5EQkdzZGk3cEdlWktvMytmdS9RZGNwQlZTL1EzaWYvN2RPODZYSHEyMWVOb3h6MXZxMlpLdGpzSktSN2VYOERSMXVMS2hrQkxwSEJmVGpJUHRMVzVzYmpBUlF4b2d6M0x1anhQazdnNTUwZkQwZ3cvNXdsZS93dVJxU1VGTFdwVE1aak5vTWdKUjB1LzZ4SjdDbFRVcVc1S1psdWZ6aXJxeEtGL3hlT3MxanVaTG5CUHNPQWlQUDJTb0trTEZPcGNvZlNvajBFRkkxQjhSQnQ3YXVCS0U5TFdpMytRRUdtcXpYZ3VmWmlsdGExa1VKVnF2MDB4TlUyS3gyRllRaFNHKzU4aHFoYkdXcm1kSmhLTXdGdWNzc21xSVFzbGxBY3VySENQZzRLRExOSzF3MFpnbi9mc0UvVEZIc3hOZU9mc0VUMG5jNXpNazUxcUVkUGpLUXdwQmlXQ1I1dmhTNEVjaHNhZFFXRHF1SmMyTHRhTG5vQmQ3aERTVXJjVjVNZXJ6TWIvVENjaXNSU3RCMjRKZkZ0dy8yT1prVmJLc1c3UnIyWXcxVWRCaHFkYlQ4SzA0Wkd0L0Qvc2J2OGNUNHpHWkxQam4vL1NmSWY3SkYvYmMyV1JHYTF1MkVvL0xwV0VVZVlUS1lKMmpiRFZYYWM3SnhMRS9XTXVuNzErdi9mbHYzaHNUK2dIT3dTZVhFKzd2YmFOOFRhZ2xoZlNvV2sxUkYweXpFbXNkMXVRMHN4bmQyTWZUSVo0VXFDQ2dKeTFWVS9MQmRVWmpIWDROajZPSTE5LzlHczRKUHZpTFAvbjNzMytBblE0b3FSakVIYzZ2Rjl6c1IzeHBiNGd2QlUrbmx5d3JNSGhJNTNCMXdXSUpTK0QyUmtRZ0JTOW5PVmtMdHpjRGRGVmhHcGlsOE9ZT3pQTTF4eUJXRUlSd3RvSlJUMktjNWVVRjFCcGtKMlRuTi84RGtzR0lYMzd5TVUrLy85Zi9IaUNQWEFPQVN2di8rL1FnRm1UVk9wdjR0NCtlaHBVRjkvbGI5T2RaaUpFSFFzRzBoRDZ3UDRMVEdSaTNQamF2anVDMTdRMWVMbGVZeHBLTGdKM2YrbTM4OFFGM1hyM0xlSFBNSC96aFh5QTZ0dzRkYllOdEhXVlJZSVdHdXNUejE3dy9wZFl5cTRyaXRUSFVDVHd2b0NtV0JKNWFjMm1jdzlMUTdjWUVVUUNBcjBQcXBtRzZXR0gvOXRPWDFWcFFjZ2E2RVRpSHAzMmFzc2J6QTVwR2cyMEpQTW05VjEvRElFQUpqcDhka1oyZXJrVWYzMXVMVlorTFZGNGNyczhZS2ZHN01iYXUyTnNhRW9WOUVKTExpeU9zZFd0bnJITWszUzdUODJzb1c1TGRIa29wbFBReGJZMjFyTTljUURwSDRIazBaaDFRemNzUzVSemIrOXRrV1lFRDZyTGh4dDQyQndmYnZQUEZMN0MxdDh1LytJTS81bTkrOEROOFg1T21xN1dRdGtxSmR6Y1k5Z2NvM3lQTGNzSXc1T3pzakNnSWtFSlNXNHRvS3JaM3Q4alNIQUhFWWN6Zis5clgrUER4cDV5ZVg2NjFDZ0ZabGhLSE1kb1BjS2JHT2t2VTdYRnhkWVV6RGQwNHdmY1Z0cTdaUFR6RTA1SitFakxjM3FSeUhzdnJhOExBcDlzZG85OTc1MTM4SU1JSmlEb3haVjR3dmJ4Y0d4ZVZ3aFlWVWVTandnNkxWWVkxaGlSVTlNY2psUFNZcmpJYTV6ZzZlY2I5MjdlNXM3Y0RTS284cGE1YnBvdU1xOW1FdW1uV2ZyaFdjblo2d3F2M0h0QkpZdDU2ODAwK2ZmYVlVQWYwQmtPVWxOeTVlWU12L01iZjU3dmYvaVBTVmNiMGpTbEtDb1plUzdKekUrWDduRjJjTWp1K29KTjB5ZW9LSjJHUmxyei80eC95bTEvL0JtSGNvYXhxRnF2N0tBZkRYZ2ZUR043N3htL3o1OS81Sy83cWh6K2c3NEdXa2pkdTN5WGM2REdiekxsMy95NUp0OHZGeVRHMzd0eWhXcFUwVFUzdUhKODkrWlFIRDE5amVqYWhMSEkrL05YUHVIMXpsMXUzYnVFMU9mWDFPZS9jdlVtM3J0bC81UldTN3BpbWFmamxqLytLOTk1N2wzNS9oOWEybkQxL3htLys1cTl6L1BJeGk2dHJoUFpJYTh2MC9JeXZ2djFGU3JPaUxqSSsvdDczdWVrbURCL2U0cGY5Qk5zNlhuLzdEU2hMM25uMGtGdTNiL0dqSC8yWVRyZEQyQi95WjMvNko1UnB5dTkrNjV2TTVqTjhWeE1sUFdyVDBsUWxqMTUvaysvOTRCZVUyOXNVeXlYdnZmYzI0bi80dlY5emFRR05zM2hTMFlvYTFiYkVjUWc0THErVzNOdnAwNGtTbms0enFxWWxxekx1REdJYXB6bk5DeXJiOHQzSFp4eXJpRzhrSWNwYS90TlhoK3lQdWh6YkxoK2VUV2hNeldzYm11ZnpsdWVMQlRlREFFOUtOamI2ekFyRnFCT3Q0OVBXTXNzYVBsc1ZYTTRtYU9IbytKcW5qNC9ZZi9BS1pabURCZFVhRGlMRGpTU2lGQWJyQkNlcEpmSWxyeDl1a3dWRGloYnU3VzF5L1BSblBIdHh4YlJxZWUzV0RmN294WUx2VFZKMngwTkNhL2l2RHJzYzlCTmV6dWUwYlV1a0JVMlo4dWpXRFpaWlEyNWFkQUNac2R3YWRmbnU0MU9zY1FnVmN2dGdpQitGMkdpSUZJcko5WVJOMzdLL2M4QjNQbmxLYlF6TG91WGVNT0xUeXdXbGFkaFVnczF4SDkrWGRDT1A1UFBwNWZFcW82UFhlY2xRQzRybGl2RzR6M2taVWI3M2RjWTNidkRwTHo3bWcvL3ovK0R1S09MdXVJT3BNd1pKekZZM3BHMGJaa1ZEMFhnOHU1d3lqZ1F2MG9iU09FWkJ3UDJOaEtOcHhuVmFNaTBidG5vQmVubDBpaC9IYUNCeEpYN3NvNnloWEJRQWJNdUdublBzUnpWem1aS0xscEdxTUkySHlLN29Tby9ZQ3U0T2h1eS84UlpQLy9YL1ExdERzMTlqZFUyZXIzaEl6dEk2Nm55TCsrR1M2aXFuRzRPdkpKSEwyTm9kVXBjMUVrRWtMVW03d3ZmWGFjQzZhZW1IbHErOWNZZldOaXdXYzR4MTdHMlA4RnVESnh0OFd5TWMrQjBmSVN3aldmUEFOMlJHc2p2ZTRlZnZkeGlOV3BLbVpicGE4V0N6UzNYekRrK2V2OERZbHRPTEM4cXB3TlNnVk1zVjhPWFhidEEvUE1BKy9SQnBLN28yWU51WDFNNXljOVNucVZ1MGRkaDhnWExyeTdDdkZNOSsrU051ZlBGTExGS0xieTF0M1JLVUthOE5oOGpXc2lwcVB2ejBHYThjN0tCWEU3eWlRa3BCcnhlRE1pZ3BpRVdPYUNFT0ZQUHJCVkZvNkNRSkZEVi8rUmZmNVMyYjhaVk94S1BFOHVjdkx2bkNWKzZTbGhXRmd5Q1ExTnJnRHdNMk5mUnNSVm9hcm83T3VEVyt6ZjQ0NExITHlZU0ZrNWZvS0U2Z1NYR3VKVXFpTlJ3cFNCQ1pwVzR0bzBIQ3pVNU5iUVNKVm1nbmlYMDRYODNwUlNHYUZxRWxHLzROenFPUWVtc1R0OHJKWlVUc09VWXE1LzNMRmFXRjM5b05LSnpnL3Q2UXdocGE1OGdyUXljdmVINDJZYmt5Q0tuNHdyM2JkRjNOTFdrcHJXV2oyMkhUdHB5dE1yeXRBYWExaE5xUzlFZjBwS014SmRMQitiekFGaW1uYVBUZU50YnpLU1hvL29qSlpVclpXSXhwMmRnUCtmVjN2c0pvYTRzbXowZy8vRXMyWGNQaDNnR1Q4M09hRnFxaVl2cjRFNnE2d0FtQjM0dW9QSityR2RUV1lJUmxtcVYwYzh2NTJUWEVFWW1uT0R6WUpYUTV3Y0JqY09XalhjdUduK0JYUzJ6UVFXckZLdzkyYWROTHRLMXdhczN3OFV1UFVTaVpGelZHS3dUUWkwSk9WZ3Q2b2VQbytRazVtcXFzY1U3aTlXTTJEMGE4RjRkSTdaSGFrbW5lZ0lDTmppTFdqbTRJNWRUUlNzRXJyeHhpaGNabUsyaHJQTzA0ZUhDQTNoNUZMSmVHcG0xUldsSFhGYTdKTUVKUkMwY1N4aFRXTU1rcW1ySmNNL3BDZ2JPU0Y5Y3JIdXgwaWIyQVRxRklWeFd1MDBjNGdlOUFXWTNuU2I1NE1LQzBBcXU3WEM1TE9qN2txNEs2YVZua0M4WlJSRGVJbUU4dUtZemxaSHFDakdMQ3VpSVJqcEVwdUJZK3NSY2lnelVRU2hVdDJpbTZTcUNIUTZ4dy9QTGtBenBZQWsvZ0FzaE1ROCtQcUozamFKcFRtSkpoMStkOFZsTzllTTdGZEVhVFpVeWVYSEgzNFNZYXgrSDl1MnkyamlEeFVXM0pWbjhUSndXbGxSelBhOTQvbXhEWUVrOUlkb1k5MHJ4Z2J6d2dFSmJDR0U0bU9XNTdTUDdzWTZxTEM4ckc4T3JkWFlKaG43ZkxHb1JpR1hVeFRibWVRZ3FGTVlhcmsxTUdVVWcwM21JbmxDZ0p5NkxCQ3pYejVaS3NLVWlkNU9qa0JhLzBvZWZCcXlPZnJHeTR5Z3hGWG1DQ1pKMndkaTJSYUNscXk5dGJIUm9IczhxUk5TM2p3WWozUnYyMWV1dHA5SEo2VFNzVnJiUGtqV0dVUkt5YW1yeHN5SzBqVFVzYTErUERkb0M4ZW9ad0xRZTdDbCtESDRVb0RLSFdQTGkxeGMrWE9WbWVJL09hakI0cEhyNkVLTEIwaE9RcW5STTVSOTVJbHJYQkdVYy9UckIxaXFzYXRqYjcxSzNqZkxMZ1luSE5Ld2Q5QXFXNHlsdjJ4b0tydkNKM1B0aTF2L0JSTXlVWURXZ0tnY0t4UCtxemxYalVPdVp2bnA5d1dUczY3MzBUdFhNSGN6ckZGaG0rYkJDdVpYdi9rSS9QcmxHdDViMEhCK3p1SkVTUmgrYzFER0xGeWxxTWE4RkpFQjdOYUJOZFhxSGNqUHA2dmtiTHhoNjlVS05seStucGpBWkhmM3lMby9NVjk0YWEyejNGb29hUnJuajh3YS93bE1UWGlzUHRIYzVhUTlUeG1VeHlYQXZXajhpMXoyeTJ4RXE5UnRocXlhY25TL1lpemViMkRYcGh4R2kwUVp1ZGtUVXRpeHA2dnNla2hGNFFnWlNVamVGSDd6L2pTL2NPeUlzQ2s2K0hWbXRxblBCNWNYN05vQk1RZUlMZE9FRGpyYjNzcHJXb2pnYlhrbGVhMEMrUUxTaGhpWVZEWlVzR053OUpQTW41NUFtQmcxQ0FOQjVGcGVqM09teUloSituRFg1akVMSmxVdGFNd3BCQ0dJUjBXT3U0dUU3cEpvcURTTk02T0oxWEpKRkhOL0Y1dXN4cERkUzE0ODUyRHlzRHJKRFVsZVR4VllHMkJ0OExDS1drOFNvSVBOS3FJdkY5UWlXNUVTdUdneTUvL25MRzhVWE9SZG55a3g5OG4zcnZQbVhUVUptR1NsaDJZOG5PNW9CME9zWGxLMGFKcG1vcWxvM2hackxKMXFCRHg3UVU4UmFMeFpxc2ZmckJSd3o5bW5zRG4vRHdEVHdsZVg1Mnp2SHhFYjkrZjVlM2YrMHV0Wk1jaVE0LytjWEg5RGRmWVJSZjRRV1d3a1NJcEk5c01tb0hiU2laem1wc1ZUT09KY3BKbnM5YnFrWnlzbGh4ZlhXTnNmRE92VU5vTEVZVWZQYlpwK1RTNDJvNlora3BQamd2OGVVMWIyOTE2SHNDRllkY3oxTGExdkhhelIyV2FVN2QxQVNSajZjRUtxdko4NXdhdVU1cUZ5MWRUNk5sc3c0eVNPZUluYUlvYWxhRkl0UUdENEZXZ2d0L0E2S0tXL3RiOUgzRnMra0w0cUNoNjBEN0ZWWmEyc1UxV3pmZTRsdi95YmVvcmk3cFpLZEV3dUdFd0ZSZ2JFdWE1ZXlNSTE2Y1hkQ0pFanpoRVhYSEZLMWhiNVRnMjREYUdJYm1GTk1vQm9GQ0lGQmJCeXdXMTh6T2pyajU0Rlc2U1V3MkhKR2VmMHkrbUJPbExhR242WFE4Rm5sT0d0MUU3YlZzR2tOLzNLZm85TmpvRGFtMHhtYm5MT3VJRy8wSTQ5WitkSG41aWdBQUlBQkpSRUZVd0tmem5MMDQ1Ry9lZjg3NTFZckhjY0R1alcyZ0pPeEVCRmg4MXhLcmlKdDdIUzZ1cmltYWxwZFhFeVpIUzI0a01Ya1Q0SVJtS2d2MnR6Yndld1BDYUlQSUdOTFpNVExab21Obk9HdW9seG1UNnhtVDZ6azNidTNRRHozMm94YXBDNjduSlVvWkhJNTZmb1hXR2hmM2tBNm9ETTVZZE9qd2dnZ1ZkSm5VTlJnTm5tU25FOUxpYUozbFJWR1IxUzFibnFVbkZFdnJFY1VCenVROCsreUkxQ2x1YnNUb01pM3BKNTMxdUNvczA4TGdTc05vR09GcFFWWTFiQlNYakR6RDZ1a3hoWkJZVTVKaXllc2E2b0RTR1RJMzQ4bnE1NXlkUEVVM05kT1JvbkNPZnVReFd4YlkxakVLSXdKUmNiZ3pJTTFLMnNad2ZqNmpKMEpFTWNWVE1jSkJZQU4yK3lGTnNhQzJqamk4b0d4YTByakg2WFRKZEZVU0RjYzB6cWZmQ2VnS2cya2JxQ3huQy9ETmpKMUhYNkhUN1pHRkllYjRVMEpSNG51RzJITTQyWEx6NENaaEZOTVlnOGd0WmQzdzVUZnZNKzZGbEszaGh4K2U4ODAzRDFGVlNvc2w4VnN3UzVhcHhma3hnV2ZZN2tkczNCb3gzaHBRYUVIWnRtQTF6MDRuakRzeEsrZURoYWZuRTB5NUl0V1dXRW11L0Fnd3ZIVnJHeDE1R090UW5tSjcxRU1GTVMvNkVXMXJhZktHdzY1SC8vQ0FCNy96TFM1WEtYLzAvLzR4bC9NYzZTbzZxa1pLVGEwYXJsWTFWVnBnRVVTKzQzaVpZYklDdjY3cCs1SmFLWjZkTHRnWXhPenVENW5Wc0tnZCtxSnNPVE5ybGEraHdUUXR2blMwaGNSWGdxdXNvajVac05IcnNLeHFmT1hveFJGMVZYQzZjaXpTSlMyS2gzZVhwRnJ3OVBRRXI2cjVjZDZoRy9wb0hGbVIwdGdXVTJ2R0E0bG9EZWkxTFVva2ZXd1NNbWtsRjRzNWpUR3NWaWs3ZFlIU2EzZE9jM1pPV3JaWVliRW9wQ2daekNaRXZ1SzBMbWxXT1U1SUJvTVJsN25oMC9OenhrVk5Fb1hNclNBS2ZWeGI0NnpoNWNtRS9VUE52L25qZjhWcU9xV3VLbjR3TGJtY0xybTUzWkErSy9Ha1pERG84ZEhsRlJldG96WXR5MFZLRWdiRVhvR3B5clVjSzN5U1FjUW5tZUdUaXltbWJkbnlGZDNFNThPWG41QjlKZ2g4eWFvU1pOTXI3ZzBDbGtJd0VUVlBqODZaSDJ6d1lsWmlyT0R1UnNUUFQyZG9wYm0zUGFBVGFFNG5PZGVGNW1pNFMvSEJ4Nnp5RXJUUHlvdDRNcTFaVmhPTWFka2NSVXhXSzlwMGlRQmVlZmlBOXk5ZkVtTlFudUxLdFZ3VkJiT3E0SlB6aXBYeHNNNFJYNTBpOElSTG9nZ253WG9lNVNvbGpCUTM5dmJRU3ZQcDh3dUVzdlRERHQzaEFLazFsb1l5SzFsa0tmMXVCeWtVOSsrL2lvc1RmdnJ6WDFCa0tlYjBqTTliSXRiUUlMSE9IcWc0QUdkcHkzck4vKytHT0dlb2pjQ1VueVBlRFlnUTRzNTZoVEpmRnY4T1JpUmpENXpBbG9iQmVMMDZLZXdhYnFrRGJ3MXZxbHE2V3pzSUpWbk81OFM5TG5tV0FaYU9IL1BsTDd6TDl0MkgvT3BYdjZTc1MwNVBUOGhlUFA5M25RWUNhRFNNdC9xMHh0SGFsdVUwQTEvUzZ5WGdXZ1FndFkvbmVWd3RVb3hwd1lLdjVScVdIUVRFd3o1Q0s2NnZadXdNKzNpMm9uV0NSVnJTdEk1T3BNbnJCbUVkc20xQis4UytvdCtOQ1h5UGQ5NzlJamZ2dmM3enlZeTlXN2VwbTRaLzhVLy9kNDRmUDJFNGp2RjhueWJQMFVvd3kyckNOa2NJeWM3aElWbmJFa21EY3c3cjREcHI4VDNCZEpyUjdmV1JucUxmN2FBUkhybTNoaVZKcVNHSXFEUTBYb3oxUEl6MkVaNms5Z0pxTDBSNUhyV0JXanNNQlE2TkRnTFFIb0Vmb0pSR2VzSGZxUmwvR3pJUjY1YUZWcXdwbkZDRGdFYXYxU3JYQWtKL25rWnBjVXBSZXo1V1NCRGxlcnRZa3pweERvU2lFaHFuZlZ4dEFVc3RKVWdOVWxCcS8vTjlLMXF0MXNTclZ1Q2t4UG8rZFZQamV4cm5QTkIvaDU1cXBVQW9nWEVXNDhXMHd0QzJMYTNLUWZwVTJrTTZqUkFDb1R6d1E0eE4xN01GSExWU1lBeVZjL2pLUi9vK3JjcW9oY0w2RWM0S0dzL1JlSkpjZ2xFU2hFTm9pNVVoVWp0QzVWTTJsdXRsd2F1alRaSjZQV1ZUV2hLR0FXaEY0Mm53UENxdDEraFlhY25SU0FTRlVMVEMwV29mZ2FXMVlJVEFEeUxRRFhnZVFtdWM1Nk1mdmZNV2pkSjRua2N2OU5qZDNHSlpMVGpZdTBrY2Q3aDE0d21SNytINVBwZlhVNXFtUnJZSllUU2l6Q2E4L2VZamJ0eThnYTk2WkdSY0hUOWpzZkM1TW50c0R5TzBINjMvY1FqT1RrOXhLcURURzlEVU9WSUlOamMyTWFiQTFnNHIxdEdqK1NybFlHY0RMZGRhKzlQVE00eHdDR0ZZWHFZNDV4ajJ1L1E2Q1RmdTNPWm52L29BVTllRWdjZG90RUZhTmxSVmhYQ3c5OW9qV3JldXFrRUliaDNzOGwvL2svK0dLcS80MFErK3ozSzE0QmNmZnNUVGJzTGR1M2ZvakhvZ05OY1hsOXpZMlNaZHpUSEdVTGZneW1yZHB0THRvclRrK3ZLU0pPbnl5dzgvb2FqQldZdUtMSlBqYTdSVmZQWEJmUTRQOS9uNCtJVEorU1Z2UEh5Tk1JNVlMR2U4T0o3aHRRMWVvbEZDY2ZQK1haYUxnazgrK0lCN2Q3WlFRdkxtdTEvaTdiY2YwUDR3WTNMOGxONWd3RHVQN2xQTUxybDV1SS92ZTZTTEdadWJXenc3UG1leFdDRXR2SEhuQVJlbm43R3pzODNHc0w5bUs3ZWFWOTk5bTUvOStCZUUydUZhUnlmc0lQNlhmL3k3N2xsYWtsWU5uMzN5RWQ5Njd4Rzlia0FTOVlpMVpqV2RJMExOTEsvNTlHS0JiVnZlMk45aFpYSm04MnUyaHB1TWtwQmZIVi9pbW9MbWMzZE90aWg0WXljaThpUzFYWThCT3ZUNDZLb2thenM4MklpSUFrMk9oek1GamFreGxhRjFnbWZ6aWdlUllCaHJISTV2SDAvNW85T2NiLzZIMytBYnNZZHRhN3BKekMydHNjYnlMMy82SzZxbVlUdFdqTGNPdWRKZHJsY3BqYlZzam5jd2RZNldMYzRLWHI3OGpHWjJSUndrM0JvbytwN0huZGpqMlh4SnJ4UHh3OHVVckdwSXA1Zjh4Ni9mWXFSYVdnZXpCdVpaU2pkTUtPM2FMajl2QXBMQm1NZlRGY3UwWkZFM2RGOS9oMy96L2U5em81cnluei9jNXI5NGM0OC9PVit4VERQR0dzYVJUNlpDWGk0TkIxMmZ6Y1JIeXJYNitQNWt5WFJaYzZ2dlV4cExyWHltV2NuUjVZUmIvWUQ5UVVEUTZmUEoyVFhOWW9GU2dxMWVsMkVTOHZPekJlTlFrZGFHRzkyQU9PN1M3eVkwTXFCdUhZMlVIUFlrMzM1eVFWU3REU2V2M2R4SFh4MDlZWldtU0tINHh2ME5XRTVvWGNCcWVrWXVRVXVQZ2JkSlhlZDhZYWpKR3dpS2F5N25NMVM2UXRvR1cvaU1nVHFkc213Y0JrRkgrMXc4dStCd3E0K1hYbUFFOURaM3Fhc3VoUzNKb3kzaVRvZDB0Y0JXaHN1ekt5cC9uVDNvWU9oTFNjRDZVaHNpZVBPTlIrVHpTOExwRWxHM1JKMFlJeFdxRzdEajVxUk55V2Uvdk9ibDZJcTNmK1BYR1JRdkthcWNkdjZTUUF2VTNsMkVEcmdRZ3RjaWVHWFBwNWhjWVV0TEZNUWN5Z3JiVk55VkJZMEhXYVR3MGd2MmR6YUlQTVhIRnhtMlRsR3U0ZWlUSTFvQlgzeDBIMU1VM040ZjA0MjJlWmEzZk9tLysyLzVzMy80TFphMkpsUWxlM0ZPMGl6NTdPZ1lQUnlTdEJIZGdlWVdTOHFKWVpXRktBVzlUc0NCV3hHckJyRlV4QTcyTzVLMnFnbFV4YVBRWTF1MklFcFNUOUlFQWNaYStyYWlLejEyT3lIbng4ZmtqZU51T01LdkJlVjB5WEVoeVkyanFYUDI3dS94MmlCbU1hL0phTmozUzdTektYM1hVRm1EYkVQcVZqS2lKVWxDckZ0WDhIVGpnSlBaa25JeFEwcEJaLytBVHA3U0czU0lleUdoQjArdTUrdUlXR0FwVzBoNkhnYzM3N0ZJQzdZNmtzcFlvbTZITFIwVExtdTJ5a3U2ZHNwMUJwNFhrcHVXNjZxaHNWRFppTVlJZGhwSnBEVnh0OHZ2ZnZPMytmbjd2K1NudnpvaUx6SytjVytIZUh1RENvMHphK3R6YjJ0SXgvZm9IVDBocThwMVo2SE42Q2hOdkRvbTBqNVR0MEM2Z28xNGcwRnZGK01zazJ4QnB4T3p6QXIyZlkzMW9BcUdMQmNMbm9xVU1GQlVVck96dWNGeVZmUGVsOStpTkJhYWt2MkJRT2lTS1BCWVdvbGFudE9OUTF5bGNVSXlyUVFmWFZYNFFjVCt6VjBlYm5iNTRVZFA2VVlSaVJSNDVaeld3WlF1eGdrMGtqaGMzMUFtWWNDNFkzbCtuYk93UHRJNFJPMWo2cHlnNDVFQWNSeFRsUm45VUxLSU8yQWE4c1l4U2dTdDh0QkpqTjgwUERtNjVOYW9abU5MRTQ0SHBGVzlEZ0g5em43MzkwZURQcjBrWURTSXFFMkQ3d2xhcTllTm1XcWRJTW15a2s2ZzZQbWF5K3RMeXJwaXMrY1Q5b1lFWVV4bFlkVXFKbGNMWmxrRHZSN2JrV0s1U3Frbkx5bkxGWDV2Uk5XQVNCTG1oRXdNOUYyRkZJYnp3dkE4YzZ4cWlIMU42QXpkVUZJNngxVU5CMS8rTmVheml2eXpKeXp5a3J2akRqY0dYZEttSnV6MkdRNkc5S09BbmhJVXM4bWFYV1FxK3FISGZKV3luU2hpV1RPNXZzSTFEZmxzeFhqczB3LzEraWF3TWpUU0ovSVZRYkMrbVJwdmp3aUNOWno5NmFjbmFPV0k0NEM2YlZIQ0VrakpzRGNFN1NHOWRUUHBuMzA0bzRoQ3pPS2FMNDBEdHFPSXYzNTJ6Yk96T2RJUHFPcVdENjhML0RLbEYzdjRvVUlGR2w5cnJwWTU4elNqV3M1cHFoS2hOY2JDMXU0Qkc3RkcrUUd1UDZKWVptd05lNHo3WFZvQldoZzhwUkZLb2p5TnJITTJ0OFlNazRCWkxkRlNFL1VHQkowQUVRMkl0RUJyeGY0NFJDdmxvVzJKRXBLNldkUEJrT3QwYkdzdGtlY2haTWxpY29GL2VCc1ZlQ1N0bysvNWJBOThjaG5UV05qYzJLV0tEU2VWbzZvYTJ0bWNoV3RvbGNkdyt4Q0FXZDdnNlpnM2QwWThlL0dDcXEyNU1CMGl2K2IrT0NBdENrcXZaU01SaEszaWNyVWdxeXpFUTc3K3hYZjVzei85THZlOEd1MDcwanlsRFR6R1VSZGJOZFN0WmV4NUZIM0RrU254TEJoamtiYmg3bmhBWFRiWTBtQlpkd3J1N2NWa05rYTNIaXduTkw1UHVsZ2h0U2J3QkJ2OWdFVlJNbG1rV09kNCtIQWZVem1PSmxPSWUxZ25jTktuS2hWS2VjUnRnL0pEeHZ0ajZ1ZlBPRGpZeDFjekVzK2hQTWxnYzRTT0V1Ylc0N0lFNDNmWmpudjRXdEE0UVZXVlpOYlE2dzNaSHQvQWs3Q1lMY2htTS9iR2U2d21WMWhyTVkzRGp6Uk5iU2hiUTFsbWJHNXNraTR6WkZVU1dNZm05ZzZ6WllhTGZCNXRqNUJhODh2VGxMS3E2TmM1SXBKVWxhSE1KT3FiTjhQZkQrSVFML0RJVzQvVzJiVjdWVFpJWitsNGhwcUFLSTVwdFlmV2draHFqTEdvYm8vckxHZFdOQVJSVEtnZHM3eEJTcmhhWkdCeXRqYzMwTnJIODJKZXBnYmJhbExkWWR3TkdQYTYrRUtTbnAxQUdGQVppM0pyQk8xRlh2TGl4UkVYeXd4ZkJXeS8reFgrNFAvNnYzbFROZ1JDc0QwYzBvOGpPdjAreTZLa3JDcWl3TklOTzVSRlJwMFg0Q3pqYnNRcWI1am41YnJBMGxwVWE1aXVXbFlYVjJUWE0wWTlqMG9xbmh5ZjQrcVVORTFwNjVaTzRxTWFnMm5oY0dzVDBZbXBoZVZra1hLOVRQbmcwMU5rM0tIMlBLYlM1N2lXdUlPN0hDK3UrYzUzdnM5dmJYYlJ3SFZoU0FLUEltdFlaUlVMRWZEVzJMTHB3WEsxWkZtVWRFWWo2cnhBTzB0VlpKUkZ3U1RMR0NVaHM5TVgxTUdBQW8vTHlaUklTcHhvYWRxV0xNdEpBaENlaisrRnhGR0VGQlpyREthV0NNQVp3Nlh6b0N3WWRrS1dpeVY1VWJEYkZhaC9zTi81ZlQ4TVVVcFNPc0hSZGJZbVVHcEpDM2pTSVdxSFI0UFVDczI2dFVKTHhWVXQrZmo4bXBQNWdxZ3FlT3R3ai9QbEhDMHNTYUF3VHBCZlRxaTJiMUVHQThLMm9wWmdKaS9ZN1liMHRXT2FMbEdpSkF4ajhxSkV1NXBSNUJQWmtyMSt6RzR2Wm5lalQzTndqN1NvR0YwOHB5aEtaTnR3L09ReG84R1FsNWVYVEJaTGt0QUhVNkJjUTZjVEVNUVJwUldjRmdMcDFnMmFzaFZrclVhVUMyN3Rqd2c2SHN1cVpyQjl3S1JvbUphR3lrcTBzL1JEU1pIWE5FMURVNWRrcldObEpFZUZwVkFCMi9jZjBkMDdRSW1DU1ZseG1lWjg3LzBQZWUzZDMrQkw3NzdLamRVNTBsbk9zaFl0ZlVTWkkwMUZSOVlZTDZCU0VXbVZrZGNOWVYzUm1KWllXSzVxeTdJeGhFMk9URHAwOXZjcFdvR1FFck9jMEtHaHNJTFNyREg1VXJWNHdrZUtCazlacXJvQ3JSaHVqbWdISTJvLzR1VEZNWXRWQ2syREYvbVVCaEpuMFVKcmlxb2xyeDNHR3Q1OXNNM1JkVXIyT2M1RUpqNjdvNEN6MUZKYWg4V1IwQkpweWNtTHo3aThuRkE3aUxkZTRjVmt3U0piZjVHeEIxcEY3TjQ2UUhaQVUzSmVaVlJvZHZvRHluU0NDaFIxNjZHREhqZTdBZDI2cG1wYUd2bDVhWlZhNysralpjUDdILzBjSndRWFZ0RTR4YjZ2Q0VUQzZXSk8rem1PTFM4YXNxYWhrcHJaTEtkdEROWUxpR1RGZFZGaFcwdlA3M0RyMWk0bUMxalVMWGxoMmR2c1VpK3VHT29LTlI3Z3JPV25IenlsVkpxdGJzQldQOGFGQ1YycE1OYlE2VzVUT0VFWmJQRDgrUkg5WVVKV2drSHhjSGVmazVPWFBILy9weFRGRlQzbDBLMWl1WmlnSWgvbkJKbHorTldTM2ZtRWpVRk1KL0RJeW9KZXYwdmdLOVR6STJ4cjhFT2ZuaWY0K09QUFdHVTVVa0JrTGQ3ZUhkb29waWhiaGpiRE00YThtaEg2QVZvSlROdGdxNHJMaXdzbUw4L1JVckphdGR3WVJnaGhlZkwwakZsdHNRYzk5T041eWJKWnAxRTlDWjljTDhuYUZwMFhHQ2M0SGlSczVUbWZ6UzJ6cktaMUVMaWFnYThKUTQvOVVZOUZiWG01V1BMczhTa25KMmM0NE01dWdxY0RQcDNPdVRJUlFrcGlWMkhyZ285TVE3OGJFd2VLckdxcDY0YlB6aVdJRUlIQTJwTElsM2k5OVE4aVZNM3R1L2VZL3ZRRFhpeFRtcW9tMUk1dUZQUFRqMCtvc3dYV0NtNGM3aEZHQVprVXVHSzlCTnJNWm14MVF6SVhVTFdHVDE4ZWM2c3BLY09FNWRQUHFBemN6MGZVY1pmWU5PejBRN3B4U05uWjVILzcvakh2SFhoRVdsSHJpTzNORHFuMWVPRWxHQVNybzJkRXRrU0ZBVHVqRVdWclNXN2NJT24xZWZiQkx6bVpWNXkwaHAzSW85T04xdzVlQVhuVzhQNm5jeElmdnY2b1R4MzVYTmFTZnJZZ0VvYkdlaGc4bmw0Vk1Kc1RBYkhub1pRa2lUdThmN0xraDU4K3BuR3d2eG15TzR6cGh6NWIzUllQd1VrS3MyVkdvaTJMUnEwWDJMU2x0cEpwTG5nOExaaVZOWk4waFJqZjNYR1Q0eG0waHNDMGpBVE0zTHBER01EejRmWld3a2ZIR1l2UHQyMS92cnFiSzZqazM3NU9zaXd0dlNoQVNFY1UrNlI1Z1VFaVZnMjR2K3NpVUVCM0VJQlF6QmRyazJjMGpLaXFOWWRJK1JMakJFa1FJWlNnRS9mNDJuLzBqM2p4NUFVLytMZC9BVVVCb1ErdWhWWWkvWFZ4OU43dUxyVnpXQ0hJMHd5UWJHOE9LYk9VaTZzVnpsazZjWWgxQmgwa2hKNkhjSllrRkRndjRXb3k0KzdkUFR3djRQaHNpckFTVTJWb1R4TjF1K1JsenRYVmpEQktFRkxRMnBiUVUwUmFNUnIwR0crTStPSlh2ODdMRnkvNDR6LzdTK1pQUGdabmliWjZFRVpnREFoQlVScWtsWGkrSk5BYTZYbFVWVUdrRlJ1Ykc1akdZSzFqdGx4UU5SVk4yWkIwRXB5MUpHRUhvWHhRQ211aHJISVFobzNSbUVoN0tPMWhsYVN0U3RDYVBLdHd6cEhsSzk1KzlKRHRHN2Y1d1YvL2hDckxlUFQ2US9UOVY3L0lzSDlDWGE1aFJhUGhKczM1SlNaZklxWGc0TTR0U2llSTQydmF4UUtCSStnaytMNUhyOXZGRTRyV2d2VWl4dFdLT0F5UlVsRTNOVzYyUW11WVRlWllhMmtydzYxYkIyenZieUdGUWtqRjhja3BRaGh3MEkyN3RMYmw0dXlTZzhORG5Hbnd0R1I3YzVmOTBRN2hIY2ZGMmV0VVpZRjJMVUVTMGUzRWJHMXRFOFlKYVpwakxHUjV2aTVNYm1yMlJrTmFVL1BxS3dibjRPWEZsTFJ1dUgvL0RxODh1RTJkWnhTVENhODhmSjJuSjJma3F3VkNTUGIyYnJJNUdPS0ZDUWhIN1NwNjNTRS8vc2tIaEtFbThEV3hyM244NUFsMVd2S1AvN04veE0zYk4vampQL3cyYjc3MUp2UHBnaCtZQm1jTmI3L3ppS2FwNkg2ZUFiQXFZRDZkY3VQbUhzT05IYVR5K1BhM3Y4UE4zUzIyTnplUXlnR0NqeDQvcFd3TWc2MXRuaDJkWTR1TWQ5NThoUy85Mmxlbzh5WFdDazduUzU0L2ZjekIxaGEzSDk2bjArdnh3eC84QkU5YS9DVGgvT1NTc3FpWVRhOTU1OTEzMmIxMWcxY2V2c0xrNm9xSHI5NUQvUGYvOEd2dVlyS2dNUzJIbzRSZXJIbDJ0V1FqcU5CUzhtQzBTOTQyUEZtc0dNVVJ2bGJFU1VKcEJCZTU0eXJOS2F6Z2FHT2YwYmpQcS9mdTBZa1Q5Z2REL3UyUGY4TFc1ZzdHbHJURzhQTDVCZk9yWTk1OS9RR1BQenVpcUVyU2l3dmk4WmhZclpPcm50YjBvdzV2MzlrbmYvb3BxN3pnYUpteTArOXlvK3Z6L3JOTHNxWUdVVE5wSkI5LzhwVGZlKzl0SHUzdDhHSmFvcE9RZVdzNXYxNnd5alBldUxYSFFUOWh0VnpTV3N0UExwZDg3N3JrTEV1WlBYbEs0RW4reDk5NW0yOCtQT0RibjV4eVBaOVRtWmF4cjdtN04rSThMZGFoRWxQaU9jbEhNNGNYQk9zVElRcFlsUVd0OUZnWkNEMlBlbjZOUzNwSW9kbnJoWmpXa0djWlc0bkNrd0dOZFp5WEZjSVloa2xFdDkvSDkzMisrK2tSdDdzaHQyS0JhVnNjanArZEx6aHZRMGEvL2hYKzJmLzB2d0kxdXpmMitDL2ZlSTJOZm9mQ0dISTh6czR2T1VnQ0hqdzZZSkRFL09nWHowalRPYjduVTVVTkxaYkFrOXpkNkxBc2FxUTBUTE1LclVQMFhneGgwMUpWRGQxMlJzK0Z2QjdueEw0RVoxaGVQU1pRUHE5N0ZtRUtiT000bjlZRVNsRmNGWnl2REN2aitQNVBQdUhXblFQczkvNDFtSVkzTmlOMnBLUzdmNWRpdFVBQXV4WGNzdzM2WjZmczVCWUUzTDYxU2ZiL01mVW1NYlprK1gzZWQ4NkpFK01kYzN5WmIzNVYxVlZkMVYwOW1FUFRKaW1CQUNtSWhFMWJnazFCME1JUXZCVmd5Q3Z2REFNZWRsNTVyWVVCYlNnYnRpREt0SnB0V3lETm9kWE5vYnU2NXZHOWwzUG1uV0tPTTNrUno1UnptVURleGMxN0krTDgvNy9mOSsxdU9NNG5wTU9hcGpHVWx6MC9lKytQU0tNSUdlRFlHcVk3UVpoUGVDbzhYam5PdHl1cWN1RFhIMDE0cWhwZUR6ZnNxbHRvSk43QjVXZlBDWVBuYm5kTHB3TmZlekNoaUNPbVIvdjg2bi8yai9rdi83di9udUxkYjhQZEpWMTV5K1o4NEVuc21FMDZXZy94MENFclIzUzdKWGFXdW11WnBwcDM1d3UyZllkU2dvTkNjRFZzT04vMm1Mc3R3Z2NXc3drekdtb1hjYWd5VWkzcFJjc2tTcm5ZM1VMd3ZKMU5HRFFJbmZEWml5OXd6dkVnU2pqU21zTkVNYzhTdkF2ODVNS1JhYzFyajE1L0plR0JpK2ZuSkU4WGFLWjBnNlhjN1VnanhUSXVzR2M5ZFNTWm1oM0I5ZVRHVWxjdG5ZZTl2U21UWWVBNHk3aXFSaHBhcGxxaVRIb21La0lua3NqVmJOZHJVcWtvWFVCNFI5blh6TFZnUDFYc1JJSW5rQXJMMUhYRWF1VGRLQjN4Ny96Y2R6Q2g0dVVIbitHczUxZmZmTWkrcndqTk9jWWJBcExUSXNOS09MdHVlUG5wR1kwUEhJaWV1cXFaMzV6emZtWHBIQ1MrNTltOUpTK2ZQOGNDMy8zNlUyUXg0ZUxpQXVzRGtZRERMR2RQZSs1MkRjUFFjMUVwcW5MTDBYekN0aDk0N2Q0ZWhzRCt3U0hYMVpvdkwxWjRxY2hQNTJSbkw5bGMzMUJXdHhTbXAzdjhBR3NsdUlGQ1NoSUN1bEMwM1lCT1kwU0ljVHBDcEFsQktZN25jMXdJOUcxTjZBUEhLbkN3TExBaEVLeGhQNHFZN3ltNi9nN3BCSHVUR1Y0b2pyV2dkUUhmcmloN3gxN2VFbG1ITlpiVmkzT2VmdVByNU9tTXpob0VnUWV6aEdGWDhiMWZlSmYvLzM3ZDREaWFhU1pPUWpUbDRxNGtKQW5DR25vSCswV0d4NUZMallvVHBqNHd5eFJleDdSYVl6SElFTGk5dlNYeUlrWkdpa3dMbWpybWRyZmw3ZE1KWGUvcGhhQjFLWkdBUjFuSzRDT005M3grVi9MR1BPSmtsbElrTVJjV3ByLzZIWDczOS85UDZuWWdHTXZkdGlab1I1VEVLQmtZbkVjWndXS1JNWDh3NDdHWDFGM1B4YzBkOTFQQlpENUQrd1pqQXRrdzBEWTliNzcraU1FN1pBVE85TlJTVWhpTGRZSHpzdVRrNFFFVFlZaFZSTlU1bnB3YzRZMmpVSUpzQWc3QnFtMFluT1J3c1VkdEhOWTYwZ2NuVEpkenlpOCtwcGF3M2pVTUxERkltbllZbWZ2TFBXem9tU2VDV0FyYTdKQ0w2L0VmdXRyZWp2M0hTWXIwSFlmN0UzWlZpL09lUWtpT1p3VytiNURKU0ZrSmJVbDZ2RTluTFlOeExQT1VpSnA3OXg5dy90VVZRaGowNFlMN2h6TkNKTWdSeEpFaVV4R25zNGlxYW1CMkNMdVNkS2FKcE9McDRvRE9PemJWR1Y4N21mTjRNY2YzTFQ1NHFzR3pqMlFpQSt0NVJtOE1tOHRMNm1wQ3RWb2hEMDVSTXRCYVMxU21Cemc5a3E1WDVRV3pKYlJDY1dkcm5BY2pCSmViRy9abm1pQkhvbFVTTE05dmFrNVBVNVpwVEdrQ0o2Y25kRzNIeXNrUkhCVXBpbFRqcGNRTkVaR1F6UGYzMlp2UGlIYzc3bUtGRUFuTEhONllaM2dFNi9VRnplQ1FXbkN5bklDRU5JclkxUjJMWmNKRWFUWlNZRVJnTDU4U3RpV3o2WXpMejg1eDNyQi9XRENaVHBFS1F1K0lsR0thejlrMHQvaGtKSHlYdzhBeEVxMFV6UGJRZnN3UnJIY2RXYTdSV1Q0eS9xM2tadHZ3YUpIamdWeEtsRktrVVU0UU1aMTFZRnZtaFViMmxreURSbEpWTmM5dmVnNW5LWHZ6UGJKRTA5WTlMMVpiN3E1ZVVydkFvemNlczUxcG11MHQ4MlJzVTllUm9uS0cyMVZMSEVla2lTTE5ORzA1Y0g3eEhJWU82TkJCTTlVS0VRMUVBUjRzY3BTejZHWkw0d01oQ0Z6ZE1kUWxsWWFyM2ZWb0tuT1c2NnNiM254MlNrM0VZQTB2YnpkRVVWTFFsaFZTQkdhSGgwZ3g0YjI3RnRzMGVHdDVNc3ZZcmgxZm50L3crb05UQ2gyUkxlWklhMm1UR1Era1k5TUtpa2xHSEtmc241N2dxaDAyQkd4d2VHdVpwUkhPTzB4ZnNsczNETVp4R2tsNjc4aWtvdTU2aE5KODdkNGhsZlVNTGtZb1N4YkhLQ21ZRkJOdXRtdnVuNXl3K2VvNVEyKzQ2Z2ZlUFYwd21KNlRoM3NRUEVrcU1JTWt3VkRrTWM0SDhEVjVKS21yTmFXRlpML2c5R0RKL25MQjdPZS9qYllHNHk1WkIwVXNCTGRPMDVxQUdnYWtpdm44NVJYT3dkdXZLWEkwUmFMNDdHSk5NM1NJZXNXand5VXY2NUs5NVI1NXJzbGRvQmtzNVNBb0FnZ3hlbjNhcXFkVGUzaEE1d3ZzK1RYWG9hY1NNY1o1T3BVU1hsSEx5bXFnckFKbE96WjltMTNONFd1dlVaVTdZbE9TVHpKZUdzRVFCRFVKQytVWjJvcTZIL25PcG1uUVFTQTg3Q1VKMXNFOGk5bWJKY1J4elBQTExZTnpKR2xNdEwyOWhqVERCZGkyTFJhSHNEMHhHVTRHVGsvdjAzdEdKdUJrRDU5cEh1dUVEeTkydE51S1I0dUUvVXp6OE1FaHhYVEtKei8rTXdTZXV5ZExUdElaWmhnb2hVY3BpUjlxQnFOd25XV1pwL2dzUVVsSFUvY3d0RVJhTTRzWUwzOWFrT2NSeHNQK1lzcHlmMEhWZWN6aUNERjQwbXJGWFZreTFaSmNaK3hsS1IvZVZQU21aNUxtZE5zeDVYeXlGSHc4OUFnemxrNkg5b3ltdThNRnc3dmZlb2RDQklxL3ZDWFRVSGtRenFFRlpFcndzdXc0VGhSYkU1aFBNemJkRGhFR0pybENKU2xQVHA5eVVScXV5NFluUi9Ca3BybE5DcllYSlcwZEVEY2xaVndUencrUXNlT05oekhDdzlscXk5WUdoRTd3OVJialBPUVpKQWtNSHRlTXFhZFpFYkhaVmhTeDVELzZuZCttNlRxZS8vU3ZXRXdkU0ZEV292c043dkFCOXJwSGlBN0V1TnpNc294ZDJ4T1pBZXNsKzRjTGJscUpFNUw5K1JTUEo1bkhSRFBac0NzM2dNU0xHRk51MlZ6ZjhjYitGQ2NrT3RWTThpVVhMdUhIOVp6TVp4eS84K3VZeWFjTVY1L2pkY1hRdzQvLzZtTkNrTEMzaitwYlZ0Y3I2aWlRSnpGcG5KUEVFdXFLczEzTHJJaloyZ2JyQWtVU28zTk5jSUxNQ0Z3SW1Mb2l5K2VjWDVYVXhwRWtCWjJFdm04NTlqVU95OHR0elh3Wjg2T1BudlB0ZDU3QllLbDJGVkdjWUZ4SEdrZG9HVmpFamozcGViOXNXSGVCQi9mM1dPNmRjbkwvUGovK3E1K2d1cFpmcnJjc2dtVTUxVWd2eVlTZzZRYW1VZURtcmhyVnVqcG5NRFVHeS8zYzAxdElZNFd4RFZJWW5PbnBPMEdTekpqT1BSN1B3YVFnalNRM3B1Y29sVmdsaVpURWJHdmlLTEJxRGUxbWgzRWVMUXZXNnkxSGlZSjRmTmE2S250RXBQbkxILzJZTGw0eWRBMDNaeS80WU5kd09wdVJKUWxIRDEvaEZRL3lBQUFnQUVsRVFWUm5WZGVVVWhQNkd1TTlTZkFzRTgvSFpZWGZiZGtHZUhZNngySFk3anlMTkVJRndmdm5KZEhOOWVlazA0Y0lJWkhsbXNSNTNuMzdLVWxYMGp0TE83U1l0aVFMbHVQRklUb1duUC80ajVBZXROQk1KMU9hVlBMdi9mcS96ei81cC8rY045NzZPdkhRY1dKZW9LM2h1clBzQmNra2laSFpoSGpTRVNMUFpsWFRXYzhuamVFZ1RUa29CSDBZNVZWeG1qUGtFNXlWRE4zQXkzTEh1dXg0ZVhITHNraVl4SkxISnpQcVp1QTc3ejRoamN3WU93dUIzV2JONTV1S2h3LzNXZVF4N08weG5VMTVTaUFxZTdJNDVpOSsrSmRzN3RhczF6VlIzN0N6aHQ0R3psY2JpdW1VTEI2NXZHYzNOZDk1OXBBaTAyUkRnL0l0WGRWamg1ckJDeklSU0lZZHAzc0pLczBvZyticTlvNnQ5ZGk2WWhnOHMwVFREb2FiZW9jb1JzcjR0ckU0cVFobzlIU2Y0RDNPQ2ZyV2NuUzBUMUNHWWZEbzdVdEtFWGo5clcvd3hYVUpRbUxRWE44MVBEcmNRMmNhRlhwRVA1RG1PV2VibG1FdzVINUFoNDdHRGF3YXk5b0pMbHJQVlZreWNZTEtaaWc4alE5RW45N1ZpUG9PS1JWTjIyQ3RZeVVEb3EydzFwTlVqbnBWWWhoSS9SbHhwTGd0eC9oeEVna092ZVM4OHp3dVM1eTFlTVpCaHJHZTNnYkt6bUpwdVJJZCtYeUdEWWJRV0hhdjlncWJ4dEFQZ2EwVm1CRGhmVUFyZ1hTS3B1Nnd6bkhUQzRhaDQ2cnBxWkdvRnZhOXBPb3R2UmFZZWtCNnFCdVBjSTdTQjNZdVVMVVdzV201R2dMcndZNGFPUjlvK2dHaEZHWndPT05aRzhkWjNWT2JIdGxJSXRXQ2MxeFdQZkc2bzJnc1o3WGxkdGNUQjRjMUR1TmhLeTBYZ3lWV0N0OFliZ2ZQdGhyb0F2Z2hZQWJIeHNGZ0xFM24wTW9qaldQYldZTHkxSjE0MWVRQmhTWFVIZk50Uys4VUlrQWRBcldRWSsrUGNvUmhDa0VYUEY5dU8zVGp1TFl4dTZwRHljQjVOYjVmZWJCWUN5c1RXSHVvUXVCMmNOejFEaXNDa1U5UXdOWjRvdC85NkphdUg0ODFKSzhrdkIrR2Yrc0xNSzlBUExFQzk5V1l6VmVTSkltWkwrZThIeDRRSnhtTG4vd0VsVVo4L043N0tOUHo1djZFN1dBNTM1WlU1UXVrR2xPdTcxMXNLVGMxM3JaNEFldTZZbkFHUGMvb2VrOElvTk9FM1hBNWh2TUpoR0RRaWFidFc4THRBRkl3bndaMHJMRHJucW8wZU8rWnhwcW9tSk12VDBpYU1TYm02NGI5YWNHWEwwZlV5NlBFOFd0ZHk5N2hrdFVmL3h1b2EzNi8yL0FualdXN3JhQjc5VjVNRlVXYThLOC91Q0ZJS0dZVEJpL1FzV0l3STY4L0tzR0huREFNUkxzV0lRWEJReFVVZTdNVC9NN2dFV3hXUFpOaWp1OENJVmpBZ1FsMEFZeXp5QkNZRnpHcUtma1R2V0IvZjUraGIxbUhDZTk4N1Z1c3E1WUlSNFNuczRIdmR6blJ5eDRoRGJPRnhaUFQ3SFpVVFVmd01Cakh3ZjZFczgyL3pRUjhmR2NRWVlaUWtqeE04QkkrM0paRXgwK2VqZHg0UE9ra3hqcFliM1pvclVjVWp3T1ZhcVFJWkZtR0F1YnpPWG1hYzNwOHpIZCs4UmVKbE9Sd3B2bk9XMThqRFpaaEdBaFBIdlBaeFJWKzBYRHY0UWs2U2RpcGhMWUxHSjJ3djF3UVJSRjdQdEFPQThmSGgzUmRRd2pnNDRSUFhyd2s5R09BWTdHY2NUeWZjM2w5aS9VZUNHUkp4blE1WjIvdmdLK2V2OFFQUGE4OXVvOHVVbzZQNzNOMWRZSHBlNG80NGQ2alkvNytvM2NKTHBER2xyZmVlb2Z0OVRYeklxVVRjUHpvaU9rOFpiSnJpWndoaEVDU3B3VGh4cVM5a0JTTEk3cCtiUFFTdlZKZjl5TjdzR3dhRUJKbkxiUGxIay9paUVta1dCd2RJYVhtOHhjdkNFUFB6Y3N6d1BQMXQ5N2dydTZRR0txeWhBQVA3NTlRbGh2MjdqMmdid2FDRS95RHYvYzcvTTNmL0R0ODhjV245RjJGRUlJbmh3Y2dGSG1lRUVVUitYVEcrY1UxYVF5WFYxZFlhMGpqakYxVDhteGJjM3QzaCtzTmFSeHo3MkNCSlNDa1FrakI0dmdwNGg5LzU3VlF0VFVoQkJaS2tDUUpuVFBNWnd1MDF0UnRnOHdTRmlGUTlqMU9DdTR0cC9UWklhSGRjYmFyNll6bnVCRGtHTTYzSlkzeGJPMTRqUG03cngrU0Z4R0RFMnk2VVFuajJvbzNIdTZ6eUJMTUVEaXZMTDd2eUxKeHlQSFZ0dUtmdlhmR243OHNNUkpPMzNyRy8vanZ2c21tMm5DMzNtQ05SU0I0dEJqVE9DOWUzckx0QjA3M0MrYlRHSS9reGJxazZUMzNGd1c1enRsMEE1MExYTXFJeUZnbU91Ykw2eXQ2NDNpOHpIaDZ2RWU1NnltU0dFSkFpSUJSRVpsMUdCY29wakZ0MzVOTHhhN3JHVUtnaUNNd2d0OS9jY2VmM3RRNEdmRkwvOEZ2Y2ZqQm4vTjN2clo4TlpsemZMb0x0RjNMSWszdzN2RndudklIWDl5U1NzR3pRckZNRlgwUVZFRlFWaTJzei9tcURYenY1OS9sUlN0NGViMWltaVljRlNtK2EvREdNWjltUkpHa0dod3ZydGNjRkpyOTJaeENhOHEydzB1Rml4S3F4dEFQbHYxRUlJUWtqaldaTTFRb2ZyQjhTblFzVmp4WWFJd0xIQmN4NjZHajcwWTBlbUVscWZDVTJ4WHBjc3B5UGhZWnpkRFJVK0dIbUtnWVgzQzl2dUpvSnRtVGtrd0s3dXFLazB4VHBKTExkVW5uSFNzUzdva0IwZmQ4OU1VTmFTUjVjakJoMXpnMjZ4dnV6UW9tY1VTejY0aTg0OGs4cFZjS2hPRGlxMDlKVmNjMCtKR1ZKbVBLM1MyRGN4em5HVWQ1UXBaS1pGZGpvNFNacVFuR0lsdEgrY3JtRll2QWd5aGhZdzNUeFBIYWt4bHRiOWl0YnBBYlI5cldPRHNqMFJIM0Z4bU9ubmFveG9KcXRNLzI2bzdsL294Rkl2RkJrRVFlNXgxZFBmRHU4UkZiNTNHOTVOT3FvMW5mb0p5anRvNjh0MVNySHVZRmswUnhlZGNReWkxLzhiTUxIdi9xR3h4T0p6eXZhK3o2bHFsT2VQcjZJKzUzamljcHVCYUtUSkpGQThvWWhCc0hSZk5Jb0tTZ0ZvRjRLcm00Vy9FNGk1aEp6U3lQMk5RdHhxNVlYOXhnbmVmZ3lTbWRzWlMxWW0rK1lCRHcycE5IUkRMTjJXeTM5RGF3UDUraWc2QVBJTlhJNEZkU2M3aFlzQjdjYU5jT2dTNVBhSUttS3Zhb3lsdWtEZnpjZzBPZTk0RVBydTZRQk41NDlCQjVjTXludGtNS2dWT1daQWpvU1V5blloYXh3cmpBVjd1T0lVNFJrME5zYkVaRGw0eTRONXN3ZS9BQUYya3U0eFRjUzE3ZVZVUnBpa09RaDRva1RWbVZIWStQVTFJZHNlazZUT3ZKWjU3V0RBek9FU2VDcnV2WmJMWTRIemg4N1lqVUNpNXVOMGpmRTBlS3A0K2U4dFhkQm9nNXpEV3hWSHgwc1dGV2FKWkppaENTTHAyUlRCczZHY2dTRFY3eWZOVXppVnIySnBKR3hhaFk4L0RoTVQvNDN5KzRPMWl5eUZKNkx4QVN2djcyWTN5ZUkwT2cvT29NRlV0KzVYdlB5Q2NwWkpwTnFZbWptS1A5Q1p0eXcyNElER1pHWkhxV2VZTHBPMElJS0FKQ1NLNXZiaEFDRHZiMlVBUWVIdS9SZGgxTjI2SHpqQ1lJeEFBUDd4L1FPMGpqbURSWHJOYUNJQlErS0k2UDdoRUZHVU14UnpoUGF3SzUwdHo2RHRrRmpBZ2txV0kxZUxvQW05VU9Kd1N4WG5BNDhVeWpEaWV2c0JxNi9XK3orZXd6VHBaek9qdncrYzJHSjQrK3laZDF6VExzQ0NhUXlaNWFwa3h5d2RtMndnYzRXaXhweXg2aWhFNm1PQ0hZbUk0SGgzUHVwbk44bkhBN09ENjdiZGd2Q3M1V0pkWUh2bjcvSHN1bElLUVJuVkFFQkZFU2tlWXhyZTh3T3NKTFNlc0R2UnVZekF0NkYzQXlJWm9uN0txT0IvTjlra2hpcENiUm1nZDdHVFpmSUlBOW9mRkJzUFBqWlR5K3ZjTXBoVzBISW1HWWFFVS9qUWsrUjhXS3h3ZEwxcjFqUHBuUXB3VW1DRVF3NkRCR3lSTlRjM014RG4yK1d1OTRtRWM0T2VZT2UrKzRQMHN3Y1lZUkVjK3ZPMnJuZUhSVWo3emZjbzJVQ2lVRTAra0U3d2VtK1pJUVlBaXd5R09zaEpLRUFDalg0NjFnVmt3Z0dJSncxRjNETWsvSWcwVW1VMUtWNHFjem90TU1QalF4eGxzKyt2dzUzMzNuR2I3UmhFU0FGRFJxSkdNUFRjTjBsaEY4UVBzR1pSSk9sa2UweTI4UXZPZDJmVU9XUkpSS0VzVXgzOTVMeVpwenBnNCtaMHBRbmpkbUhtOHFmSlF3bVdnSW52V201TEx1bWN3bTdNdVVTU0xKNG9nNDBaUnhRamFaSVc0M1ZEYXdueW1POTZZWUg3alpyTkhSaEVSQkxDVlRwV2hWVE5QMEVHa1d4WXpDQm5wam1NMFdCRE9RQkJCU3M5aTd4Mkhaa3NjYVJlQ2ppeHVHN1pyRDVENVdCZ1lnbFFFbU9kYzNBNE1MekEvbmRKc1ZiZHN6bmMzeGFjSXNVZHpjOVJ3S1I3ZGJrNlE1Yjc3ekRwTnBqaUNReGhsZVdlck9rS2NSTWppaTRNRVpQbjE1dzl2dmZKMjI2M0I5UUNRcGl6eWxqVEx1UHoybUhSejlFS2g3ZzQ0MGk2SWdqeVJWV3hNcGlSWVJVa2txSjloVlcrYUxCWWRhNGtMQVdrWFZEeVJaeXJhcU1jNUJFR3pNaU5LTmhhVWNLajUrL3dPaXdZOEM0MGpEd2NNVFVxMVo1Sk5YL2p5NHF5cTZka0NoVUZJaVJHQ2lZTGU2WlZ0VzNIdjBPdE5zUXB3RURvSm1VdGQwRG1wOWpKdnVvVVRnOGR4amhvSDE1b3BVTCtudVhySS9UOUZha3N5aDhvS3U2cEFuKzB5bkdkRlZRK2NsZit0My9oN1o0VDMrMVgvOTMzSlpEVHlicFJTRkluakgyYnBCeVFsZlhON3h4c01IQkIzaDNJQ1Ria1N6QjBud2tLUXh0K3N0RHc3MnhnV1FGUHowcDM5QkVVYzBuU09PQkowUjNOVURmWkxTOXcwaWVLdzMyRkxpVEVOdkhDK2VmODUxMmZIc2FJL3J3WE5yQnFxeTU3VkZ3ZjVjRWc2ZnNuT0JIM3ovKzZBVWtSWTBnNlV4SHVNR2RvMmtLRVp4ODdMc3VUZUppWWFHeVh4T29SVkNCbXpic3hRTlRtaWlSTkpiaDQ4U2JMVkZUelB5VERNNFJkdDJJeXBmQ3JSVVJOSnpmclhCbFMxQ3dyT0hleXdUUjNuMWtrWWwyQ0NZYXNYaE5PZHMxK0g4UUpxa2ZPczczeUtLWk16VHd3eUFZUmhZOTZQcE12Z3g1V3FWQXVGSXBNQnRxOUY0NGFEMWlrUkF2MjJJT29jVWlzbkJNWTdMa2JwaGJsa1lpSm9ObDlzT0VUeUozVEdMVXc2WEdTcEloSWNpalhqcFduQ0d1dHl5TWpXRDdSajBsRTkrOGpNV0I3ZVliaUNQRlUxZE00M0dCZEdqVi9lMm8wV0JzVDFWTzlBUGhqWUlyRy9ROVFCZTRQMkNaUklqWFVrc0ZZTTZJczlUbEdzNW5LY29MWWl5akp0VThjV25IL1BHNDFPbXFhYnZQVDRUOUgxRUpNQUx5U1FTeEFSMjJ4MGd5Q0pOSWpWcEZDaUhoanlaY0hod2hLdEtFajFGaXJFVFA1aEFGSG04V1FQdzFsSEVKMWVHTDc2NGhvT0JSUm9SWjRKeXFEamFXNUpsT1lnSTE5Yllyc2I2Rm1zMGZlZXdwa01vc00xdUhOTUlpWFllTFNMMlhsMmg2Vm9hYTRsVXhLRWVWVGxSbXFNaVJkYzNxTVdVYWhnd3F3M1JiV1BIN1ptV0dOT2pwR01JRWI2cFFRcWlvU2ZYbWszYk1jOHlyUE1Vc1VBNlE5dXNxY05BS3lORU1tZWFLVnpiSVYyUDNaMnpXNTB4S1RSeDF4RVFIRXluRExZYkoya2srQkRRV25HWWFLWXpSZXc2UWlmQkJTSlpjM2QyUWJQcnlMS1lwQllRS1NhSlJrdUJUQ2VjMzIwSndHNnpRMHVCanhRdk55MEpoamNQRnl4U1RaelB1Vnh0U0tWRUIwdXp1Z0RUa0VlQ3E4c3JaSUNEZ3lVVEhhR3lCQjBzbVpRTWJzQzNEdVVIRktPb3llUDRaRlZpMmtCdkhjZXlJN0ZIck9zQk04UWM3UXRlMWh1czZlbjduT2xNRTh1WXFPOHA2NWJtNmh3djROdHZQa0FKeHp3eExMS2VSV29KTW1lSUUrNnVMdG5ZRVJLMXpESlMwWk1uZXRUeStvR2hiaGtJaEdIQWVjRTBGaFJKakRHR09GV3ZiQ3FTaFI2ZER0dmRsdDRKWmxHRTd5UlM1MmpYa1lTSUVrZjB4MStzZVhLVUVtdllOQTNUSkNaUFk2YVJSZ2JZT01tMjJtS2M0L09YNHd6ODhlR2NSWkZROWdOOTVlbWNCN1VtT1grQmN3WXBvTkNndEdSM1d6S1lnQW1CZFRzK1VDMlNtTjQxK0NBd054bFo3Rmk1aUdBN1FGQjVSNjRFcWx1allvK1NncXZPazhXSzlxN0Z1c0RSTkhEVHd0QzNIQlFUOGtoUk5UV2JjdURtcW1HM3JaRlNFZWNyZXErUVVUUk9NWU1oa3lDbW1paGVZQU9zR3Job09nd3gzZG9SN3pwdU4xdm1oOGNZTTNJRkpsTGhwR1hYYlBuNC9WdUNnTy85NW5jNFg2LzV2UisrNUxkKzR3a245NDc0NTUrK0lNa0tCdURhSjNqaDJScFlOd05QN3QyanQ1N2IzclBwSk1tc29CR1N0Zy8wN1E2bkpONHBybllqUFByanN4dXlXVXdlUnhTdFppK0xjV0g4NHV6OEtHUTljZ01wQlovdFNzUnFoL0dlbzFtS3psSzhNMmlWZ0JLVXJ5RFlRbWxrT2lkeW8wTWwrbjU2aENoYkVCREVFdDlhbHJNcFdaWWpoYUx6aGxVelVzTzN4QVE4eDM1QjRqVEdPZGFyTmRaYWxQUXNGM01jQ29JZ2RnbUVHRGVrZEwwZDRkNmxZeENTdlZsQkVpYzRBblhYay9iNjFiMjZoK0RKODV3czFyeVRMWmhORDdqcXYrQm5ma0xhYUpyckZTTEF5VWxCMHp1cXRlSDRjQlF3NzJySklBcjB3eFRYZHdnQnJoVjREK1ZtaXcrQllwSXpUU0lLVVRDZlRzbnltRFlJS3JlbXJGdGlIU0drUUVZbnJEK3JjRzVBZUZqa1U1S1RFejRyRzdJM0hpRUQvQTgzbm90VllQTFdHL3h3ZnAvYmc5ZDRmQ2o1NnZJci9rbnY4R1pNQk5WV01BU0R1MjZSU2hCMU9idXFvOGdVYm1zUUlpS2Z6VWZyaVl3eHN3aENvRlE3MXR0YityYmh6ZGNPaUVYTWVyZmgrUFFobTc3Q0JZY1lQQWZ6ZTd3UWw3VGRodUE5eDhVY2FzbHVWektiRjRqZ3liMGk3VE95TEdGdWpzaUtHZDJuejRuK3hxLzhNdGwwT29xU2dzRU9BN0ZPZU8yMUJ4UjV4czF1eS9uWkZhYnB1YjdlTUhRMVJaRVJKeExuSFo5OGRZbHhEbThhSGg3dXN6ZWZqMWoyK1p5NmEvSE9zYjljb3FLSTlicGlNRDBIaXhtTkR6anZ5ZE9VS0FnZVBIekFwcTRaMmc3bEkxNS84eGsvOS9PL1JKcm5wSEhDOXU2VzVkNEI4ZitIc1plQzY5V1cxV3JOZEpxUVpnbmVTYTR1TG5uNzYyK0IwbmpuOFNKd2M3UGlvNCsrb0dzYk50YzM1S2VIZlBUeFo3eTdmMFJ4Y01EWEZnZTA1WTVtTUN5WCt6aGplZnJrUG4vMG83L2svT0lDM3hzbWFjUzMzbm1ITng0L1JrdE5uTVJNNTFNU3JVbjFoR3cySnl0eWd1azQrYnYvTWVYZGpzT1RBN1JPMkc0MlRHYWFPSnZoVWJ6MzN2dGN2SGpPejMvN0d4eWUzaWNFd1hwMXg5T0hweFI3SjJ4M2QxampPVDlmODhNLy9iODR1MW1UVFNha2s1eWlhdmlidi9JTDNEODVCU0haN0hic3lpMU4wL0dUbjczUDBBL01weG5USXVONDc0aTd6UlpqQng0K3ZJL3RXOTc2eGplNS8raHRFSklQUC93WThkLzgycmZEYlZuUnU0Q1NjRFRMNlBvQkpRMUtDc29lZFBEZ3gxaVhCWjRjVGNIMkNCWHpnL1IxYXEvNC9PS1N2eEh1K0ZwcW1Xako4Y0dFcHU5cGpFRkY0NkJtM1ZoNjF6SXZNc3Fxb3JkajZxZFdLVXNaMkhTV3puZzJ2YU1WMEE2ZWVSWlRkeDFIc3hrbjh3bWRoRmdydW03ZzhuYU42dzN6SkNFU0FxOENpMVN6TEZLK1dyY1lFMGdtT1FmRmpIOXpWdElPTFhOaDZYL2wxL25kMy9zRHZ2ZUw3ekxYZ3I5VnZvRDFpajVKK2ZLeno5bVp3Ry85L05kWkdjY24xMXZhd1hLc1BWODdYdExaQVpIUGtFRlFybThnVDZqVmJDek5CRTh5V0p5TU9OdldDR1B3SVNDRTV0bnhrc3VxUVVwQlAxaWk0SG15bUhEWk52U0RaZGNNS0J5VDZZS3VLWkVoMEE2QnAvY1B1UGNQL2d2KzVaLytpTDdhTWZ6Zi95dmZmckRIZnByaXZLZHNHcGFaNHNIcElSKy91S0VkeklqMlN4UW4rd3Z3am1vd0xLWUYyODVnQWx4c090SW9JbElReVc1SEVTeVpHR05RODhFd2xRSmxSemFBOXgwVHBaa2VMZWc2UTI4dHZyeG0xUTdvT09PdFp3ZFF6Tmo2bnZjKytZSkh0S1JPY0hlNVFtVnpibGMzTE9JSW9RVENheWF4cDE5dktYQVVBaElobUVhYU9IaDAxR0ZVSUFFU0ZiQ3hSSWdCbTNVY0s4LzVpeGZNWnpOaXJaR0Q1WUhvVUxuRitCR1NmSlFrU0NtNFdkMkJBeTBDYVdPNU40bDVsblpzTVFRcCtPM2YvZy81aXcrLzRzLysrR2RvMjdLZjMvR2RRNDJ0Qm81eVN6b0VYbnowVTU0ODNxZDJGYVVQRkRxbmIyN0o0eGhuQTRMQU1oUEVzbVBiRHJqVkxVSEM1UEFCVGIzalVSVFlkZDM0MEN3a1IxM1BRYXh4UUNNVTFmYVd4MXFUT1UrdkFsdmJNWTBpanVLYXV1OXdQbEJQQk5lYkRiL3grZ1ArNSsvL0h0Vm16ZmJ1bG5UdVdCSVJrT1Rhc3g5bDdKczE5eEtEVVlHdEN3emJhNXpxR0lZQkZ5Ung1SGhjWk96S2xuc0xpUXVHUWlkRUtnU2tqcEJBR212Q1pJSnN0MlNMZ2xqQmVndHQxeEdWS3k0YWkvVmdOTFRXb1dSUGYzbko0aEJlZS9xSWo5WVgrT0ZMRWdXYnBtYTFhb21sWUJBN3BJY29tK0I5VEYxM25CN3VFVVVTWnozTjBETUlSV3NraElEeWdqd1ZWQUk2RjE0QkRxYk14Vmg1NnZ4QTB3VjBKQ0NhNHRxQnpucXU2anVXOHlYQ2FnNTFqL2R3dGRteXloV242Y0NCRm54V1JXQWJUazhXYVAwTU9SZysvOGtQZURLYmM1Sm5yTEJNbzBDV1JUajNhcnFvQXNGMkNGMmc0b1Nic3NOWXowR21xUTNzdXBMajVRRlN3V1N1dVIwTWczZTB2c2RhVCtjdDFtdmswQktKZ0JJWlI1TUNGOVRJU1I0Y1p1Z2duWEZqTEE4V1V5U0JtMzZnOUpJUDMvOFpMNzQ0bzIwYlpHZUpGQ3p6REFlSVlTQUl3N2FxRVlOQmVoQ21ZNzdJS2ZLY1hBVUc0N0R0Ym9SOEswRzUzV0pDSURtWUV0bDB3a1JIbzR1dktSbjZsaWdFcEhCRVFyTi9mSityNjJ1RWExSGVZWVBrTmpwZ0drcU05NXdjTEZrZUxQbXdiTGw0ZVUwMzc3RlJ4R0FNMSt1T1dhWTVtRTFRV3VKRVNta1ZjYWE0YlZaSUlLZ3BVaWRvMnlLRkJpSElNMGxjVE5qZGxXT01PbzJJbzRDTU5KaVIwWGU0ak9pN2ppQUd2cW9yakhXYzVnVU9TWm81T3BlTmF0a1p2UGQ4eGJzUENtWmFVbHZIaS9OenZ2MmRiL0xqUDMrUGVyUG1xMjNQeGJ6aXdYVEM4YnhBU0hDOUo0b21MT2N4a3dCZFU2TkV3aEJBTWk2b2xJTFdXand4bWNwSlk4MnFiT2k2a3FBME9wRklKZGhQVS9xNlpqYUowVklpbkVQb25GVjVDMDRRUjRHOVJCTmgyVTh5MWwxUElJQUlhR0Y1c3RoamIvK1V2bTNSMHhTcG9MY1dFOEFaTy9vY3BSdTV3QzdRZFIyVE5HRm5XK1pGUVM2aGlGT0NoN29yMFdKMFB5c3BpV29mTThFaGd5ZEVHVkkyOUVHL1NwNDQzTkNSN0QvQTdpNDRqQjBFajVBZDZ5R1FhY24reGZ1Y21FdmFZYzRrRjdnUTBUbUowcHFUbzVRazFnUVZZNFZrTXdpMGJZZ1RDTVFFRkpWYVFyTm1YaVJNaEVFZ0tFUE1ldGRBR0VBRzZySmhyU084RzBpU01iUHdZdE9pbGVKWmtmUFdZWUlGK3NGU3R6WDdoM3ZZM21PY1p5STgrVUxpdktEdVBhWHg3TG9PRlNWOCtNR0gxTnNhMlZrY2xwdWJrc09UZ2pTSnFXekhUZGN4U1JWYUNkTFpuTDd2UjAreDZjRUhlaE5odktVMVBXVXZFV2p5U1BMU0NTWks4R2c2SWRHUzBoamFjaUFOaGx3SkloMXpWaldra2FTWXhvamdhZnVXRkVtUkN0SkVNL2pBNWFaamF4eFZ1ZVB1NW9LNnJwajNQY0ZNNkxvV0p3U3phWUVLQ3MrNDB4QXk4T1JKUWQwTlRIekF5L0VVMURtTDg0Rkpxa0ZISkNJUWhDYWE1aEhsZG91emx2MHNJVXNVZUV2ZGpqWk9uU1hFL1IxM2JVdVdKVVNSb2hnOFZkdlRSNHAwOFJpemY4VGNha3lVc0hNTzJSZ09Na2tld0wyaWpuZ2JLRXZITEZWbzZSaWN3Z2RRelIzekxLRWRlcEpjamNmUjBqSllSK0Y3c2hDSTh3a3VCUENlczl2Tks2KzV3TlE5ZlJaemI1cWpWT0RqeXgxSk5NYktURmZTMnpGRnM1L2xsRjFEWThIWWhDY1BIdkNIUC80WnNVeUpDc25wdlRsRkpEazZtcUcxSnpBZ0pIUURKSkViT1plUnhqcFBWVFhFY1VHaUJOTU1WdGNWUXg5UWswQ1FIaThGdHV2NStNVUYzMzNyRVltTzZGdURpeFF1Q0ZvcjZZdVUxZTRLbVNia1RoRUpPRjRVeE43VHRUdHVPNDBQc0xXQnVuVlUyeFZaa28yNldoR1JhTVgrUkZFUGdkWGRsb1BaakNUV21NR01JczQ0TVBpQWpsTUdOL0lYWXpVS3VMcWhJVWt6ckRXc0xzK0pPbTh3VHVDTVltZDNoSkRnck9OZ1BpR0xJNFRNR2RyMVdKZnFLelNTTkowalpJc01FVzNiMDNZRFR4NC80My9iN1hqcEt0WlNrS1V6NWxsTVpUVlYxUkNBeVRSbEVRMnM2b0hLV0h3WTAyWUt5M0l5WWVqTXFLaVBCcXhybVdRU3hVakhySGNyN25wUGtVWUlBa0ttb09IczlwYStUWmhveWY1a1RxdzBRaG9HRmFQd3hOTFJpQWdWT2ZDQnpneDg5NXRmNTUvK0wvK0NqOTkvSDRhV3ZkeWcwWGdQVFRlQUVFaXZ5T01CYVNVQlFkVVBGRm1HQ0E0VmVhU0FYZWNSU25FOGozRFdVRnBMVk13WW9vU1RCMGVVcmNFWXg1Nk9DTUZUbGcwbVNJUk4ySGFPdXR6eC9MTXY2UVg4N1hjV1BEcVlNWjNOMk5NUk5uamNiZ2Z6Q1crODlqVUcrMzlRVmhYdHJxRTJNMjRxdytBRWkvbVNycThZZkU5ZXBDTVNCczBrU1NpN25xN3ZzUzVnWTBXUloremxDYXZ0RHVNQzg3MTlwQWppcjVHdVFrQVNpZEUyNnp6ZUJRVCtyenRwSW96eEtQZnFjaUlJSUFQV09uUVNJUkJFQVp5RDNvNStBQ1VGUW9peHJoMDg0YThkZU9QdlZSQ2p2REY0UWhENEVBZ0JKSjRnd0FPRGRRZ0owa040aFpXMTFoR3JpSmlScyt0c3dNc1JKMnZ0aUVjZGY4YjduWEdqYk5uNlFOdVBtSGhlbVZESEw0ZEFpbEZENzhNWTFCU0F0WUhCK0pGYzRod2llQ0l4Zm5CREFDa2tPbEtvY1hsSzhCNGhBbmtjSWYwWVRPMnNKYno2RytIQmUwOW5MZFo2ZkFkZEI1dmVZeEZFS2lLU0VpVUZMa2lzaDBpT0lDb3BGYS9DYU9PZVFValNhRVQ2R3crREcvRTlTb3lkVGVmQnVvRHhIcHpEQjR0MWJvemVPNC96a2loekhWNE8yTmh6T0oyUnhSSG42MXVVYTFnTHljT2pleGdzblZka3hiaUsvWEo5eDJDQklFbWt4dnVBaUF4UG5qNUVmbmFITlFPN1hjMUprUkM4UlNZamJmT2lMQkVxcFVoU3dpdjlYOW4wdEwxbjZFdlNkUHo4WmxsR0ZrazJ6ZWpRM1pRcjNqamVweEFWMVhZZ0JNaWpIWXY3OS9pcVMvRjZISGNhTTlCMk5UdGptQ1FKaVFDTG9OcDFPQXhERU9RcTVmZS8vNGRZTkErZlBVTTZ3L1Q2cjBBb3F0WVNwRWNLU1RBTm5kSGN0UTdyWVpKcW5LaEpzNVN5cVJBaHNKZWx6Qk1vVFF0U1lRSTB1eTJ2RjVLNnE5bGNiekErVUJ3VUxHWUxLdUVKd28zcjRCY3J2dHhDQmpnSlpUVGpSazA0aXFlMGZjUGdKVTIweENEWW5yM2d0V2R2c0sxYW5uLzRRd0tDSXN1SkhlVFNZNU9VTDY0clRPWHB2ZWU3eHdMdkFwZTducm9mY0NGd1BFbm8ycHJ6enFHSWFhMERvVkZ2NU9LL2FqdEhaeXhYVmN2TGRVMGZMTmZYVzI0MkxZTVVYTzFhZEJ4enNRMXNXOGVucXgzblZ6dVVUaGs2UjFPVi9OVzI1SU9QdjZSZlg3UHRMTUtORU9OYTVBZ2xpSk9FM2l2YTN0Q2dpV1NFZFpKUDd6cTJ2V1FJZ3E3cldMZU94aWsydzhENXRtUGREbnowb3VabXQ4VVBodG9KV3VzWmtKUVdidG9CRTArcFJFUlhOMVFFMmhEVGVHZ0NySnVleGhyU0pDZUpFMndVODJuZjhaLzh3My9JRC83Z0IrektrdFhaUzA0bTBhaktHU3l0c1hRdTBJaUVUVytwYmVEOGJrV2pNcXEybytvR2V1TTV1MnRwQkpSVzhLSUszSFNCYXJDWW9XWFY5bVR4T0VMWGNjYmdBMTVDaUJSV0pHeGNRQXZEaDEzZ0xzQlYyL0dUMnhiclBMVkxhWnhtMTBxcXV1WWN6WHZYZHpSZFRmZmlFL0orNE11cmlzOXZXMW9sT0tzc24xeVgvUEFudDN4NlViSS9uMUM1MFloNnRqWmNWNDd6MGxEdUdsN1dqai84NlMwZm5GZklKQ0g2bjNhS2c3MERoRkpzbWdwRllKWVZKRTllUjBqNDEzVkxIeXlaaVRsOTlwaEE0TDM2QXpnSzNCd3NlT2NiYjdKL3ZFOXp0dVBSc3pmNTZXNUhMM3MrRW9KMHA3RHJodE5IcHlpdjJUVmJ2RE5JbmROdVJnSjRMd1gxdXVaZ1dWQjM0M0Ywd1lUR1pXeXJtdUFEOGY0U1JXQXZVVXhuNDY3aDdLNGxxVlA2SVVJWmcxU0NTVDduY1ArSWp6LzVEQjNGSUFWdDFhSVZmUFBlQTVUU3BObVV4V3dmS3d5bng4ZGtTYzZIbDJmOFVYN01xaXlSd1NKMXhQMTdSMXpkbFRpVEVoQ0liQXAxL1lVQUFDQUFTVVJCVkIrek05UlZ6ZXRQbmhBcGhkRVNnNkhlMUxSMkJGMUwzM0Y2OUlSNnFCaUdIcWtpY3A5U3IydWtqSkZTTXBuTnFROE8yZW1hVFZ5T3EvQjdSNFQ1aEgrMjJUTFRLVkZRNkRUaTlQVTMrY3JDWGIxbXFGdldCdy81bDI0RVlVc1JtSFlGY1pMd3djNHdmM2FJRW9IZlZRc0VFKzVVaVNsR01VZUt3eUhabGkzdFpMeGZmVlJKeE4vL1IvOG8rTFliNTlHN2lzSHVxS3VhWC92bFgrTGU4UkZmWHErdzF2RHR0NzdKeTlzN25QY0VaN2s2TzZlcEs5NTUrMjN1UHpqaFQvL2svMkY5OWpsdE85NmZxNnJsOE9TWTI1dExIajU5ekdRNm9lbzllWUJZQy9iM0ZrZ2wrZXlUejJnYzVOTUp1N2JEOUpiVGt3T0dFSWlrWnJDR0R6NzlqSjk5L2dXdjNWdnk5R1JCWG1SME51SHFkazFYZDl5L2Z3K1ZhTmJySFVVU2MzUjZTcEZQOGQ1eitkVW43TzUyN0IvTm1FMG4vTkt2L0FZZmYvVUZ2L0NOdDNqLy9TKzRXNjM1VjkvL0FmZVBGcVI1VGw3azZEaWhxaHAyZDFkTWlkQkNNdGdPbmM2NGR6UmoyNC9sa0ljbmh5eWVQT0xQL3VSSDlOYlF0aTB2TjF0dTExdSs5YlhIdlAzMkcwd1hVNzc2L0J6dkRjdkpCQlZGWk10REZwTVpzenpuNW03RGJyM2kyWnRQdUwzYmN2SHlITlRZTzJnMkczNzliLzhtMTNkclB2emdBMHpmY1hwOHlITC9rQi85NkVlMFZVa3h5WGo5eVJQT2IrNVliN1lqYk9MMGdKUERQUzVYTmF2YmE2d3hmTzk3MzZYcEJuYWJrdFhkSGM0NWZ2enBHZUkvZi9ja2RNMHdUZ0p6aGJVZTdRM0ZOR2VpSlcyVWN0MzI1Sk1sUjVPTU5GSWswdlBwelpyZzRIU3ErTWE5Q1YyV0Vhb3RMM2M5eGdWTVUzT1lKWHgrdGFNeGhzSEJKOWMxMWdvTzA0alRaYzVocmloeVJSeU5aL3M4SGJ1Qjh6VEN5b3lCZ0l4ejNydjNDL3lMbjMxQy9zbWY4NSsrT2VlWDdzKzRIQkordHVreFppRFpmOG9rejJtN2dkTkNjVmV0K05PLy9KVGVXaDRkRlR6ZHkzanplSTZNRk16bS9NWFptcWVMQ2NKWi90K2kzcVJIcyt5KzAzdk9jT2Y3ampGSFJvNlZ4UnBZUmRHaUpMWkV0SzFHTDlvdzRKVVhiY0NBWWUvOElmcERkTU9MM2hndzRKMjk4Y0t3WkxRdENHMjAyRlNMbEVTeFNGYXhLaXN6S3pOamZxZjczdm5jYzA0dmJzTGV4UzRRRVRmT2UvLy84L3llbjFMdzg1czFZVlh6YkRFRFB5TG5MM2N0WGdqbWZpQUxOZHQ5aVRTRzdPaUFuNzdlc1dsNlRyWGpuMzF5ekJmWE8wNWNRNk16dXYvMlgvQ3YvdVcvNXZkdi80RS8vdUduUEpoUHVGM3RVTjd5WURsQklGaHB5YnZySFlrSWtGcGdoZURoazNQVzJ4WnRETFdQeHR2QXJ1TDVwejlFT2ZDVFVSTFZYNzFsM3hrdXYvdWEzZzQ4T1V3NEN5MzNQbVMxTFZsVlBSZkp3TWtzWjk4NXNqQ2d0WTU1UHVPTE43ZHNOd1UvK3VCRDh0bUVmMTFuNkVYZ0NPYmpUSTZRVkczRGZCNXdrRW9DSWRqVmEzSWxXQVNheWZ2eEo0MWptbGp3NWV0M0hNMGZvTnVPcU84eGNjWkVHam83RUVTUVM4dmhWTFBhOUNRZVBweEhETmFRS01Pbko0SlVDMEtsUVhwdWk0clZQc1lCRTY5QmxLUmFVZlNlNThjSG5GemVzbklEbTIzTk1OVWdGS2V6QlZjZHhFT0YzKzVndDBlZW5DSWRQSGw0UW05NkpuYUQyUlRjS2tFWUtKS3U1MXdKdXF1M0hKOHNTVlRBSTYyNEh4eXpWRkxZZ05aNmNBYXpLN2g0ZnM3NU5PWHJUVFN1WWdVVXZhWHFERyt1YmtnL1hUQ0w0Ykdhc1BJUnQxM0Z0bGh6c0l6eG0ydDIrMnUrZlgzREh6OC9ZZEoxQkVwaXlwNzcrelZSR1BQOHlRS0hwSHYzTlFtYXhYUU9rMFB3a3F1Tm90NXVHYnFPdk5ia2VZd05ZZGJzT1RxSTZKMWlWOWM0TGZoZ2tmSGk2dzFWMjZPUFEwNkNHRmZWU0pXU0NZbXU3bGlvbmppVEpMSmhxaUorOU5tUDBQTlpScWcwM284dktNdDVUQm9KZ2lBbVZCS1hKeVNCSnJTRzk0a28xbFhGTEFuNG8rODlJb3dqU2dGOTI2SmF6NzVxNkwwbDFRbVJFc3dEei93b3dub292YUJ2YW9KSUU5Q3hiUWQrY0xIZzNrSmlCWDRZeDhGMTF4SnE2S3Vhblcrb1g3NWl0eXNnaUFobWMvS1RVMTZ2UE9IUll4NzJOZXYxbnNaRGZINEVybUNhWm9UVUdLdWhQOERldjZhOCtSWW5KY24wRUNzRmt5aW5yUnBrWkpocXcvd29RNmNKL2UwYVl3ZXVWaVgwTFhkN3h5TFZIQjNQNmN5TVZ6Y0ZoOHVNeVRUaTJlTXBRNUxqOWoxTkhsSFprREROT1Znc0VOMlcybHFVbER3NG00SzE2RWdSdmw4TUhaNGZvTFZtdDlrUllMRlJRbFAybk9ZS1VROUlCUXVuMkx5N3BRY091eGhkS2FMRzhQYitsdE41VGhKcEJpZDU4V2JGajJZenBwbkdDY3ZycXcyUHpoYmNsNFpoc3dJaGVmYm9qUFBqS2E5dTEzaG51TjRYUkRwRUIwcmo5Qmo5T3BsbTlJMGk5QjNUeVFsYUM0Yk5GVU5iTUprczJUcE5hd3o5dnVCa2VrQnJGYTl1eDhMRUo4dVV3Mm5NWVpyUldZdlpGd3hkUitzVjgxU2pKSnlGSVNKYzhKdGR3emYvOEZzS0N4ODlQTVE3VDVJRTlPaHhSdDdYUkpFaUNRTjZwMWcxRmJ1NlFRbEJHd1NFeXltcXRzaGlUUGE2cG1Bd2xuejJrTEpXeUhLSHFmWU13MENlcGRqanh3alQwRmxIWnhWcEhPRnRSOVVZQmlOeE5pS01OT1c2SVlrbkpNNXhjZXlwVnc0ZEI5eDJQZXU3a3ZQakE1NDlmc0RVdjZBejBFdkZUZEdoZGNocVk2aVVKb2dERmtjTDFOVnJscEVnRGp3cVNvZ0NSUzhVVWlrbWt3bkNHTFNFNmZ3VUlXSGZHZzdtTVoxUUNPdVFEcVEyTFBNQkx6VyszMUwyRUNBNFdLUzBkVWZYR01RazU5RXB5SzRuQ2hOeUh6Q2ZwN1I3UTZRa3ZoM3ZERzYyRlk4Zm5KRk41a2dOWG1sT0hwMmc1N0ZtRW1lQUlFNGlydHNHSlFNNktvUlRCSUZpbWgrUkJCSDNyOTVTRDVhNjhSd2xOYUdRaUw3R1drZlJhVTZTQ0c3djBkYXk5N0RWTVpNb3h2ZDdsSGJzRVN5MHBxOTZMcDZjMFJoUDcwSlVCTE5KVExuYjRRYUROejJ0VUtSaFRCQUVISC95QTU1R2IzaTl2eU1SZ3FuelpIRklWOTh4UFg2Q1N5Tm9lNXp2dVMyM25HVWh5L21Td1htU3lDUHAyRzVCZU1uaHdTRVd5MnJyQ0hWR2JRU1RKS0xCMGp2RllSQXlpMEpxUDhFY0hORXdybFZ2aXc3cGJ6bGNHbVpuQzZ5Rm0wM041ZVVWZVo1eWVIcEtTTWd2di8yT205V091NmJsMUhmTVE4M3AyVk95WEJHazBSaG90WVppdldYaWVsUjZUcWdWS2cycFpFNjUyOUoxQnVjaENlQmtFckh2QjI1M05WWjRIbDRjSThvS3Nwak9XSEkvY0hvNFk5ZGJ6bWNSblExUXNTWUxORFlLRVFjbkJNNFJkaDIzcTRLbWNVU1RISzgwMzE1Zm9WZEZSVUJORW1oaWY0elVjbVRWOXkydEZCaGpDVnpDZmRVaTh3TmlOekFSZDRRS3R0M0Fjbm5BNEFTQ25yZHZyMWk4cDMvNnlyRGZySGxWRkh4MGRrQVloTVNpUjBySmcyVk9xaWVrZ1dMZkMvUmdDRUpGYXdTZGxZZ2dJUEtPTkJEc2U4dG1kYzBuSDMzTWwvLzJMOWxkYjNueGxXZnk2Ujl5L3diRTVwN0x5akk0UzlldE9LQ2tXVHVNOERqcmtha2dPNXFTMlE3bFBjSld5REFoVWdHN1lvWDFGdFBIQk1KelYycVNENThnbFNhUkZZY0haK3k2Rm1zZHBiam5iV25KcHdIZWVMeUFNQTQ1V2FaczFpVkRXREdmS000ZlBHU2F6Mmp1SmRQak9lZVRnRmkzZEpWQTRqRlcwVG1KSVdaMmRnaTJwV2d0T3N4UjdGRGVZYTFoY0phaDNIT2taeERNT0hwNGlyV090bXlJcGVhclZVbmJHdzVjeDhOSFA2VDU3aTF0TzZydHkzVkhQa3VZbjU3Z05oc0diK2xrUUxWZFlRYUpjREZlS3VJa1Eydm5TZEJqTTNqZ1NCV1VZWWp0S3d3UUNVL29MU3B3bERjcldqTVE5VFdYTHNDM0pVd1dSSUdtR1hvU1FnSzFRVXJKNEVOQ041REhBdDlWTkxaQ0tVM2IxNlJCUXBiT1NBTEZ6ZjZXMSs5V1BEbzlaUkZwZ2tpekdYcWtqTGd1ZTNaT0U5UWR4V2JOK2RNekhzNUw1aytXTk5KaDI0Sml2MllhUkhnTDAxaXhERUpXMngxVmJmSENJenk0blNTYlRraUZ3RnJMc0ZtRHRaeE5BaHlLTEVsb25PU0RaeGY0WFVQZDk1U3R3TnlzYVUvT1NDTE5iSEpOWEZXWWNzM3ZYaGYweGpKWEhaODhtbEQxS1RwWGJMMGptMmJjWGw5enZLOXdWcEZJaGJlU3hneVlkMjhKdENSKytDR2J6U1dQRHljMGJVZHJMTkdnRVhuS0pCYTBQa0l5NG14bXVxVGZiSEV1eG5yUFBJUmQxWkduTVRvSWFadVFiclhHR290TmNxU0RvWlhVVW1IdlY4elNFUlcvWFJla3NVYkxrQURZbEQxcG5LSUZqbFpIV0svWTdCb3docmJZVVRZTlZrZ3VGaE4yWGN2Z0lvWm13TnFCU1JMUlZYdUU2NW1Gb01UQXBxZ0lwcEx0M3VFUjlQMmVKRTBRZHVCNlUrR0ZKOVVoZVI3UVZUdmtmaytxSlRKS21CN1ArSWV2MzNCNnZpQUxKS3J2S2UxQUswTldyVWZmWHpJNWY4anErcHJmVmgzclhjbVQ4d0Y1TUdlM3U2Vy9mc2ZnQnM3bUdlSFJuSEM1Uk1ZZFpoaDQvZkk3Ykh2Sitka2hzMGpSMVEzejJaeG1WZENyQnVjVVpqSkR6bkwycjc2a0xSMVd3RzNuMlZROXU5KytJTktLeUZVOFdXYTgzRlM4dU4zUTl3TkhnV00yU2JqY0Q2emFpcDN2K0xRWnd5WW5pNVFvQ3NuaWlFNkdsUHVLOHl3RElYSER3TlBUQ1pvT20yVUVGcTdYZTFTOTUrSnd3U1FiZWNaOVU3TjZjNGtWZ3R0dlh0RUIzL3ZvQTZUMnREY3I2czZTNkpDKzF0UzlwekVGT00vZHJtWjdYL1BnNkJndmVyU1UxSVBEOU4wWUpsVWx2eWtzNmVVRzdhVGtkZEZncmVQWHIxZDhlSDVBWnkyUkhmdjhmcmZ1eDNKRGJiamFEWFRPY3Q4cEVqeVRhTUxYcjBzRW5uS3o1dURBWUFtUUFnWVBXZVhaMVlZdzBnemVFM2hMWEhmWXdSSkdpa0FLbXJyQUFHR1djMTkwckFBbEF1UXc4UGZYOTFST3NPU0crS25qWGVYNTluYk5LeXl2WHE2NE9Ebmd4WHFQcVh1c0VPU0JRdzk3dXNvZ3RDYVM4S0tHekd1aW5hV1VBNWZibWpNLzQ3SnkwSTJYSzdPdVpsazBsQzZtN2hoYndvYWVMMTdkajlNUnNPMDhmL3JraEVaWi92MmI5WHZmUHBTMTV0NEw1bE1OY1VidzNVdnVObnR1UFZSV2NtOFV2YmJjR1VmcklCQ095RzRvZXN0TllkN1QyTEFiQnQ3Y2JQZ2o0d2lsSk5TQ1lqL1Exd1UyemdqU0FOTjYvdUhyUzQ2V003N2J0dS9aUDgrTFc4R0xtNGJOdmtWSldFNFNmbkZUOFh2S01HOUNRaWw0dFd2WTFKWWdEWGxWTm15ZFlQak5MOUgvbzExaWh3QWhKZFhoSVgvWkRPUjVnR1FBcGRudFdyck80a3lEbFFsQ09wcTZSVXVCYmdhcVlRd3RuaDU5Uk4yTnB3WkNvRUtONkFiaTJTbkYzUTNXZWJKWlRpYkdGRytxWTRTRGZWMHl5elB5Wkk0MTlTZ3EwUUh0MEhMMis3OC9vdDN6QlEvUFpod2NIZkkzZWtCNHg4UHpBNzZLTXI2clkzeGM0NTNubDdYbU9EMm1EUGY4NEVjL0pKc2tmUDNUWCtHN2lwOWJQK1lFSGh5eTIyNTVYUmdta3pHdGU2QkQ1cE1aOGV4b0JDMnM1ZXJtanVINUtWazY5aXJ2eTVMZm5oL1NPTS9rb1NhemxxWXArZlpnem5JMjQrekRqems4UHNUSENaLzk0QlArN2pkZnNESno4aTRqOVNIM0xpRFZNZDViUWhKTTdMRXVZRjlXbzFXa3JKZ3NqL2xWM2ZIZzdERmFLMjdiTldKbVdKZVdvdGtqY1h6KzJlY0VLdUJYNnkvcHJXR1p6OGlUS1p0SmdVODc4SjdIVHg1alAvTDhkSGZQMGNFQ3JUUjNkMXVxcnNPYWdlLy84QWRNdEViSkVIMTIvQ0UvL1B3NTJTUmxVenYrOXE5K2h1czYvdlNmL0lqWmJNa1h2M3ZKMWR0TDVHREo4aFNoQlhlckxhR0h5N0xtZHI4ajhQQ1AvdE9mc0YyWGhLN0RTODJxN05tc2Izank0SXoxOUpqT2RBUytaN0U4SnBRZVhaYmdIQ0k5NEREUDhFcVJpNHhBYXZvd1k5b1VuQzlqa2pqa2NCcWpicjdpNlBPSFhMME5HT3hBRmtmTXRFZFBUNm1xMGNGckNjRFhIQzRTdXRjdmNONGgyeXMrUHp0aEdnaXVXcytyei82QXYvanJYMUowbDVpeUlwR1cvKzRubi9EMDhWTTJsUU14UndwZ09jVUdJVGMzZDFSOUI3TUZqMVBESklneE9zSWp1U29Vb3ErNDZBY09iMy9EbVp0VGUwT2hLaTRmelBuZzlKQlpFcEwwRmUvU2tQWHRPNGJCOGYyTE0zU1dzUzRhM2txTlY1QWRKRHlhQjh5Q0dKOGFsQmk0emcwM1pjLy9vVEpjcEpGMjRGd3EvdkQ4aUkvTGhxcHUrUGcwSjhnVFZvbm1ZYTRSRXBhekdlK3U3eEduVThMSW82U2xsQ21sUzVsT0Qwak5EdTBsaThlUDBQL05XY3YxZi9neityNG5xL2Y4ZnRYeVpKbGkvdUlGenNKUlZmT2hoa1FseU5JamhXQmREM1RHSVZZNzdxTlRuRkJzL3Z6LzRaOCtHbHMrTEo3MXVtT1dCK1RiRmZkaVFxYzh5elJDdUEwRUVXWG9HS3dqeURMMDhoUlJYbkl5VzVLRUFmVit6ZHAydVBvZFJlRUoyNXgrdithanhZTEp2S01mWUZmZVlYWmIycWJuby9NWmtWTDBya2JJa0RTTCtWWHZxTnVlYjMvOWtqUFI4NCsrLzVEdm5VejUvbi81bi9OLy85WGZRMUhSREJWYUN4NllPejVvQjFhN2xpQktTQUpGT2ZUY21ZQzc2NWZJd1hKODlvQlBIbnpNdTNjdmlXMkRGSUlUN1dpck85YmZGWnpyUjBUMm5tYTM0VThXTSs2MW9LM2VvQnBCcmp3VERMTnBUK3NFeDJGRE1GUWN6U09Xb2FXekExZnZicWhMd1pNUG5tR0xNZnR2dlNaYjV2eFhmL3hmOEcvKzZtK3BiMjl3WC95Y1JUUGgrMTFMTVF6TXRoUDZuU0tySytwcTdFMm9tcHlzcmxnY0h0UFptcUYzTFBJWjFrV0lxS2JYTGYwd2NQWGxMOUQzcjk1Z21tYTBlVThDNGl3ZzBKNjN1MUZGb3R1YUJ3K1BjRjVRdmk5ODFsM1BmV2M1Q0FQKzRMUFB5SllIM1A3dFR4bE1SZCtNRXFkbkJ3bkxKTURxa01PaHdYaEhGaHRBazJXU1MrRnBqU1cwT3hJcldYVWJEbjNFUVNqWW5pNUk3aXBFc2FOM2pzRW9PbSt4dHVjNGNBZ3RFSjNqM2tvZUhPVFlwc1lvd1h3Mm83WWFaMnYyOTJOTTZ0UFBIdE1Jd1ozUkdPRjUrYzBMZnUveloxeGRmVWU2K2hhNnNXUzVXVzhJblVRbmM4SW9SUHVBS1JFWHp6Nmk5WjdwZEVhUVNQS0RDOVpWaThlaXpJcEZsaEtsR3VzRzd1cWEvT0FJNHkyK2tzVFRDWU4zeEhuS3dhNUF6ekk2WTFIVEdHOEhBZ0UrVkVnck9Ubzc1WFFXc2VrcVFqSDJJMGVCUldSejNERHc5ZGN2c2RXT3gyNkRIelRhRFlRSUZwRmszMVRvd0JBRmdzRmJJanBxMTlMVkc1cTJwYldBVndSQmoxWXBDa0VtRkRkVmo3NUlBMG9VeGpteU9DRVVpcTZyR1dURUlEMG54d0dCVWxTdHdVdURraURDVVRRNFRSZWNmdklaeDA4LzRDL2V2dUIyK3gybmFZSUd2SFgwRXJ5M0JGcmdrQWdrem50Q1Y5R1ZOYjF4aURBbXR3V25pNVI4Q2pvZXVQdnFEZE5aZ3RFcE1JemtVSnl4WHQyempNYVdEdTA5V1dnSmc0UmNPYlNVT0tISDdFTGQ4djFsamhrc0wyOHJ2Sks4V2JjMHl2UHYvdTNQYUlUaStVY2Y4T1hmclFtb21NV0tUV3NRMHJMMGxraENLaTI2MzNGNGNZd09RN1pWejY1elRCZUhySWNkemhoMnpSMC9mckJrT3d5MDJ4WHJ2ZVZaTnNObkdiMnlGTnVDMWxoaUVYRnlla0YxOHkwb04vS0ZqVVBNRTA2a0hHMW1zYU1OUXQ3ZHY4SHNPb1FRUFB2d0NFeExrczZaNXpsV2VNUnVqYlFRQm1OK3NPbGJlaCtNMUxYdHNYNUV1K0lnWXQ4N09qdFMxQXdkYld1eFpVdVc1d1JTSW9WRWF5YzVUVWRseUNnYmhuUXlaZFp1cUtVQm5YRFRHUGIzRythVENXR2swY3JTT2s5RFFHWmF0R3ZIRm95bVp4bmxoR0dBbGU5dFZlM0l4Um5ya0Fsb1llbDh4bUkycGUwTnhlcU9nb284bjFIc0phYlJ6T1laZ3hYc3lnWm5CeEk4WnQ5UUdjc3NHdnQ2bXYwdFdNSDE5WWJwMDRla2FVVFp0b1I1aUxlS2Q2VUhyOGhuT2RNMEdxZUNVQkxxa3AvLy9BMCtHZmtHZTNkTEpFSXVWeHVhdm1YVkp4em1DYk1Jek9DSnRTY05ZZDJIYkM1Zll3N1BDWllMWEdkWXZkalRYY3hJY3N1KzFuZ3Y2SWNLVlJraWJaRkRpek9HbDk5dFI4QjFzU0N3SGhrRTdQQWtMY3huQzlJZ29uWURGRnRTcFRrOG14RktSZHM1YW1sNTlmSWw3OTVjUWx2eWVUVDJNQ3NwQ0pSQU1HQUhnWFVlWjBjRWJoZ00wMm5LM1diSGRERW4wQXJURE9nNElMSTFmYk5qa0lLczc5R2hLSW1pQkMwbFdnaXNEU0YwNktnZ0ZJNDhHdGdaaFloVG5CS2d4Z3ViZVJDRE0weG1oMlNMVStxK1J3dFByaHFXWVVmYkM2UnQ4RjNQNVhaUFBjREpaTXFUOHdQbWNjRE4vWnFtSDBqbVN3NnlnR3cyUjlkcmJPK1l6TS81MlZkdlNad0Fyd25yaWlRSVdjNG05TjVocldTNmZFQnRQTFBBRTJjWmNTVFo3N2IwT2tJNndXd2VNMWpMMzN6MWpqOTRkTXJwTEdaUWl0YkRxdHB6KzlkZkFnTXlGTmpQUDJVMmlWbXZIQmNKbk9VZTIydkNXR0Z2MzFKS3lhNldsTFhuek1Qcmw3OWxzSmF6Z3hsMWNjL1JTVW8weVRDeFoyaDZwSFpFYmN0MG1aSFk4U0VhVUlUN0dnMGtvZVN1THJpNTJsR2ZkaXlTQ0NrMVo3TXBhbmxBbTEyZ2dwaXFxTWlER3FVaWdqZ0dQMkNDSHVNTmJkV3hONTVuc3lXMUNHbWJraXpKMFZnMjI0SXdUdkZDYzdOcGtRSkM2NGhsZ2RjUnZpM3h3clBJTTZURFk3MWw4QVBlajZDbkhjYXY1ZitIVlFyZW55eFlQNEthVm5peU9DS2JaTFJOamJVZTU5eDdpSFFrTXEwSHJSVktTNkpBSUlWZ2NCNHZCTm83aEFla0pBdzBVcjUvZXIwbkRFTzhIeVdGMWcwWU93b3MwMUNqcFJnMWJrcUJHcUZNeWZpOWxaWm9xZkF3YmdGSDh5eTl0UXpXMFR0UEdNVFl3WUJ2d0J0Y2IzaTFxUWdEU1J3cGtrQ09ZS20zS084SkJXamNLTTNBRXdDaEc4QjBaSkVpa1pLNkhpSFRLQmhCVjhHNGhsYkNFd2VDYVJJUjZSR21iZnN4TDZna0pGcVNLZ0hlVVZRZFZkOFRSaUZob1BEZTBWc3dYaUNsQXU5SFlCWUlwUUFQMW9HMUR1OUhNTGV6SXlpcnZCdGgxL2NobEtFZk94YkUrNVBEVzB2YkR4aGowYjV0a0VPREVPQ0RDYlZvYUx1ZUJFMFVhUHpRRVExUVMyaHRRTzhGalZlb0tPRHBwNSt3c1piWDMvNk9xdGlUQ0doc2lEWUtid3pONEprZkhoTXNaMWhucWJZYmlxWWlVVDJaVHNkeFVDdENhMWx2Q282U0dTb1FwQmVuNUsvdktDOXZNY2J6N05FcGVSSXlPSWV6QXc1SWxNV1lpcVlYMUtGRnVwRHMvQ0hOcHFVeks5ckc0eFJjSE9ZTVEwZG5FMlNzK2ZHZi9ESC95Ly82Yi83L0FnN3Y2WGNienA0ZHMxaE1LYzNBZmRsaWR4dW1ady9vT3pjV09TY2gwNnJCTjlkOG1CanF3S0Ywejc3YTA5NnVPWDN3Z0VCTGRtMlBEVVBNNERqTEF3SWhFVW5DMVg2RDIxVTRLVkRKakRESldCNGVVdFFOVGROemRWOXptR1ZreXdQS3U5VklNSnNPamg2eE9KalQ5ajJ1YVJHQko1Q09WbGlrdEZSTkJWcFRGUnNPWmpsNXFqRW1RUW5CNEFSdGVZODFqaWJPV1U2bk5PVVlSTzBHeDNSdTBiR0dSZ1RqNzhKWnFxNGpEMFBTek9LOVlGMkNDZ1J4cVBGKy9DK1FVcUFSSEI2ZjhyWXAyUmNseFg2TGl3MmhsZ1JhcytsYm9xWmk4QUl6T0pRUVdPdEkxY0IydlNLY3pFRkt1cUVqRW9yZUs3N1pGUlN0NGFKWUUzVWVHVVNVdGh1emJKVWtUcVAzbjNXZSs3c3RZUklUS2MyT2pKMFJIRGVHcXRtU0xtWkVuVVVLeUtjVDJyNW1Fa0VZZWw2V0hRZUxHYmRYYjJDZU1zVWpvNVRkdW1TSWVyWlZpd05PMGhDNmlyNGJsYlBLaDh3U1RWMXVNRHBEYUkyZ3h3ckZaSEdJRDBKOEZKRGtGdThrclIyNHZLNFFVdkx3WVlTSVk4SjhNdDVGdERXSjlaaGVzeHRHL1A3aDhRU1poNVRsbGo1ZDRyemc5dVpyYXYrV3plUmo4anpGQ1FlczJYVVFaRG1wOGFBaHNBM25KOGVFZ1JxYlJPT2NYVlV4RkFWSGFZajNuaUNTNUZMZzRvU2pTRklQRm05YTlGMWoyWHVOOVo3QUYyU2hZcmV2V2RlTVNkWitvTFBnZlk5ckJaNHhiclF5UGU2cnIvajBuLzlqUG5pdStPWFAvb292TDFmVVpqMm1iUEtZUFlhcjNaYUpNeWdCZVJiemJWT1F4UUhkN1I1alBlM2dTZU9ReGltdTloVmRiN204dVNmSk1vcGRSV01HcXJyQ0JqR0NQY043NWwzSmlJbFdZQXkyZll1eGpoY3FvUm9FYXRVUkJhUEpzekdDZGwrU1p4a0w2ZGhkM3ZLSGYvQmovczh2WDhLMm9nQyt1ZHV5UFR6RzMyOXgzdU9RWE5xQTVtYUYwTkg3ajVlT1puRHNtd0V0UXFSU0pBZUhpTzBlNHd6eHpacEpxQmk4UkVwSnJTSW1NcVFiSE5jMysvRVBZaDBDVUVxVGh3R2kybEtWb3piL09zMzQrN3NhWnd3aXZtT1doQWhud0JsVVlQbjgwK2YwZGNud3hYL2d1OHJRN2hzR0oraWJua2t3WWwrOUc1c2RwUjRiUVdiU2t1VUJ2WFVNKzVZODZCbThwNjVyakFjbFBQci9mYkVGNFhET1VlMXJmdkQwbE5iQ3JuRllQeVpsM3R5VjZHQXNPUlRXY1ZXMHhOT1V6VmZmMG43eFM1WVhGMHdPai9tN3Yva0Z2N09PU01Bbmg0Skhpd1dyMWhKMmU3eVFKSk1KMzlRZHA1Rm1XL2YwM3BPWUhoMUthaEh5dDUzQk9qaHNCcktzNFYzVmpwSHJQS2ExTlowWEJFRTRBcE45Z1pTV2ZEb2RSMEFQZFYralZFZzNkRHgrZEVFWUJieTV2R1NpUXA3T0o2USs1OE9uOEtmLzVEL2p4WXRYZlBubEY5QzEvTS92T3ZMOW1tN2ZFQWFNM2NpcEkxQUI1WDZMZDU0MDFkUnRUMXUxQkVpa2treVBKRzVvS0xkN1RoY1JZUkF5bWMyNTN1M3AreHBwT3ZDanMwY2FReThVem51azh2Z2tvN1VPNmNjVEpnNHRaZFBTOVliWlpJcldtbmdTc1lnREhwVUZmL1RqbjlCM0xYOStlOFAvZEhlSGxBSGVTNHE5WlRvSjBXR0lsM0swbTZEWTdrdUNSVVp6VzJHSEFZeGxsbHVpTk1NTUFjNTZna0NnLzF3ZlVhNjJTQUVIRngvd0lwbVF6bktLcXh1R3ZrZE1Jc3JFSW0zRmRKb2psU0tPTTV6V0hEOS9SRHFOQ1VUUCtkbVNYMTg4SXBqUGtGS3lPVDRnUEQzbTNlVU53bzZ6Zkp4TzJEZDc0cU01MTFkcmpCbm9xb0xqZ3huYm91RThDcEZDWW9SbnQ2OFFYWWUzbGo1S0VNcHhFS2VFQW9TVTRPejQ0cFhtV0R1R1ZvOTB5SzRvT0lna3lTUW5ERFJQbitka1NjQW5UNytIVnBvZlAzM01iVFh3azkvN0ROOFUxRTFKMTlTY1B6aW43Z2R1VjNjSTRQbkhIMUh2UzZKcVA1cE1rZ3kvSzVHVGppeE5FV3BNU1IwY1hoRGMzaE9tQVZvcHBrOC9SallsWlZHU2FJbnBlNGFxSUlvVWRkM2ozQWo5VG1jWjcxWWJsQkJqbk1zcnJGa3p5eU9TSkVRSnlVZWZmVVkrbnpKMGE4eCtnWkFhTFFQQzZRR3V0NkFVNXllUFJ2ZFBOM0J3Y29UVW1uZjNHMUkxNGRtSEgvTDI3UnRzYjVpa0tkTjVSaGlFMks3SE84ZnpENThpL3V2Ly9uL3djUkl4REQybTM5TVc5M3orNUNHck41ZDBuV0Y1ZE1LYkw3OWtIam91MG1COEM4MFhuRDU1eXMyMlo5OGEwaWpDdVlGdmJtNlpoeUZTYVo0OE9FYm5HbisvWjZrZENrRmRsZFJOeVRTVVhLOVh0SDJQbEpxRFNPS2puR3dpMFVuRVh3K25EQTRLcGFpYmx2VDBFYXViRzA1LzlUTitjSlF3aTBJMlpZa1RqdDRZQWhremVFK1VhRXBqcVZ2RGFab2hoQ0JiVHBuTUpjMXU0R3BYczV4TWNGSE1xUXg0OGQxM0ZLWWp5bExtU2NBZ1FxUWVUOE9qK1lSaTE3TnFOMWpuaUFWSU1XUGJkZWdvUXFzUWtVMUphUEZ1WUtncWVpOVpYWHlQbDAzRm05ZVhMTDk5Z2ZJRC8venpFNEpRVVlzWThEUjl4VHhKMmJjZDk3dG1sRDZaQVNjREFxMDRXYzRRU3ZHOUJ5YzROV0hmMVRUN0R1MUhZWVEzRmZQNWhDU09LZXNHWnpxY0R6bGVUcGpsTVM5Rnl1cDNMemc5bk5MMVk2UnRvaVhXaGV6NmhvdFkwQTRkcDhzSitudS8vVE51OTJONXcrazA1akFXbU0zWFRQWWxnZlZjbEZPZVRtTjZaK2wyMWJqUzdlN3g1YmVFTFV5OVEwdEJid2NlaUpDbzZCaThKREZUMW0yTE1aNXE2TkZLMERuSk5KVHNCc3QyTnpKNkZ3Y3hxNzBEWjRrbU1YbWkrYmo3TmIrOEdmajFiVTNySlUvLzhUOGpXMFFjVWJJMEd4NUdpcWFzS0lnNWd0WXhQZ0FBQkhWSlJFRlVXd1lVK3dJM2VDUURFNmQ0TUp1eURNYWY2ZUZ4d052TkJsdVd6TDFqWWdaRWIvQis0QWVIZ3Q0NldsL1M5eFdMeVFHYmZzQUMrNXQ3WWcrcTdoa0dTMVZXUFB0ZVR1ejJCTDdBR2JoLys1SThWRHlkQmJ4b2F1NGF4MDkvKzRMOXdRazM5enU2dHNiYkZpVnpqb09FKzZiQU9ZK3ZHNEloSUI0c3o2Y3hlSStwTzJaSE0ycm5TS01CajJIWnI5ZzNOd3lkeFRkN2NCYTkyMEJiYzU2ZWNCNUhmRlVVN1B1QjVYekdZWE5IMENsWWw3QXJtTWR6NGloRGFFRlp0N1JTczczZUVNbVd6c0taT2tTbnl2SDhZRlNQK2NHTWM2d1hCTFpET1UvWHQ1U21BeThKVFVQZ1BZU2V1Z2xIN2FrRGFRVnU2QmtHUXhwNWxCQk1vNGl5cVhHbUpRNER0QkIwWFkxV0dVN0NSTlhJWWNEVklMeW5hQXdaanFHUlpMR25hV3QrTDYyNHR5RlJZUGpGWC84YXQ3M21RWExJY1I1emVpeVlXbGllbkNEOE5aRXhPSlhoK3c1cFBXMDRaZ0dMdW1HN3JTamFEdWVocU5jOG1pZkVCek9xZllmekZwOUk2cm9oRkpyby9CbkNlL2EvL1FVaTFtaG54aEtMTEtTNmZZM3JXem8xUnJVekJsb1hjVlYwL0hyVjBCUHc2UG5ISEg3K0dmLzduLzBsdWx2akJjVENNV0JvdXByT0RNeXpCSzFDQWxxS1lvK1FrdlA1QkNsNitxNGp0dU1FMDhlQ1lsZU5MU3p2MjFoYWtlQWtCR0VNT2tMbEhXRUpWVm1qOVlRQVdBaUJUbks2MmhIRkFVcHI1cE9RcTEzQk1oM1liM3IyQmhvajBjcDRRbUZSVW5DdkV1YktJWkdraCtORG9lS0V0Nit2U0ZYRVBJMlJIcVR5eERyQStnSGx4Mm5CMkFDbEpRbjlLRUxxR29aaElBazFtV3BINDdZU1ZFTTlqb1ErSkF3REZubEEydzBZbDJCRVIrTThiUitSQmlFbmlTQjJJVTkrL0NmOCt5KytaRjEwVk9XR0RSVnRQc2NNaHVMMWE3UlNLQW1USklRNG9GY2h0UjNiT0w2N3VhZTM0M0pKQ2tFdGU3eldGT1ZvUGg4ODZFRWpveG5HZU5ZdnYwRklpWW9UZEtDWlRTWEdlNHpwRWM1elBEM2t2aCtaUUxxT05JMll4d0s5dDJ6cWdmdTdiM2d3L1NOV04zYzhuWVZFc1NMVzRGUkVXeG5xd1hFK1UzUU9WQkJ6TXN0QmVMSXM0N3JZUTl1aDBvQlFTdmFsUmVnUXJRUjI4QmpuQ2JVaW55d29yY0NVQTY4MlBmdmFjejVKOEdVekNqKzk1K0Z4VG0wc04rc1ZnM1VjVFdNVzB4dzdkSlJUQmQzQTViWkNYOVlkVDhPY09KQ0lBY3JCc2NnU0xCcVBweHBxNGl5bjNGV2tRcUs4WUNkQ1pEVGFPMW83N3FabjJZUmQxK0dqQ1VJSXFyWkJJMGlWb09wREhHQUNqN0FPMFJ1eXlHTWR0SVBuOGNrU3U5bmp4R3hjWUFoSjUvWk00NERhQlp4ZG5ITDU5cHIvWkhISVpCR1Q1Q0dYdXg2aEpYVVA1M2xDcUNSOTU4bXltTDd0Nkt3Q0JGVlhZSjBrampWS0NPYlMwMW5IZHIrbktndU1FenhhTGtqeWNOVGgyd1kzZUxxdVI2aUE1ZFNpcEVabHh4VDdMVlZaRVNVaFFnaGEwMUsza3MwUU1na0Znd3g1OXNPZjhMLzlYLzhPczk5eFBwOHhqelZpTUlTeDQvam9pTWFNNnAxeTJMRGVOcHpPVTVKUVViZFE3QXVXaXpsSm1DR2xvREVWZFcwZ2lpanFtcll6dkh4M3o4V2pZMmJwS1ZKb2VsdFFOSlo5VTNEMDdBUG1jY1EwTEtpU0tYMzFscmFwcU40THZ5Wk9nd3J4Z1NCVWpteVM4UjhCZGFzaXJ4RmpmOVFBQUFBQVNVVk9SSzVDWUlJPQ==","base64"),
        test: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUVBQ0FJQUFBRFRFRDh4QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUhFQVVEQjFlSTN3QUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBZ0FFbEVRVlI0MnF5OVRaSTB1NDRzQmtma2FjbnNqYlFQTFV4VDdVUGIxVVNuZ3E1QkJFbjhNdk8rZnRmYVR0ZFhsYjhSSk9od2R3Q1EvMVBlLzZrSVJGUmt6UDlpL3A3bUFaeVBmMzZHeUNVaUltUCsvakkvaS8rbHB0OURCT2J4Ni9YaDMwS3E5ODEvc2crZ2VYSDR4Nnd2dUw3NG1GK1Q4eWswbitFMmJ6Zm15OUs4NWtnZlkvMzFNazhmODVjMEgrbi8vYi9lVjFRSVJRUUNDTmJQejhlQUNBU1VvZk5UWVg4bTJJdDFDVGcvaklwU2h1N0x6dmxFSFNLUUFkSDU0b09pOHdVNVB4OTBYMU5RT0M4M3pHMkFDQ0V5M3I5Q1JEaHY0bnc4dzNYeHkyaFFaTDc3c0k4VWY3MkdESnEzOEhlZEZNajhwZmtUYnhITVg5QThnRUlLcm8rSXlEL21BbzY1b0s5OVNmZUtIUFAzWWNHdDdiRitYaStvZm9QQmJDMjczSzlxYjdCYWRwZFpkalRiY3N4dFJyL2Z3bWErUlQ3bVF3Ny83dXJmNHZrQUgzTlZMN09Pci9sMDlYdUc1dWZiZkJoTlcrdFpwcmplZFFuWm4reFpQV3R4UHovbytxdjl1RERMRlB1TFBJOVVFWVVNRWNGN3JkYmoxZHhJK3pOZ1gzTGZJK1M3L3Z6NGJEelpId1kwVzA1U0JLTDdsNXAvNkZxZDgra3E3dzZSNjMza1h2b21DTDNYYVlqTURmbnUxVXZJSFJRd2w3NVFybjlrL1B0NTE4R0s0di80N3hsK3Z2eUtIMzZ0bzFxK1R3aFU4MWMxTDFJK0MrbmRUU1RhcTlrdVV6WExIWFBWcmd2MU1jLzYrQmlrWmp0ZDg1ZTMrVm5TNmZFeDYxak5KbG4zYkpnL3FZa3A0UnZkNnhTQzZEOUNtTlU1WXpueExzY25lRDhud3hOMDExckhYSnZ2bDNyK1JORnJYMDAxdTJMWTVZNzNMajZiUk1YOS9qMDkrSzRxU0JPbHVuK3V1elBlOTEzSEpmQ3U3T2VNd29yVGM0ay83enRVOU42WGhXdlIwNngvQ2xab3YyUTh5MTBGSW9NQ0VWQTQ1bUUxUkNpQTRKTHhKeUlmdDlxdXRPalYvd2JwTG9hZncvS0ZpYUFCUGttemw3cUxiQlpHQkVMMkJabmVhNWp0SWVhZ0NEZkxIa0dmNXEzWHc5VHZYaWFRSmc2VlJIUVVrWjRLS2ZweGtSWVcyOENjcmhhV21MK3VsME9LSDRDSTdxaXM0VVorQkJUQnZBTG1xTDNzeTFxOEtGTHRCdjhONXhYQi9PR3lGeG9pbE91SnhDS2ljNE41TlBuc1dOSzhxajFiaHJuamN3OWNKbTVoYnFkOUlsRkkwVXZHL1VTVGovdmttcFltelFXQlgrNExEcTNZQ2JQZ2FMQ0gvVUg4V2wvdjhqRnJZdmczTGMrRWZKS0lmNWI0RFdNWE92MW00L3pOUFY4QkJtSmRKcTdUYjZSd3UrRngvL3J2YzZTSSthYTMzVjBHS2VvMTMxNDNsc0JsamptYkZjd3pDUE42QWY0bThiMFRtR0hHb1pHd2tjemFRZ2g3SVRoZDFiNkhYeXM1Rk1IdEhBNTNnd2tCL1VvYVFyck1EUFNZWjh4dE05N1RBK3Y0aHBEQzhYN2ZsWlp3Q0NBWFpLejdnVSt4ZFM4VEtVc2dGSGJ5eHg4TytWbzl5MGo5MmczTFdoTmNMc1A4TUttRnhkbWFsblg0My9DZzMrNnhsZVZicEVSelVFaGFWeXRZM0I3ak1XRTJ6a3UwM3ZFdkhJYllRVnBVOE5seC9mMy9TQjlpNHFLZHNpUTR0SDllOFJ2K0ptbzhaKzFqWEh6L1ZEbmYxLzh4YllaTFFvcTdBQS84SDdpU0Nwc3owUHdnZmswOG0zeThsLzVGUHRqcDJuTmNVQVdYOEcvZll6d2J3SzVkR0t3c2FXOUxoZjQ3K0o3eGZVaUx3Mk0rS2I3QU0xRm90dUtuQjA1aUZ2Y0M2OE5nR0cxZ1czbXZRekt3WHZiVHBPL3FkN2o0bytaOUpCMW9nUWorTVV0V1ovQUxwOXV6WGkvL3lTNEIzUjdZNFp3dVJYNFJFYW9Od0FKRXRWa2FFMW9JZjBYTXBWN1VEck0wR1dNVlRhaWppQXlCaWd6ejJtT3lWWXhITnRmU2h6bDVJVEpFTCtHZjBOS1g0N1BYc1hxdUJoVllGNStBNXZVdEZmK1R0eENxWjJWRUFSOXhteXlyT0Nza2NhbVNTS3J1OXVXTWdsV09wLzNlQ0xuQjhId293a2RTcytEbWxkVlB2QXI3b0NnUEI1TUF3RjlaKzAvNGl3Vi9qeUhOemY0eDZuZjNKdUFydXMwUTBOZTczQTEvaWhYNHI1MGs4REtFN0hydWNLeVVES0h1RXdhZmx4SjlVM0RJb0ZBK2NhVktGUXZWczRyaU1YMDQ0dVpCdElQck1CdG1lS25CUUQ3M01lNEtpVW5GNVd2MUovaC9YbjVwM3ViZGgwOWpGajhUOEpMNjlHWUZsNUFBNVBCbndSSk1JckhFZ1VYK0FBYXlZL0lUSzNtOVRFZ3llMFB0M1pxQkI1alA4c2N1OHBFOWR4RmdvRWlJZi9TNU5kTVNZWC91VHdZcHNKWUwxcTlndjRpYXFBQ0ViZk1SVHFEdjl0SmtHOVlSd1hsSE1RVC95UGliQk5UOFBFVEtBU1RSRjVLb2ZXbU9DRW1NUGhMektFWmtFSk04NUR6N2t6S05jS2grREo1QlNuTWw1UnY1eGZPM0NKaHFyZnRQQldtdWhMSysvakM4c3JiQ3hBN1BkSXkrNVlVZy9yOCtxTnM4QVpKdWxTWDcwVUIvVkRjVURmZVBRcytxb1Q4OCtFbnhmcWxhU0pITWFWdG1TMERlMEM1VzFSS1hIbkJ0aGlINDMyWDh1NFc4elNaejNtcE5yRHo4K2xpeE5peFRKUG9sVURRbHphOE55RVlEUzg0SHJDYjh5VzlxTVJ2UVpTWHc0WmU0SkRKRGtzdzhxaTMzUFBIMkY5WnhpZHdvSCtFMGViQ1FUbEdXRVFWdGJrYzhaMnFZbjNENU5NUWJTeFBSdmFEVlhGRGVnSEQ3UjdNeGxveEFod0VXK25kQWlHNEQwSU9jNTZGREptVWtMNFAwUEJGVy8xcEVrODRmRnVNOHJ3QlVlSDhjU05BcDlHUnU5S3FBZnZodm1kMnFYOVBhcEo0bHRzWVAzRVBJRTlnY1Rkb3JOakRwYWZrSnU3MXQzNUdKK2JIaWV1RFFMZGJpdFZWYldhU25ldlIvR2ZJSGpqNnkvQ2JzV2xTUGppVGxFc056Wi9BbkNkMXBIcUZOZVRPdUtycWt0R3FoWGxDb0R2RmJldUZaMW1EY0dQczYweGtpTU05b211UmhxbDFiT21UMEwzd0tmVGRMWFVpaXFWWnNaakEraEJVenZEQ2tLVHZVaExibEcvODJxb1M3WkQvUCtxNTRRak9mR09yTlBPcHpYTHV5YWNqSmNSVExHUEFiQkErTm94SHI0MlBXdlQwRUxHNnhrZnNmZzRZVE9rSVEwbzFNaHJDaDZlRVRxNXZSV2JJcUNDQ1ovYnpleERkdkpJZC96RFlBemFreW5HOUN4aVRXUlBDUjhlL1V5Qko4aDhpQTRJbjJ0NG42T1o0RmpReCt0WFdaUUY2T254U2VQNFltRisrNitaakVkS1JqNGJZQSttZDI2Sk51SFAxV3AwZi9HVVI5MGpxMldRMU5mbno1TSsxT05OUTlyd0FxYm5GYmc2N0pqVjZPblZRYjFMWEMvUXRXK2JNWVdwR3E4Z3Bxa0tTMDIxdFpCZjQza0ROQlQ5bUJ2TWFkRkZFWlk0b1NmaGVSVSt2RmpQUXdxNWx6aDE4YkpuRktZekpFMStvM3RzSTNWM2FTM0NmR0FzdGJXMmlFYi93WTB0R1BIMWkxRXJTb2oxRDZMYzJGQnlTczhnMU5IbFd0MUZ6NzljdVhVbzkxalZXeDhEN1lQOW0zRzRZUjRnenFrR1NGdFJtcXpZa0Q0Qkh2M0p6Y1A1QmNEREozUmFLaUVTSUs2L3dzU2dURFNOSHB4bWVXTTUvZzF6WFhKWjNzQlFQdUxVUDY1QkljTVYxKzBlT1Q1L3dqdk44amNabXBCQlA5ejkydWxJRlBFZWtQNit3eTJmQXdqa2g3TDg3dTZDdWxtOWZjYWRZK01CSlRTWSttcElKWTZvMW9rclNueTV3ZXdiSWhqUVo4ZVZ2RVBiME1TT1k4dTAvK1VySzd3dTVsMU90NzZnRDBzUWZHUyt6RTNZL1J5eXFua05zMjRsa2o5Y2xEUlFmVmYvS1J4Z25HMTJib21WSmU4cHRZUEtZdWxrNlY3UmlsMlJJNmcvMjE5OFpZWE1KY0lvL1RBZGF0aldpT21yLzh2TGZ3azhMdzhMa0JQRXFSeGkrOUZ0emx0dzByai9USFVCSHJueFpSWE0wK2hJOUJTTFFWa3ZQK1NqRG1ZNDdpSy9FODJ1VFFIeFBqN1lyL2VDNEk3bzVzczRiMUZBM1pnSFh2Tm5ndkZ3emgvUkQvdXYzU1lkRkR2RmdqRy8rZ1RKZkxrMW5yOEE5eldQR3NqTkVnbjhWT2hpTjRYbmVHNDRGVEV4RG4rb1EvVHhlaHRMSDZqTWU4QmZjTUtDWnhJdlpTZTc0Q1JZQlBoUHRJdEU5V1JxVXlLcGVyTTJ2QXBTU3NTVnJCOFJLak9ySlF5YnBhcEhNdFFZUXF4MlVTZkZDSnpmWlUrVXN3d1g2cXNCSWVIVUQ1cXYwN1d1Z3JhVVhySDE3UDNJYnlrOHFFeEJ4Z0piWGI1ckIrbyttQ29CSzVkRzgveFd2Y1FEYTZNVjc2VGJtTWRLdUdQMCtzenhtN2F1ZFozM2IxYzRxN1VZZ1ZjK25wTVk5WGZMQXFmbXdPb0FaMjA1OEFnY1M4ek1MS2llL3cyUUpUcU5aam5pcEhCOHFCV0dDano0UTBBTlY3ZFJpVlZkb21hV093OHJ4a1J3eXJmQ252SWZVVldDanRFdnBpai9kT3p5ME95K2hqRnFuWVJieUlUc2FRZzNJbndOZ0t1bW9ZSnNrbStkR3BScXhOZmtsT2E2ZUxyZFBJZ0dDYnd6d2ZkTC9ncTNiOWw0eGgwSTVoQ0xZRFlwR2grdTduc2VvQmhnRzRHVmhMNWNyOHBDalFhUVhTRkJ1VS8rVFBkc09EQjFHK3JWR3A3RnRNTEg2M3dhUVJoZXlXWTBNTWpGemtxYzdtV1J3dThtcGJLbHN5VzBiR0ZjczNIU1RGcThGYmcxWVVoOVdoazM2SnRXZlFMUDNEUFRDVWpydVNObEUyWis2VHl6N3dpV3A4Yi82d3RtY1hieUZlcDhPK3YwaUs0M0o4YU5paFV3ajdweEZsTTd4bXFtQkVrMDJlbFN4VTBxLzhOMVoveUlEWjJCeVE2QjN4YW1ZZ3BzWTNXNlFhMDJFK1Q3cGR0SGtoT0MwYUgyUGN6ODRUMmVlN2lGeWZHTWh0RnV2cWljV3RnOW9rbDV5TU9EdERTMG00T2t5THY0K2tZdzRQaHhZRU1zUVVmV1k4UkVSRlZYZ0xkRXUveXluMEp1S1doMTVJNmIycW43aWFXVmtoeE5BajRrc0NBbXJYcVBkdDgxbmdFQS9ZWGFvb0c3ak92RHF6L1hqNEUwQ3JjdVRMTEhwYmlrQkRjOUZzbS9KR2g0MmtpYm02cTBVU3hSWnNzQkZLQXR3bDlyUVBydWdJV3R0RHBkRHRrWWdnaExNaUlIYWtxcWovaVJQWmlMdjArUURGRzYyTS92VWNBbUE4U1piV3F4UlZHYmNQL0xKbDVxZlNjbTExbWtTSXQ2SFZXTVdhKzlVVFk1SFVwekphaG1qRmIzSnl3elRVQU9tc01CenVTeFlaU3ArRkptaktLciszZTQrZUxndlgvL1lVTU5QRmNmOHRhMUI4bWc4VWhxMVZ0NldYVzlhTEMwSjRrYUE2UzJXMFprb0cvanQ0MU5zZmtGMXg0bXBjbUNvRW1DUUM4UVpwL2hYT3Y4Y3RoL0U2YlNuSkJMSFB2VTlSQmdrVCtkVFlCUENEangvcDg5Q29wR280ZFppVmw5MHlvVHRMcG5TeWN4dG1PYXIzUzdOYXN2WkFHSjRwR28wVmp5bEJrb3A0RFl5bk5QNkxhUGp6QVdQWGZBMlgzUVlVRGhQSXNxOHpGcGRKVVZXRVZFYmNvaU9KTmlRMHhSS2g3NE5iN3F5QUVoMWVXcmVCa2pDUCtRdzJ1MzJXdUhJYlRHalNLbG9mNGowZEV3c0NzWWYrNGl2RnVzWSswaGZPQndNRm14WUptZGJVSkFQblF5WXptSmVQMzFybEcxZmloYlJDV1dpUUlhczBJRmhFdStQTFhwemJOT3JaSVZ4Tm5JT2g5azFsZHlqZTI4WHljR1Jvd0RhQisxZS9HWnoxaUVLWXpoRk1YdXZlZElnZzBPWU5ZRmtkVXc4NVpqMzdNR0VHNXNRZzVackh4ZU55NDB6OWQ5T0hTdDFqeVZqZjA2QVRxbFUrdmdXUTlBeDlVTDVRVlZxaEw2c1BZTUN5cUhmcXpJUFVYeVJnc0pHZW90NUhOSnAzUC9DcWdRZTd6VDc1ODhzZHFhcEJ2TSt2OUdJZ0gyRXNPSno5NGlvcW00WVBoWlNDMTlyb1FydEVQbWY0TkRwMGlGajVoaVk3dzlLL25xWWpSVUhTNm4weVpwOExyNGdWMlFHM3ZlY3p6NGZkZVltaVpUM0FvM1k5a3ZtOXc3K0xEbmRhL1VZWWZ2NjdXU0JXRUZrcllmVktMc3ZzNysvQU9yK1JRdXFkY0pweXNMQnExYTlSVk1UTHA5ck1JNVU0M3g3VnFIOE1ldTY3cW5yZENYZDJ5S3V2VTczbS9RQzhqZ3Z2VHpiUkJXTDRVS01IUDBzVEtqU3Q0QjVoWWQ4akZXVThKVWpSS1JTTXVXMEExdzdvUFNlbit2YTBrVk40Zy9CY1EzckpHSExCYVNDN05uQ3N4ZmNpRnM0OWdQbUR6cENQYVlvZXMyY1dWZVRQS0dtb1VxYmJoekc0a3FObFBOSFZGZ1dwNVJ1cUJXME4vVmZ6TU9uTmNJZmFYM3FobEUxdk9SejdvMlR1djl5aUphRjNlZkpLS244MXZMUHRidkxnckpwWlBaaWVMeDZsQ0lmMHI2WVhueTBFbzFsL2diOVg4Y2t4WFZXTkdydVJoa1RaQUtIdWdyOG54cnlJN3hhK0V0bTl5bkd1MTNaS3MyOHBMdjkrZFRGektPbENQdVBkcFN6WHhOVGhyZjRseGk2K0FCZ2d0OHdjd0I3M1YwVkJEaE5LZnpRcGFFL2FqS09MQWYzcGNjQXQ5SS9SQ3I1TG80S0ZWNUFmWkMrcDZpRnpiNFRMeC90QUpiMExEaEhObytRcjFqbWdSUTRHVDNxcXhpNkxDSjBQY3pKUTNrZDFEUSs3VFdvUlNLMEh6Q1IrK1lLY1VWUlRWOURaMmtSTXUwOU1qNUJDQmh6QzJaM3orS3E4WXZtRDJUNkk5cmhmamJIWXJNTE90Z0NQK3cvY1pSZis5UWVIRDc0bEh2am1Ec3JyVXI3dGdVNEFOaGV6ZUFBcUg5Rkl1RWliWGxxNzZaOXBTWkxiUFVRd0VWSTZ4UDN3ZWlWTWJVMDB4dVU2NE5sVE1XakdMdE5nRFFjUG9yQ1RoRDBUYWkxQTZoK3NCazF5R1lFZ3dNeVNUWCtIZTIwekZkeStqU1IycnhUNk93Y1JQRllJcEc2Ylh4MXZXcm5aMEpTVm9WUlluSWZ2OUQ4MG9UZi9rcFVvSm9iSlpjb0VKUGtnV0dXazdIVUdOcEtvSER2YjJSV0ExYVg1Y29WZDBkZWdqaFFxSUpydDRNbUpRMncyckY3YzFlMDRDbUt6aU84clVkNVF0RmVuNDBCM1pmcEtnckU5Y0p4M2hWNUJlNUNQdmJXZ3Y5clRFOFY3U21uV2FZZkk0WEpEaFUvTmJOS0FYZmdXQmxrRVJiTXVtVFpHWGozbmxsS2phYitqL1Q0WnFYVFRtcC9GZCszTnlBZlZYUnpKWWpROGxwTm13NC9HQTFmYVFtMWhPRUx4dTZhMmNCb0YremM1cHRPRDFaNEFWaW56a3BsYjl5Z292aTl1aUE0ZzBWOU0rTjlaYThPeWZGNUc3bjI0bWdldTJLeVhQYTVOSFFNS1g0TnpBWHpxajY3K210dTJPY1AvS2F0Z0phQTZpTHNsN09uQTB0ZlRJRXNLK0hiTHRMSEtaVlNUaWYreVIrOHdKTS90ZDVIOS9aak1US1IxRWE4R3hEbVF0NCtOdm5HaUZFWFp5MG02R3ZHNndpNER2UkIyd3ZxWmxiblh3SHI0ZFVBV0J5TG8xRVFhbnBkVmI1VmQvakppaWR4TFluWnRiZUFWbThCWDJPL05xUU44a2xRVWJONVhDamJkb0lDdW9rajlQaGtOckdjekx5TncrV3lnaUJXU3hXdkpyTEx3N00wTUZZK29mTkhpczZ4OGFJekVEb1Vzd2xhbGdiN1hsY1IyVkJhZ0l6Z2RNdlIzQUhmR2Z2WEwyZ3ZEcnFEZWUrYlFXTmhoTlNZWXV4dU02NlpMQ1VaMTB0SjBjNUJOVTk3RHViaER0NUc3K1ZUU0Y0aS83TkFsdUdWZ1dpRmFKYy8wZi83NDhSbmFKQWtqTVRCYVVZcDZUSjIxRDlWbDFZdjQybDlKV2pJYi9aalZzWE5WNU0vb3g5VU1QL2xpK0xVdXhoRW9wYkVDN291MUpod2ZKOUJRU3c4Zm4vdGtMVjVvMlN1ZzZjcHJsTmh3UlJVcEhMc3VuMmJGT2NCa3VzOWZybWorc1Y4RTNJNS9qbVFBbVljdnJRTUNabVZuSTROVXJZWFhnSVZsaHN2ZWdWTC8wblFYQTFnL21JWFVyNCtEUUpiVHlzdjRjeTVmYlRpOHcrSk8rRVNhU3BUTVMxcW42dkFub1ZidHZ2a3RCMEJpaENUWm9XRUxiZEZQSEFsTkViVUtHNGd4d2kwRG16WmNNaWlxRWZ4c201Mm5kNkRlcUlQWGl1eFdoVDBycisxb2VQVmdYNEZKbXVraGZHL2M0cWw0T1l6QVlCWjZSaitoNHFsZ0RxSjhScGgzZnp0bnljZmRwOHRYdXNnUENBZE5taUdONVVHVEFvQ21MNTJrdGlWUzdhNnlmY3ZWVUpaeTFPYVFQbkRPVTFtRmdEL1BqL0dZbU5tV1FSUVpRL1RqMkpzQ0dzTHo4V3l1aGVkbkFuWmFDc0E3UDBaVG84VUVrMFJNKzFGeEVUUkk3NXl4Y0JFNG1zTFBMdUF5QjRVYUtXMjFMaVJOTkJvT3JXSE9GTE1FbHd0cWFpNnU3SjRhVEtxWmlneDhXb1dvdkhsaEZzWmhQTXg1cGFJUG5MOTBnL3ZLbVhhZG90bXpxSG1KbDArWDVIWExvbGdZU1piS1pUMTlkTVZMWDV2ZTZBaE5KSjRVZVlLWVNackRIb2k5Sk1Sd1JQaCsvUzJoeEFDKzZaV050QzMzNVowWjgrcmJNeWFtaExVNUxORnFtT3cybkkwNmRTNVBFTUcyRWdwWGFpUVdLRmRDWFExM21kSE9NTzJnMVRORlRGM2ZwR0pPeTI1Y1lVYkpTSFhWNGZIQlFZMm1hem1TcE0zR01aR2xBQnB1cHlRTXNnS05QaHVHTVNydC9sRHFMTUZ4S3BPZkZDUldCazVqQ2VIckxhM3dyQ1lKZ1Zrcmg2WVB1bHA4cGlPWHB2dG42WTNWeERlOFYweGZxNDlRcnFkbCtlcjFPV0x4OUJLelVJWE1wOWozYVJzSzB3Z1JTRHNXUWo0OXVUNk9aV2JGSjNiTlFKbDRhcVlwaTZpdVZOZERzMGUvRVRoMVVrQlhiY09qR0NlVnozbjBZSzg4TjBaeXdtbnFtRlRQSC9BWk1LU1NHQ1ZCZjlOSjF6NkZTTFZOaktGWGpZWWF6MnFkS2tRNkNpQk44clJZVk80bVdjcVdUY1p5UGVoYnNzaTVNK2s3TVk1cDlvenRUY1hZZ2JydXl1S216Y2FVZER1NlBoRWVhT1Y2Q0thZzBHbEh6WE1EWGtJRDZNOVpJNDQwL1BsL21acEVENGNrcmZoU1dtYUQvb1BqVGYwUWdKd1oyZys1aWxTVlRUb1NQaVVyR1JrUlVyKzE4emxNNnU3dk1FUXU3M0tMeEw4LzhmVUFpbFlEa3NXdWVIaXdMNTJ4Um04SkVsdE1vSWQvekFvTDNQQzhrZE1lQXpiMjgvU2REQm1Ec1lyK21hNFErUWhsWlhuSTJXcVdjVmlOTVVYSlM5UmQ3RSt0Z2JUS1dKZ2tvT0hIYzZpSGFteUV2Qkx3bEFJRmZWZDA2L2NjYVY0cTBxd3hsekJBOUJra2VzVzlBbkZtdDVqZ0p2YkduUXdoaXh2ZUdaSE9IRlJIRzFJKy9WVllqSTBPYUVZRjJ5WnQ5S2U5VmNkeTJhVFhiaXpWcy9JQm1LZnpZUG5TbWJLL0wvZ3BJcGw0OEtxcDRVODJhSFhWV3lXbHcyK1dPMG50T1ZDRithQS8xT3E5YjhvcnBycWw4N09zM1h0WEExREVkemNaRmVpMytlMmRQalBUR016WEpCeWFmb3J2ZU1VZHJhRkZkN2VXZkpqWXBxYXFmVWtrbWlUWXFzTDRqWnBnT2lwZGt4K2RUVkRValBwaWkxb1Y2U3hGRVNOM2Y2RXppYmxIY1g0S25VR3Fsdm5TMU9PR0FKbDdkWFg3b1J5QjBmMVEwcDNkUHdQbFVyYjJ2MUlGc04zelozTnZ6b0xvczl0cjl0MFkxZkVTbkJRdkpyNjNoOTVkSmZnSlJXajRLWWxkUVVPZXNIUEIvRVZDMFhBUVZrMUROWndIY1paMEhLYmpuenY3dExVK2UrNDNYMUdjS1hZc0NRSW0wby9jWDZ6c1VUT2NkeU9oNkUvaHFqOFhvSlFYVVJ0NXVIVGpzUHI5LzVMbUErVzJQSWdBMmZBOEdpVUwxZGhQSHYwUm81OUZVRHl4RXRqUm9KcHlSNExmU3pWc2thU0djaE5EclJZcEdTSUV3cmZZVHcvUWFialJuUklNZjJFWC9zRTJkZHBrRnlhSGRnMFRVSFdaRHpLbmxJZStGZ3U5ckJHNXExOUs0citsc29XTnRFdWxFcTAxVFNIUW1MYzR6c3IrUnYwbTFFcEJUL1dHTVZKa1RGWDJSQnZKeW9FK0owR1RiK3gvUHN0eHBLdkp4T2piNWFpSk5aTE5xYmRxZkZpbVJnMklEYk1rbGdxczVPSEZZUDMvTGJrTnlVcU5CTFNLSWNnb0JJZndhRlllQnh5K2FzVXhRRXhYaU00NkFXTW5Mbk5UVGFLTjlMcnZnZUxMYWZjQjZuVFFxRHlJOHZ5bFhGdGMydGVrOGQ1Sk9qcittc3NlTEJYaVQybDd4Y1pUOEs0VnZSMFdvcjZOY2FKNTB3c0ltV3pvNnUvRTA2TzJJQ2FrMnNCdkJ6WDhMcDZXejNodXJSRko1VVZHZGVETnVzbzdaOEJvV3VXVTlvUmhjaU9XWjFZSzJ6d2VMNGZxMkIrdm1QN25LT2hyTC90RHZvUitOU1BxVHJXblNMNE4vdWdhWW51WmZ3S1M0VzlNMVZBYkdhVDZqMktGS2toVDVSbUNMaFBPYmxhLzl2d1BtaXNNSDllZi9YUEJZZnE0MXEyQ3E0bm94TzU1V09iaXJnY01veXdRdHlobkR0RFYydUxiQWdvekJKaWFxbWRoK0lBYTlUZEEvOVhDSUEzRHc4YUhCOSs2VVBwNEh4eDRoYThoOWN3cUc2N1lvZG5pKzBFQS9YY0xEZnFxK1VWMjJ1U2pteXJqeVJCV1ZVQlpHc1p0MEdVT3Y3ZUtzMk13T1VVdUs4ZTJPbU5UYXJTVTNhY2dlTmpITXczT2tUUWRvd1lTV2pBekIxNVBHN1Y0VkxtZE5EUS92Mmsra3ZEOXJCWXNnRFdrR0haZk1rNmFSTDNBRTJTV3MyeG9KWlViTFFSNHBueHBWTXpFK2dONXpwRy9xU0gycVN3MlJwZzQvNFU0aFh0OFJ4TjlWU1RoclJZYVp0eFgzOUc2TStwaHVoT3FhV0NyeENkTzltUFRON2gyVjBacnQweU9vR1dQLzlBVFYvc01oTDlmcitwR005bnJjOVY4U0lMVmp6TFFJemJMU29nZWhSN3Q5ME4zQklXUkJmRitIMllXTkpXWHFKU3BGMm5RUWUzZ015M3pUbmZhMDQyRHNKUURQT3R3bWZBRXowYmtweUFoTVpHcWs1ZS9KcUV0QmVEYkovYWdnajFoWjU2dWhaOE1SMTFEanVGUStxNFE1MGFJb3lmMVE0YVFyNjkrbVdwVmZ6YXQ5cDUrMFpSNmJ2R29ab1NaVVhXbWhCYXRubWdOZkV1VGNOeWpWY1lwMVlpZ3RWVlVkc3VnNTc4WEJIanRGVmgvcXE3UDZWT3pxTDRYVXp3SnBveW8rckl1Y3lqcmc4VWF0blUzTU12TFN4b3NJVDJ0SG5ZZCt2UzY4OTVKVS9HTW54UGZyMWM4RkM2eXgybm95WjhEcU5PVTdIYWhBVkpYRWtHT216Si9qQ1FkWkxhT3FLc0YzRnZOanhpcUlPQkJrZnBaeGE1dmUwb2NpN0VkMHJCTTFkZGJ4eGRMRHJSS1ByYXZsb1kxVG5GeHJLSWVyWkR4VjhCUVJ0YUFRMngzdXN4RjRyZlRRNy8xWWRYbXB1ZmR5K01aSmQrUzRCOENxQXQ3Nm92bVNtZ0g2WnRzeVRjdExYMzAwWDFpK25MSFF5ZVBrRWV0RVRKR0J4QVUvSTg3SmN4UklMNS9ZM2sxY2FCOXJXMkozNnhJcGdZWEZadTh1N1REUUtCUjFmNGRyak8rUlVjZXVjakR0Q0xwSytWTEo5S0JmOHkyRHVsZDBHZ1VBR20rK0NGTnpaVXhYVTNaUGRXcm9vejEyNFlEQ3ZOTUxDbW0vK1Jsc1U4UXBNb1dRQ1p6RFNtQk5vd0ZtdUk0eVdvWGp4dURSZm04SEUrTWdFT1lOUk9ZaVd6VVV3ejdKZVpaaGpFN0NPVGJydmp4Zjdub3BJenJwUXpVMUdvWG9oVi8rSGhsVVFTUDZrUndqOXZxKzBzMk4xTDBha1JUUjhkWXdRang1YkJpUEFWbjVlS0hMNnRWNDdNTTBOUkxPdm4wZHRERjAvT1VwcmtRSjNJenVyaitlRmdqN2pSa3B2YVpHWFpWUy8rdXhuaXhxaGJ2YUhodFRCWjVtV3F6OGRCUEtrQnFTaTZWVElGS2J1dG1zM2I1UFhvWVVscWQ3OVJNb0h2OVVlN3Zjc1NrdUY0TU5oYlNyUGdOcmtLbXlPK0s0WC9VOWZVclRwWnZQVFBsMjd3Vis3MEtpWUhmUDBIQWUrRUFHYS95Y3BUNnM0bEZlMW5nZk8zWWRQQkUwMWNMYVFIOGVPYzZyL1Zvdm1sR1dYbGFMdnZDbWp4Y0E0MDdTS3F5ejVybzdVaGZndzF5eGEyRFcvMmMxeWdBNDNSaHp3djlYT2FSMzNkdnhXL2RYaGREd0VUMURrMnYyYkFXbE1ZUExCTUNQVHJBcUlMY1ZiRTY0ZFh1NXJxTTM3QVRma2hBRDRpY3gyMXdhSDl5Z0ZWZnBhY0N4RmVPUUVtbnFPVkFBeDl3RWhSWXBEdEIzWFErbVFCMjdTdmhPMndvVW03VTRFZDlKcUM5M29MVWd0ZWhmMWJneGJUV1FsNitvMmwxbUVJcC9QbGVrYzY2MS9yaGhOSUdLblN4Smd6LzRnOW5IM29kUUJ2OUM4YzJLcjlzcmE2ekE2c2pLdzhCdWFvbGlsUSt3YW9rTlZKRE9QSWJXdkE1SFJQNll5VDY2VkJGamE2MUV1QWxEVlVSMlNNZnBiRzdFVlhheHFyWXpaQThNT1ZtYlo4bXVtRlRlWXVQSVVXeitiSWpMQnViRjQ3M2puMFJHUk1tUVcvSkxGbWFIeW5MY3RsSlZUVERiNnpYajFvWVVvVHFnR3NYaitxUDNna1d4K3RROXJYbGJ4Q2VQOEQ2dysrREc3U0ZSdFg1SXpoOUdrMnZYQ1FvWnUyeUVWSzJCSkFSRGp4NWoyOEt3QmtnZHExbmtVejJCK1ZIZjF1RkIzSldqeC92Y0NLTktrQklFblJ6YzFVMmpOQ2lublhPaE9QdmFrdTNidWcvVW9vaUxlQmt2L3BaOEFvSDF2dEhLUW5OR1kwRWU5QzhlcEdqc3NpM3FPNmlzVnRXTnBCckZjS2x5UUxQSWxFbmNtbktBVHJTRXozdDhOK2NZTXMwMWJRajhxVUs3ZWUxV25vRVE1V3oybU9OUDBDV05DKzZhTkRKbnFBd1E2cjV3LzBMUFFuWmh5SFdUTldYYTc3eGlkUVpDTHN6NFJrZU0vOTg0bmxSUWFEWUFVVjNybFlpWGNMUUhNNEFBQ0FBU1VSQlZDYXFSSnNWd0NQQ1pnT28rQnVQTkg0NGhjOG92N09FU05PU3FDdkdaNStwNW5NZ2MrSEkxWE5oR3NVaFBXOEdudTRYUkpyZUpUNGNudW1GY2hHakxmbzdYNGRPdlNyN0pYYUtWdkVHUTVSUjd1aUE1cXBMWmlhQzZVOEEyOGxES3ZmbCt2NWwveHg4RTdCd3ZIQnQrR21BRm40WVVodXljRFpCdlFRNW5VOHBWOEdYNEdmNDR6UWtQRkdhWUtLb08rQklremltamFqOGx2V09MeWMxZzV4OGxQelpxQlFsWVVqMFc2Sm53SXJEQVNJcVEvczUyeVZFR1FuRFFVUm1Fb3hxT3FyMG5LT213SC8yeVpWUXRtekUwbjMvMGJlUC9qckZLSkJGNHh2TFVnNTI3MXdiWnpXRzMwTGpsNkFIbjZUbmprSmFuTUQ3aTR3ZjZncks3MGovOVZuZy9reVhNZjN6ek92R2FURVZTMHRKRStmWmJPTURGMjU2QTdOZ0c5V1pGZzlKcEg3aldES2ZjeWVXdGdRa1grdXdRdTdGWTBuUkdhRjJzL1E2S2xPYXgzU1FETC94VWU3clo2QXBDWGVpZ2FlTUNTNFBjWVZmZ2dXUHlKWTk2T2NSdnErUlI2TzZUM3NnRWsvbmpMMXRHSWxhYlRiY3U0Vlk1OEV2QzFUS3REaUc4STZ3RncrcDlZZDd3ZDlJbmhBV2Y3OS9tc3B6dzZicWh0ZVBkRDZnc1ZGa2tISTFlQ3pvd2N6bkZJLzlPV3lRSHU3cEcrQ3hXRjVIV1AzbHZraGY3RFphNXQydkdUOUppU3lnZjNaMmxIdVJreTRFZXVvTUJRZkhmQXJyL0gvc2MvQ1NJcnlicUNBL1NBRVcwdUJZTVNqSEYyUWxTNlA2elNpVjErcENkUXRhVXZ1M2thU1NUdHhnUlNER0ZHVzhDL28wa2ttK1RPb1YwNWkvWmRaTmJXNjQweWZxaHNWVkRWZGorT3M4d3BmZ0R2TmZJZXYzMURDUllBWDdDWCsyUFA4TUdPWitXbEpyMGFydEVCVlk5VXpuc1Y4QW13WFJqUzM2VDluVi8raC81V1NhZzFGMEhXV2orcWJhbkpualc0YmdOUEtIaHpDdWRNS3RubTRwN0YxWE9vVHBSa2x6eENtNWJKWjdmQUIrWXZ3T3dEZ3VBTVFjZzlWNXhRNjJZZmVaTzIyUEhzQ3M1K3J0aFRCSjh5ZlBMbC9wSDV3ZndHOFFjL1NKdVB6Z3VtT3pGZkZERVhBNFFBNGpnY3NNZUZURjA1Sm8zL0tUWEdzUmpDT3NQaVRYSmcwWTZST0VQanpGUUY5VTZ4NEZHYkJIMmt6SDZ6RG40ZnJsWFQwcmYvN3ZpZDlTTGFyUjNHVnBQKzFhSE1jSXNzZFRhMndIdlY3aHJsaXRydlpQK3NZazUzYUNaNUtFdjBWOTluVTJYd0dWVkYyNHczTkhRL1BuTDQ1bU9uTEhGUTU1RytvWHpZTlFVY2dWY2NPQVdOS0cyZDFFOHM1aTlhcDBNWmc5eEIvRy9qMnFUd2RXTjRMbnMyMVBlTS9KREo4aEd1eXZyTWE4YUc5Y3MzRDU1a3ZxNkJyN0tTOHBSa0ZKbjk3eEd3bURLdEQrZ21jQ3Z6WjZlSFkrck1meG1ENjhEdXBwYXdXUEpENE42UGpURWNwRWw2S1pteHYvbU8rdmt4TVZOSG9tMHZrd1g2cGRJZzZEc2FJNHh6Y1VaSjh5RWpVaUpXR2FzQjlISmRQSUhDdDJPRkk0aSt4bWNIRW53enkxMzlrOG9oRnZXQ05uR2ZWSEl5ckpjWGk2OUxYaGVSZU5veTRHazN0SjA0TzJQSHkxV2ZRSGRrUURWdkVmYVJ3MU9La21pNVd0dFVUbVNEbE5heWMwTFdQZFZMNEw2dElVVzhYck1IeG81NWNJeGViL2hsOGVxeDEwb1JLd1p2MzN1eU1kY1l4YlduN1lpbGw4MkU5ZmJlTy9obk1jQ1ZvMmJHYlpjYWlqRk1hUnJ3dlp3a2gzWWxTblNqZHNsMVVLcTgwakE5Qm4xU2p1VEdDWGpxYk5GSE9Qank2MlZFTG5LOEt4T3JQc2RBbjZxN2t5enM3MHY4R0dBVXZ2Q3A3RTY1aVpoazBKYmhyb05RWHA1L0Z4bmZpRlM3YjhBNHpQWjJSNXJxRnJtSUJjY1lxSlBYOC9oU2xTcTFDblRRa0xqaXcrbTdySzNJeFJxN3o1NEw0c2MvMDhzZUxBMkk1T3QvZS9YSE1QYm44MlNocWlLai9ZbkpDeWkySzB3akhxMGpSTjJWZVM3M0JwMjJLTjA3NUhQL1dRWGk5N0ZpS0NjV2d5U01NMHRjV2MwemlldGlKbTRZNUVHL01keEZ0Y1pDWUtpQ0dCNGNhZFhFVUZpYUZpVG5VNml3R1Qwa3lURFlUbE9Kb1loaXF4RzkrZ2FjZTNTQzhvZnUyNHhoOXlaWDZiQzZaSFYybm5obURxOHNLRzcwSUZnUXFxYW5Vb0NBTzJXQXVyaDd4KzlDb01VeC9jSUVqdE4wTGt0WXJRd0VwUE1FY1RPMjBFaWFac2xPUFJLTVJQSVF2b3ZvaGpSZm10WjV2N3ZlNE1MNnlZcTlrRzQxaTRkMWZoamQ4NFl4NGpOMzgyalg2RnJWTHhldEtNazVGMDRvMW0rN0gvVXFXNTZQWThDZE1Yb1AwdmZlTi9uL3JrWkxlOTN6RDRHejM3WHFIejBTVEV2L3h5VkpSVW9PUWpDY0hKTzZkdlJEUVRCS1d5S0hYQmJEOUdvOVk3ZWhGZ3BKcnVmT056aC83T1RWVE9MVDNJLzJYbGNja09vZWQvZnV5Z21FZUVXTFV1Sit0SWhHdytaT3hHc21MaVFCU1phUmo2a3JZdkdWWks0UnR6Z0hnVVVhQkVJNEFCNkwwNE1hcTEzdkhtRDVxaUZOM2QyT3RDNFUrRGNhZ2VmK0hIa0RqaS9iNmZXSmIxT2E0TXRCQ3IvbWMzZ2s3UzdPdmg1MnlYM3ZwUithSzc5QlRWbGppUVAreS9lRGN5TEEra1Fob2d5Y1FDUWVRdkJDbkt1RVcxTUlxUnIvQ0orU29Qc244ay9OQ3NHTGtQZ2kyQlZYT3BKKzJJTmJIZGp0L2lMQ0podW84d0hlYVlocGxPOW9aK3ptbjRzbVdlT3NLRVBEYWdnSnNNeU4vMFBEbTQwakswWmptN1pUR3FDZExzcXdINURaVmx3bkVrcVNYOG5sNkFsRlNsd0cvNVFCbHMwTWQrTkxQREpGWEpNVFhRTHIrMXBvK3kreUNVcWlFU2VsNXBybGtXbzhzc1JiaTZJR2NSU3YxdG9uQ09ibDlQSHlzTnBRdkd6MzhYMFRsRUJ2ZkhXS1k5K2c5ak1SNlRjVWp5QWVnZkJIbzNLTDFnVE84QVRVWmlpajFwUDBsSjZkZlFWOEtuSEVBa1BzWjMveHZOeENRNUZwTHpONDJvTkwwTjg2Mkg1M3hDS2NKb3NObmRxQlozRDhiUXlVTUcvWU9WS1dWc0VFblRZNGRtcE55V3NVem94ZndtMUlhaHNvUWo5MWpJOFF5eGc5c3o0S21Fbzc0TFRIY0JCdjJ6amxhamRDV1YyckEzUVFTbmRFU1NaaFNjRGhuQkRYcm9ZMXp1eHFzNVpGQngvOW4yd3g5V00zOWIxcjhueWwyR1Y3NHlldGExdER4STg5WFFLTk42Z0lsbEQydkw2Q2NxVFUzbjEzMCtNT3E3TzVEYmFYellvSXZtci9SWHRvYjRyTUs1ZVNnWFFjUzBSbGtkWXMrVkdXa2pVV1Jza2FIUVBpVXhYWWMxcERLZUUrQk9uU3ZwQzhEWklQdmI3QUhwVXdMcFpUVlVnVm45bmMzVHNObDRoMGZUaXZsZ3hFVlQ1OG9UMzFnb0cwelNSeTZudHNueHZkemF6d3gzbUhMRUlWeHpzL1VJWnhObzFuV0FyTWl0WmtER2N3NGdUbVRCV3gvbzRqMk1IQXUwSllzMEgrQ1FraGJPSW92bVEwb1E5aGdONDFrR0trWWl0UkNlNlgwV3I4VHhjV1JGaGpwTTQ4RHl4dXZpSDlKRTBXNWlRRWhiUnpxMUlBMWZsaDQvZW5iOGtINk1iL2x1cVRPTTlPSHBYU1FqZlNtTG5WNElSSU5WYnBGTCtMZ2RoN251VERnRVJnSmJKeEpqRXloU01JVFhaajlYVmNxcUtZRzZhaFczZ2VuYVE4REhMVXBLZjFITVJNaU5zWmdNRHFPcWtuSFpMYU82SnhXNzZ1cUVodGNsRU04Y0ZmbVRUMndRSWoyako3N2x2eVJKU0x6MWR4VVBqS3BoVWRraDRtdHhmZmZ4Zm5XRE5CQ28yd3hzTkdieEE5OUQwcXhwYnpBSjU4TU1wdGV1VjQ5UmlkM0V4NlpQMDZ2cGFpTDd2THZCWHVobEJITE1xazVYaFIxU2xKdndoSlNBU1k3Tm5FOG9kZUFrZ24xZ0d5UDFnQW50ajBhUlhaeVdRU1VSRElyd1V6dVdrYmpJcFhOZFI3Z3ZmaDJFelZObXNVeUxEdzM0WVZOM0lvMm5TTkxjTzBrRmZqL21DUWRaN2Zadk1Ud2RqbFFCVjdMSnZBVlg4bUNVaVFHcm9NSnR3bEh1K08wS0VaRWl5RXFVNFI5dzcwWVZvZkdtb0dCNzJmRVdPY0d0dElVaVM4NGtKNTBZb3BnMGxDUnI5RWo5S0N2M09GODUrVlBULzlMT29pM0NweWE4VkJaMmp6UnBiL2lXajZWZHAvUlFEUCtPbzYrWXVhdTdkYWdaNkpxK2xKK2tQTlBWYk5mTDAvL2xucUVQUE02elFNL2svS0Q3TEhkZElJTHNuT3E4cWxhQVJBcjU3cDc2THJNL09WL1ljOU9zdUdrVW1UVDlCUUduL2M3KzJqcWY2UTNEYVlNYXp2VGpGdFlUNHo4ZTlMT3l4QjJtWFZqTWNQWDBKVk1yMHR5Tngvcm1tVFFtVkJxa0pCekN5aVJYZ2RWNnRuczJTdVNSajNjcTc4eU5vOXZlb0tnQ1BIMHlLbThyQk10K3JzVUJ5NTgrd1l6K2p0dWNtRytiRUp1MkltMEpHQTd4R1RaTTFKMmN2eCtlTEZ4cmxMcDhtU00rN0F2TEZ4aXFMRFpiaGxUU2duNXlnQURmejZkLzZQNFF6SXpEdDA1Z3MvcFJNU1JzcXJHNmVVcHN6Z2RXbVRGT05WWEZzelM5UXRtb2l1bXRTMWNmZXQvS1NuTzVCanFzbFVyWFcycXQvaUZ5amRmS2ZwblYvMHc4Z1Q5Sk9PUFF3THhmajkyTmhhSzNNWWFIbFRlcVNhTnM2NmxQSG4wNGRyS1dyUU5vb2VOMnhtb0J4cG90Y1NTcHIydUo2c0U2QVhJa3Vwb05IZlFaOWZOL05FbGphUHFNSXlGZVRVc3dKd0RCRmdGUHZHaWZPdDhKMG1pbGVZWDBZRFFKTnl2TWVSWXgxSCsxMjJQTnRaUTNlWUxOMldIZXlCM3ZVWndab0o4cEJPZHpodG1zREVlRUQ1bHFzTFViM1k3SVVOc2tPQndwUEpSY1NsSHM0bFkvbmd6VnJCRGJIWHJJTGFMY2ovbDF1SlgzRVVEVENXQkQrTUpDZHBOZkZVelg0eVR0amx6aXQ1bGllWnJxcVBhQVRYaEdYMHlEaWp4bHY2ekQ3TUJ4NUY2N2pLTFRzMGRJVXk2ai9zN21KUTk5aVN5d2Q1Ynh0ZUxGVVV1UHZYbS94bkxkWUZzd1FGT0dDL01BMlNjSnhIV0prMTQ4a1crSHJUTzlTa0hoeTRna2tpU2lhWVJuemFxZFhXQms1WVVnSWE5NmhvY0ZvcWYyQW9EaFVlUUtOeUpNWEwwcVNrZU9YRHUrdVJoK3YvUUgyVmgrYUFEREJJUlFOY0lveStKeVN3RjBPZlRqQzBnMk9JU1VuMjhtNElROWsvNFBrU3VVRU5BTFc1Z0lXNmZJcXI0UnVabTZGOHd6a0crNkpyOWY5c3hMQmgvRTZudjFYTUZkcnZsOGpMbTRCM3o5NU5va3c5UTVJT1hUTldUNnVKQjIrYVBnU3Nycjdma2lOdDQ3VnNyYXFMak9YNXBzU3ZLUXNnTDk5c1dmSmFoOUVWbCtJbyt1bnB3SldCQTRxZ2JEQVJ2ZjZmVFlzcjh0S0VFZEJTQlYxY0x5TFhNM3gxV2ZRVDVQVkpVeDVuekYrd1UyOUYvNHpRM0dLd0FyWEo4Vk5idFV6WmU2V0NlcFZrb2JFT1crTmN4TG45dU05QmFDc1UxOFFmZDBDNkpZcFdLdkhIWkhWUklpZzUrOTFnKzFyZkFRUCtlZ3Q1K3pWR0lQYWVvTmZ1bXl6VjdaTFFlcGpBcUtIT0w5ZlR5ZERoMXpjOE9jS1RGRzJDa0pYejI3bERRd0VxbUlobjVlMEVRenRCU1FlVENtUFE1V0RGWVpZMk1ibEFOcExHMnZyK1hHSnNqRGNLTmhEdHFSbTNtaitKaFI4QTcyaDlBYVk5UlV0VTFhQmxQSnIrZlRjamNVdHBWREgvZkl5M09YckFib2pxcnBwMVlyWG52cXB2eWxWcFJPem5kWnRVcm9XblFOcjhvZG1salJyRXVtbzJha3JEZW5BUm41U09Xb0sxSEJtd1BjeHZoZ1JRQ1R0cjVRQnpKdWdiNHQzMkJoajdkM1ErVyszMEhDVVJxOHpZZ3VlL0xjbmhwaU8ySEpSVGZHOWlvTzBXVjJQNXVJUnAwcms4NGYrbnpVSWFubTB0cnZjckVTakU5N3ZnSVhDN1Nva284ZmhJRnZsYlc1LzlsQnErR3g3bVQwUXNHaDczWmU3dVVqaDdSeVk5QUs3dWFvS1JXeERsK2hrU0N5d0llRjROTnM5VzMxWVpvWk1BU2Y5RWo2MlJsRDVDTzhYM2ZEWW9HV1FScnEzRDZ2S1dqNFN1SnkxUjhUOFc3bVVxakVEOEhlTmVUS1JUUEw2bU5zc0s1dnFhMlFxdXFWTGNId1hzQkhDYlkwanZwSUQxT2UvekU3QkQwMHYzMExIU1p6QkJxZnFhU3lBVmI3UVNyai9oa3lsWkJNVXRPSFVmWHI3WVpDQjl3LzBncTVtMjFmUjVCRmJzNUZLY2FIdkEzOTA5Ty9OYW5rSmRaSi9MKzk3NGZYenN4WkFRanZhZmw4dm92bjNYSlBmWFFxWnAvMjBnK0tqQSt4UjBGcC9nbDhzMjR2a0UxdGgxUTJwRjlNOGpZSDhFVVhMaUZlMStMamwwVWVYWEVsVXJMN05HWGR5VUVlcGdkQ2QrSlZSbldNU0pMcThpV1Z2cGoxYm01dWVOZ0RmdjZxRTJraHExR0pBNVMyZXg0dEIzOFptV3dZN3dyOWpCSlRQQW04ampFMSs5VkpBWFpOcjduQ1kzYk1OMFVDRGcvZDd1N0NGejJLVktWdFNmR2xQeG1EV3k1V09SdFNoYmNwb0tQclQvRzRJUWE5aVRyemV2ZDdYMmZHL05sYWxWWUV2eVZKT2hGWHF0K1VNV0ljWVVQWm1vRnBLUjkwWE9rYkJIWG9aVFM2bFRUbjJPaWozdVZyeExJUWxqbWxJYTVrRy9uVW5sYlFVQ2IyM0c5b3BGcmZBd292NmZFUU96YllxQVg5M05Wa05FNjRxRjBnQ1JFSHJ4NitYUGNpdTRVUC8yTmI4Vnd4QUhZbXdMSldCcjdQeWlyRUdaWFJtdk1FNk9DMWVsaDFtVVRaZmp2MStXN2dVaVYxZlNyUnhVRW5ScVBYWnEvQmFEclhqcXBDRFJYVytpb1VqT1kwR01rV1lSZDlib1ZpdzhxeTVsNTh1ZHZGQzdVRWdpM3Z3RGJ4UDcyeDlEUGR3b2dlQjBERzdLdFZ4R3c0eC84RHpLaW1mYS84MExPYUxTSnl2cUFnU0xNaW8velhIS093bmJBNW1wazlRb2EyTTA2a1QwM21CTFRRRFVRSjdOd3lZcFVlRzFRREk3cldFZ2MxZHpUWlZ4bW5SeldDMithN3gwS3JrK0tHYjNaSUpJN3JUa05vRm5oVlZ0d3V2UWdnbS9XSFdTV3JYLzY3c3YvZHpYTmdUQk9pTzhHRlJJMXNHWFdDTlJmak5Jayt4cXJtaWxoK014N1FNSXNWVVIxYkxYTGZrRDk4V21MVnRCRTNBODBLWUtZbU9iMUFUSW52WVJGa2kraHQ3TkF3ajduOVdhRlZCelUwZmNhWk9pVU9uMTFrMEhXbkhOcHFwa2pvTGtlMGtXUnNWUERNOG9Tam1UaWZYYVdCSnJtOUpBUmJ3ZjN3bU1rRytmNkoyeVFIVDVWU0JOZWJ5RzU3ano4aW44MnduZjJZSitFcUJJTVFncitOZXEzck9JcWUyQisrcEtjN2lnajNsaG9zSWxnRGdHbWFncmtjdy85QTZSdjBpVGtIeGtaRTZ5Q2VaODZuVnZoaEtGSHh2ckZ5ZXJiMW5NRkRZYVJXeDUyMFByeENGQTZIdXprb1VFWDlJSWVwMmFzZHRjQmpid2l0YW5mUWxGemJFNmJzeVBJOC9aa3hnYTZnZ1hHdWxrdTZ1THNHcmJ4dzNDWjg2SzRKVnNQMGM3NXBGQkRoMDJJV01EVjBzNkp2bWZvMGtvRHRaWXRtYXAxc3A0T0xLWFI5Y08wM2ZmYkdveWk3d1pVMjY3MDM2Tjh0aVhLZlNScXA4a21DcGJLbVpWK25WQnFXZXFJZHpVQ2tEc3FHNnpzYTZ6d3FSaWlFYzFZYUFqMHBXYW9CdVJvbU83SEhzZXVSTkVOQzlkaHlRa0pSRnljM0w5dmgvRWIwb014bHBIRUo3NGw4Sm5oWUpOSllEbWV6RGNwcHdCQm4xaDlvSWMrN2F1Y0Z1bWVIZHg3eG9UMGdScWlsUk1UMGx0eWtuOWs2eEIwVWE3eUFZL3FyU2dMQzlkbWxmRnptcXA0QlBBK3VsUVE1d3B5VjNFdG5XWFJ1VXk0c1I5TU92bWxlVXJWb3RsRThsRk1HR2xlUHVRU2JqYzJqN0xEaXkvQVI3c3ZpU0l6UUl0RnBCaHpSNmdDUE1uREp1T2RSL0dpY2NEakhuWkJhMUFBd1Q2TFA5Y2ZmdlA2dDhhUktjSE5kZkpGcitWWU9yb1FnTll2Mnk5cDByUXVjOUppcGhjd2srSzRXaFBURDhFcnJhTmxETjk5c0M0M3V0SUs3TVkvZGNjSEtINUhkempnMEsrNnRMQWM3VUphV1MrKzArT3E4ZEJmZWR4KzM2TFhMdmpaMEdadGx6N3R6NzlKTHh0ODdiNWlXMVlGM042d1lmKy9senBMcDcwY0JGZHUxcXdydmRLZlNtOG00NktVU2c1MXpyck1EMldBL3R1aEx6d3VacGZCcGNRNFRzcGRtVWtaR3hyYTA1Zkw0SGxVRmNPblBXYWt0KzJyakVPTkgxYkZIcXVqT2RBZkxXakFlYnlROHhZbTB2c1VIaTd0OFdSZ29qOGlTaGlad01NVmk4cGdYL2d5UHFXODR0M0U5VUVBMnJuZjBUakFJZllGQmgyT056YjhhSUJlR1p0TXNkK21yaEYzc3QrVm1CbGJSQ3l5bXd1Ymp2czY5RmNidGpkUEU0aStwK1BiV2dGRlpSVzRmL0FvenpMRUwxZWpuTEZrUGMvaDVWTUpUUHMxdWY1aUVydTVkZjl4Z2V0Tkd2d3VueEtpaW5zclc5aS9qZUJFSzdsa1FNd3dLa3VsZnVFUW5OUTZyNDhLcldxWmREenpsNzZCT0NtK3I3aXpyQTNJa2Y0c0kycGUvdERNdnpGT1k2TUt3TVhiRExCYjlrMm5pWFBCV2pOVVZRaXFuVFZuRlludWwzR250b3ZkRWRWT3A1Y2dMU2U4OG8vOEFkd0tqNDl1cnNSL1ZVWTVNemFnSnpkQStOTjgzWStXUjNuSlhzVmhTK2FsenZkNi9Va1N2bC9PQmVoZUY3VENIQ3VFd29mbjhNQ01WcjRlaUZDRFozSFY0RVNCY29sSEgva3h4VUZ6UkFrZnZHaHF6QW1aSlhTTTZvc1Z2QmxCR2FJeDErUk40cmZnQWdkUWJoeFpXUVZvWnFOUldWRmJoMFF2cVpRVjlLY1dVbXBvY20xU1BDdmp4MkJEdXJKR2R5ODNVekJWMTF2RlZ3SzZ6dE5jYmpHSGFPbHlYOE85ZHVDdFZvSy9yZmJvTXdZTjdEZm5BNnJxRnF1VVdhdjZtdmtucCtqNlorbWtjZHhhejBrVWNudjU3TjBCRlA5TjdxdDg5UUhNKzNMRjI3TFZDZEcwZ1JpL1RqcXFLZDFUSkV4T2pYM2EyRzhmVDR6Q002RENoZGZ5QTNhWDNDUDFIcFpnSDBTY1VpTjI1RUdmc01PbXlVZ3YzVGFoN1l6OWVyLzhibTlWZlVuMW5FTkJFSUYzRE9NejVqbFZLcnhYTzk3MEJVVlo4bzdxZHV2ZHpxRHRqQldlZGpzc0luT2hIN29TeHAzdlc5OWpPb2pqSDZVN24zbHRBL0hFZUh2b0tkL3JhZ0N6V2xyVXBhcEpYcmRRQVZPUnBOb0dpb1pLQzQxK1RYRlVlenF6TXB5Vm5oVzlOZ2RDY0VqVG5vZnhIVTc1bkRRYytMdjFhVG9mOW9WWEduN2tYVTgwVmRWMUJnZGp3QkI0TnIxUnB0MzY0WXc3QVlGb2FBcjRaU01SNXFmOHdiNi9zTUdYWW5teG1TTVZDTzYxVTFXNFBBWnJFS1F6UDNDa0VuRUMyYlZRUEJCcXBpV2MzNU9JMlZXTi9oakM5azI3NjV4Vlc4ZjRJaXZ4NWJtVEpjL0Nzb3FieFIzYXhyamNLVWYrZWI2ZGVEc3Q1Y3g0YmMvdjdmaWRZZUh2MjAvYjN2T2MzL1hNaWxmeC82WFNOUnl1M1I0RFR3N050RVpPemZyNnRuZWFDMlMvVzlpMTAwNkZEdnF2N2NvU0dLUEJ5bU9OR3FtbDJxNkhpODFMMFExb1BSeWV6NzgzY1dtdVdMbWJKQk1Eam03REhGN2VVMFR6bzZmVDVqL1BBZlczUWdMbEcvOXlWakpGajhmMDJ5djRaUFNnM0JiS3IvQzhsRW1mKzhhN3k3RDlUaWs3L0dUQjNvRFQ2UTVZQ3k3S3lQeTl4c1BwU1RKVFVIUzZhcmZxMXFiRFBFaDYrSDVQUHNhc2ZjQ2N5eGRPZHozYlN1YWtNZktKcFpXekgxaGM1Y1JJUlhTUXl2YVpsK3JUNUE2QmN5V3M0bDkyVWJKcjRuWHVwajIwV0NueW92Wmowc1dlUHdPR256ZzdwbW5KSEpJQWsvVGFKVUJTdGN2b2I5R002NW1Oakt2aVRoSlYvaVUxWElsUkd0MUthK1RwdmhrYzJpVlgzU0ZqamlhODh2cGZOazdHUGpldkRQRGJ5ZVpZN1RiT2dMUURmQmc2SmF6QkJMVHFITFdnT05YRjNkWmdMSU1kQzB0SVZvd0p6Q3IwQk1zOTZXRG8zak95bEptZjE4SXRtd1JuNVZqaTdwTmo4bUg2MkJiMXJtdkR5c0hXRGRzMnRyS1BCK2pHSHNYeXFGOHUwNG4rQ0lIQ1pCMHZmMUhiZHI3OVVDeGJzRmZTSFQyazRIVlViZERUNVF5WkpNODhyNmZPb2dYYVNGQUR4T3ZUSTFBcm5hSXdWUjRkUVJUNVQ3YkxFOWpCclYvWlM1alR4cjBEOTRQc1hLZDJ4Ui9TaWo5eFgwMlBlTWc5YzU3VytkME9lZmRSSTIyK0RKaGl3R3ROTE9OMHErQ2FjSG14NEozYTFoZUlIeG13QjRiUHZuS1pPSngvUDVOeCtFWXlrQU5BNzdFYzFWTWFxWUhjaWpsaTloVFE1YUQ1RERnWDRyRzVpMlJubE1FNHZhOUtqV0JqMWdUK3FLL0NVT0NuM2NGS1lGcllpZ3MvTWVyVXdMQkRPMkx5OTBQZVdBampqdW5NNjBQSFdXTDF2a1R4NnFKeVNCMXhqRFppbGV6SGtBOEcyNlFIOUR1VERWQXVFaWhuZlBKa2owbWhQOExNTlJzMTIvN3l2Zk5VemxLS0ZHQTNJT1hqWHlxWm8wcmpHYzFrQ2ZFMTlXWGcxcWtvOU5FMFJNMy9hMVhtZks4VzZkb3VOenlVMm1ZdlQ1RU1aNUVNMS9HOHkvdlU0WnlyUGxxT0VtbmIrYWlnT1QzZUtWOHJXcmJYZEVWM2lqNnFwUzlNWkhGNlpxams3cmNocE05NlV5VGNmaThoQ3YrOWxkdkI1TTMwU3h1eTMyOXpVcDhYVFYwb3hwZXFBZ3FvMFhub2xDNDN1V3hZcmhnZmMzL3FSSUkxbTZTSzNmRnZ1NWE0NDk3NUVQMkdiamZ2RFZuaXRFUlZ2VHZ5UjhlODhuK2VFZE1ESFFoRzUza1pBYjQydmV0dkNhZ1dIWWtLMTFiVGppUGwrVmcrME9JanA4ZjFqVTYyUFhXbGlDWHVmSElzWnNxRm9tSUhzSDhaRFVUWVNaQnFUeXNZY2hqUTR6RXEvZjhZeUZLQjV6aWhHMDRCeFdlV3VpYUcvVHFXWDVxd1lxUk9qL2V0dGd2RWFZTUZtRHQ5dEpsemNmZXNBOUIyRTBHUUxEZ2h4eGdXcmVUMWE3NnppM2NFYkc3RzgrK0YrMVM1TUFvY2FvU2Vlbm5Dbys3WGoyajJDaW9hUGlGb1B5ODZQOUczNE14Qm5Hb1B1OXcvdktqSU5EMFJOWEtGUndTd1g5Q1lrOEJ5bzE0RDNETmFScGtSYS9nZmZtdTZIUlVDZk5IZWliTWdsYnBNYS9pVnNVMktuQTZ4aVpRTFBXZHpacUljcVZTZ3JZNlR4d1FkTFJWbE4veEpCRTc3anlRZy9na3Y0NzNRNm1GeDJtWnhwdy9iY0JzNzZaZ3QvN1lCVTJhbmVNa3UvbmJOUTNKV1RCKzVndSsycE5ON3R4ZG9vcGpsd21Xc0RHRDNTQVNteDgrSGhiU1hOTUJxSlBoNkw5emJEeEdsV2JyYXZTT04zeHh0VExRdjczT3RRcWxJK0VuM2pmMGtOZjNqc3VYSUEvV0crWUs3bXVWZHZVTTRqQ0svRGVSV3lMS2VhYzBsWUFBcS85T2ZuZXlMNjBObGczZHYwQURNYVRDdFlhWjA4T0ZxQVRoSjMxUFlwemJTU1diTDhobWZySmhCdmI1NE9DeWZXU0hFdU9mcmZzcWljbk5VRE5PSFJ5TCtKRUx3akplM3NrTkxrU3lYV1IrcS9LYW55aG1sNkJiMTd1VXZLUTQzdm9mdDBxV3FWV1A4K3R2SU5aNFg2eG5qaHVyRnlWWWpwK1BBMEhudjUvZ2VaMks0TnM3RExtblpnRHdSSklHY3B4SDl4bGRQWVNJT1F1VFlNcThsd1A1WElsRmVWeFFLdEUySlc0bUxRemlxU2pxYjlSRFJVZStCa0JMWFBqdWlYVjJwUmtUYnFVYS82N1BQeTNWMjFVazcrdkpVYVhodnVLTVdRVGFKaDZ3T0hNUnJtUGdlcElObGVTVkVPbFFiaUxSV2gwaTJFajl1bm5lcEZzUzBEZjJUOGE0YTdETTlhWHE2L2lKT0JQWE5ueDhQWTBUMFFMOUQ4T1VTMHZoVmhaS3lKQjJBYWNyV01YcCtrY2FTKytPVThMS3NFU3l4eDNGSUpraGc4RTlNOVNOanJsR080K2luRHVYMXFob3A5YXpjMnhiaFcra0R4cFFJRWJkdFhTUStwcFNjM3BSR252emJUTGUwUGQ4UHdqRW9BdVN1bG9vTlY4RkxkbjRubDh1OXMrYmFvZmR2djIyd2RCT1Fqc2RScnN6cUwvN21OcmZwT2dwcWtZNzJUc1R3V1FqbTQwdjkycUxGdmRMbUJGT2JlMkJtWDdUOURMZVZvdXVtSDZnSlpFMkt1eWhwWm5nUERELzI5VGM1UXN2czI3Q0Zsd0FmZnYveUhnTE83QzErMzF1MnRGdXNNMGNUaGRHU0FWUDZPamg2OUs3K3Fmb1QzdkxhNlpkMm5ZODlRNTFSN0NQNUY3R0JHOTJVYmh2L3ZtRmdmaGtkeWtxMXh3dTFUWmV5WFJacXcvWmlMbnFrY3c5d3R3SFJ3V1FLY3ZLM0oxMUdBVzZnNzczOFg2bnluTU1GeXJWMU1XQThUT0JleUgrdmR2ZjdQV1YveHRpRkMyRWlmNlBvU1QzelpmT0NhUk0xbDF2RmZXcW1vWU9IdEhSQzNkM1RDTndVS1EydHVQNDR5RE4vVnFpZmNaVTc0SVBRR29pOXMrRHQxR1FxbE04UDM0Ym85WVppWjFweDR4Q2p6a2ZGbm90WHNQb3Q3M2hvNGQrZTJuYzBGNm5DVjUzUDJwb1ZYUU9mUGluVGdXNldza3ZDMjJ3ZXVvazI5dys5TFpQcExCemhUdGhDOEQxWTU4V2M2bWFoU3F4bkRLTUcybmQ3elpmN0gvMTFGTTJ4TEZzUTFGdDVUcFVJWERhOUlRYXJCbW1nb3RhVEdvZXl5Mnd6bExCNld6aEdtTXlYRDJXTEViSld1eFlmNVlhYTJianVvekFBQUlBQkpSRUZVSnhTRHpKUy8xRWYrai8vbmk3UjNic2FZajgyUGwwRkMzOHREN3FyTmVhdEp6MkVsZW81cXppZTlYWnhONlVVZU5USVNRaTdaRGh1KzExZittODd4Zk5VVGYvdVpBWFBaYmh0QnR4eU05OHNQUC82KytLY1ZhLzVuZ1pBak43cGhIM0NEMGVOU2crdHdmNmdFUFBzR0pKU2x5cjVMU0oyUjdMSzcvSGs0K2xiRW1CME1oc2cvNmVtNXZGczlyMjFQTm5nT0E2ZWh3SnRBdHp2UXB0WldaTHM4T1ArSTNQUFRpcThES1dXeGRWbitTYmR5SldQL3pGZGVnOTlYblVibzAzeHZIZUJ5UVJkbHBLY0o3YWk2eU0rQ2JoZnNtYzRFR1BkVlNxcUthNXdhQU1IYkJvdEtMdGJiQ2RacmJuK1RUaEw0NEwwclZCSVQ0bDdQajFXa3VFSXQyNThNUyt1ZHo3MnE3V1E1NGl1eHhsZWFvYnJXcm4xd3FXSmQ2VVhFVzgwdnMyaXNJaFRXNG4vMG04eUpXMjR0ZEo2MTdQemwwYSttRTYrWm1lMDJZUWdIUTBSWCs4K2xDVWpSbk1Zc2E5bTJFNUgydVBnUzh2R1dxSjdZWlpqZHhSNGlWRk8rdzUvcG96RWFadWtzNXZ4SFAwaUQzY1NtWG44YlIxM2ZJSXIwWkV3SWxyWTFVOW5XdTBORThOampNallJVkVqc1l5Wm1xTmtxbDFkNFVNMEpGNzg1MXhYNGVNOUl1S2Q1Z0ozMDhBR3BXNW42MGtVekpNK0NuOHNnL2htemw2SWVoa3pCQmtzYjcrRm1lbWJvYnhFL3FqQ1BadXdDT3FHUk1lMFRmNXB0aGx2OGFiTUdCOW5JYlpLQnhaT0VHZWd1OE5PM1pFdmZaWlZpdkQvN2lzbGo0NUxXL1dGN1pZZWwvSTlYNjhWakQ2c0xYMzVjMVhxNnBLTHRBSW8rNWtOK1hFYnpybVpOL2NWQ2JZbDZLbG5TOXRPazFnOS9RT1ZlcVhZSDJvTXJ5SU9YWStvL1BqM0YyMDZqaTZ5aGE2UWJzeHp5NWlwSTU2UGpxOW5rbENGV3YwVDFLbVNCV2NQaldXVUZMUStMT0FZcjlBcTNpVFhNWXhieXNVemZNQkUzVHhxWHFtZ2JhYVpiME5keW5pRG1USURIU04zWXo2czZHZlJieW83RUw0Y05mUFVaL05YQXYxRjF6TTkzOHpJNzlrcHhaSWo4Vi9RdmZsenNlVmZxWjgrWnNqaSsvR2RnZ1d4VHA1QTh4R0xUQTFLcTR2ZExac08xQXJadnQ5d3k1SzdYanZNbXpHZGVGVXlTSGdNL084aCtDNXA4UUtxakFHYmdqODEyWHZQNW45TnhwZUpKcjJSckNMKzVmTGNPSHFtZS8wb0xTQ3VxTE55Q1QxcXNWMHJXTGE4OVVtdUNqOTg1cFo4SWxXQ2wxU2l0SzdrUEwzK0cwSDlPcG1Od21DOWxvc2FuSVNVL3ZtOGVJeFlNelJLUlNLUXZQQkxpZzg5dWsvVXVkbW1HUjRBbndzcmxBeFduNmpDdVlZM0tpU0VocE1ITUtlcUk3NmVmRHlvU1ZsTmVpTFFPMUJ3VW5Nc0xKbGl5c21hdC9PL3lwNGRVaEV5T3dlS05qMkdVS016bnVYeDZjSURtN00yUmQ3V0liVnpQZzV5dGR6TVlJejdlamZ0ZnhwYWkyeFMzNWdRektvTHZPV0NCelpPOFdxUnVTYUhsTWJUV2VVWk5BRlUrR3RJR2w1YWtVeGJzRFhjaGtUQVBvUDJsMFRYTEFUK1lYcHJOK1hpcWxKbUpvdThtWWppMGQzYkxiZWhVdGwzdXhvUVpTRldRYW1JaFBCbXlCbmhLb3ZQVnJ5cFVxRStybFpyVGpJN1ZHZFhPS2NtOHdPb0d2djh5N2hKNDQrTlY3VStyTUZ3K1k1SEVHdG1sUDhSUGltOFpsVTkyM1JhNVFiN2NxSXFLOEUxVk9DUUR2M29pK21IbENEdWh1VU9TWnBZR3NFcy81TmgyOFhmNHlzTHVqL0J2NWlFdzViOG92cGQ2a3Q1emRqSDhTNEpHVW1VRit1MVNYOVYxMWhSWVBrbE95bzg4MzFsTnkvMnFJQkFhdUIrVUZxMWFRZ1gvem1YNldlV1dCZU01SjJDNW5aQzJmZ3krOTVLd0JwNkg2UlY4cEk4c3FvbkhxQVFxVlBCR2ZNWlpha3psVnFGL1dmcVhIVGF6OSttQlpmUWR4SWZuOWVtQTFrNzNQNDd2SjEyVE5sUjZWZ2piYStuRHIra3VMZ1R0Q1o3UkZzOGpTYlZuMElRZXJZeFY2bVA1MS85cEEvZVJ1TnJRZUM0Zy9vKy85WnFtVmNEWDhZVk9VUE9VKzJ5S3N3UGZVTGZReTlqdllveFBkdDFSTUUwandqMndUZWc2RnlDUkx5aFBBNlpvNUxHTkpQOVdQQUZNOW55aG5ZWGpmbU1hZ1l5UW9LZmpINWlUaTZSS2ZPZXptQ29pZ3IvZzQxUGUxQjNDQmVETG54WGlXVDhrZ0FSZkJTVUdhNkV5RWVUeDZVZzA2eUVSQ2hrdHFwbUxWMVhIRjV6RlZ4cHlqalN1VG93R25QZnEvRjZmNk5MWi8yZlVVRncxZ0xGbmdtS1h0LzVpbEFobmFEd3VHOEZMcWxtRmpnYUZaL2VyZXlCVktvYmpIRXZ4VStMSTJJL0ljcDFqT2gxczdCZlRQTERqV0MxV1ZyTVdQNTdCRENDVFBuaGZqWGhVNGxVMXRneFdvemhSZFl5OXZtRlU5VXM1VlNrWE13SGhFNVhMRnhYYi9HY2tla3FhT1JKczVwS1loT3JqM1FkK1VUaEQyOGNkRkNYc1VYR1FKcDhZWXJEQldxQkl6NkxIV25WWG1aSmhydUNUaEVOR1VzTnhyenJUOFBkdjhTZ00ramVTVnBEQU1DZVVLRVN1MStNSlg5NEIxQk1EcmdZeHcwc0VKVURYQm9oZlZXS1Fndzc2UEFGVnRBclJORWdONGgwS0FiblJPMyt6cEJrK2VVNlVwV21Wa1Bma25USmd1Ni8rRFh3djRBdE5hV1RnOVg5WDBTMHZRaGNqRndSaEdLZzFYUTJwcXJoSFJ2RTRkekJ1N0drc1g2R2FLUVk3UHNRMEppRmMyY2Q2TzhEZFNIcFU5c2IrMjl1QkRQVzVtdGV1L1hQb2tBZlRxZUN3bEFNaUNveG5UbTBEcDltQmRWYkx2UkNPZWp2SjFZVDUwUnpwVEU4Zi9YaXVYUCswenJyY1pUa2MrOWRyN1A4azJrNFNwSm9FUENqNGJFRzNxc3d1c0kzMDRqR09vaS80aFJjcVQ5THlVcFlkZiswNVkrTjlrQUtHejd6Rm44dVo5bmw3dWZrT1pEV2dRaEgxbC9kTHpVM1FDdkdydHpab1JmQ0wxMFJSM052MjQyay9OREVNZXRObWtLNzBFc3FuT3N0dm41TlliTVkweEZvTTh6c1NWc2dHazl0NFVNelgveGdjTW1zdk1JZVN3d1R5aldldTdSVUZuRlpnNVFKa1p3Ujg1UURjVzNmY1AxRDNyVWJJYmhrOVh6QXR4M2JTSEI0QTEzdU0ySVFtNXVPMWF2a2Rtbnl0cDZzSzczY1VoVDBUTXZVWmF0WXVBNjgxVmZtSUI5OVc2ZFFtSWFhM3hORkx5SGxLc2FVTHBhRkhNNFlPSGZ0eXZ3S3BCa0ZJVTNIKzhRKzdESGtmdEpxUDcreDBwWDdqZWRaNjZGay9qN1dQbVNjbGN4eUQ1eHlSK0I5Y2U3cmIxbWdsT3Q1ZzdNMm9ORjE3K0NESFJicm1sZkJTN3I0cjJCMjZTWWU1WGI5TFU0UXVhMkF5ekQyYlBZVGhTMVFobS8wTVdOK1ZDdUJWdTlZSEppTGlSeGdBbk01SjIwM3NNdXVnVkZTdVpJRm1sU1ZyaGViRGd5K3pRM0pmVUVrNC9pRHpheXFJWVFKdlpxSmZwUHd2bjVCKzBuaXVrSWdIbDFRZVhyaGNTWDlHQ2pCZjZwTW9kbm1YQmFxUm1vc2drby9UQWF3aEFoNXp3eVlKS2NiRHIxRllyNUcvdEE1MWVLYjFuYkVGWHcvZ0dWV2FEMFlUbmdjY2V4dGJHOWtjd005N3M2YU1zVmEvT1hiMG9Vcjl3VktTemFPaUY5ZHlwQ0c1bWRCUnpnSEtqTGJVZXZVWCswbGo0T20wWWZSbFpXR1dUOEQwbWtZdWhRczJLZ3g4R2JKNCtFNzBrandkdHk5ZTlXWTQxaVdMRzhuUXdCNjhPckZqTUUxQWhWK20relRJYTEyY1picG1JUmliRXBlM0pNUFFQTDQ3R3lLdXBDTks3aWRwWXY5QTVDdEZSRTNzMzBMQjJyU3o0ejRyY3djckNrVXJ2ajlFd2F0QkZPWHE3MVJ0OVlrQm16M0FTbk5JUm9JaXkxckIvcE1ZRzZzQm8zUllWU0ZmVWtOeThRZUYraHIzeXpSNXNYKzkza2FkVmdld3NkRCsxelRlV0R2aHZRZFh3ZTZqQ1NFSE00VWNhMnZxNjh1M29GdjY1alNaSElvOTNtWlFWKzhNWFRuTVFNd3ZBanEvUkRoWGY5Z3pPaHY5RVI2cVZkWGY2ditMSTNHNUNnS3pmdktwT0IrdC9HZGg2Ui9pOTlWYzVJT2Q1SEQrMk14aHBGcy82djZsN3NXdmxGRXMwSitMYjRZM0F0MkdKSjBYTEhtWGJGOE5pOEtkOXJSdTBsWGIvZEdZZ2twcStjQTNveWNIcFpvNzd3Nkt4djVKbzVjZFhFQmhFS0FOazN1UlhUS20xdnRFZXRKTjZYcU92cEhlblZJMFhRdFRSWUtwWVpnNnJPeWFaZ1g5TzVjWGpzNnJ5K2ZvU0JYeGFKZ0FwSVVyVFNjeVM2OWZwdGZHUDZrY1B2Z2RtTHlBb3pyTkpFMGhDV05xNTlNL2srMWhZWWhZTXpSaDdtWElhK0gzd05mVmY1S0swLzZSeXBweU9qSFNLYzdlTEZYV05FbzFONkNiSnlEVDQybkx4S3c5RHFIWFg5L2dRcnhjS3I0aHd1WFhkRm12aUtyK1BUVktkRWNOMDF2REE1S2NaakNaaTRMSllxUVh2S3VBSWw1NHZwS1BPbWNJZ1NudWRQb3JlWDRDQ3dUVG0yZlk5NFRuSXAxM2JlMEV6SndNaFVZbXpkTFBPMEdyMHJBdnlrQmZueG8wbzdPQklzTjlWRWgwZUltSCtlU1pQaDlVYlIyWU9DN2FoTmlIMjVIS2d0VW5CbXdRZVVpWEpaR0dBWFZjdVRGaldoT2ZTbTNOR1habmpkWmtidnVrYm56YU5KSkN5b2hHaWsyU0d2RWZER01yd2J1ckRTT3VJQVlOT29kWENTeTVHWmI0dGYrSy90aUZKNGdXNEM2V1BwT1RJc202MHZ0dkthNE9HSjRMajJrQVh6OWNLTG9OMTJ1WWVJSTdOUlNqYVZGaGxJVEN0R0ZNSDdmSWYxVU5IY3FFT05zZXU4SklOT3B2eUpYRGNYMDFRbExRL3E1a2JzdkxFZjFJRkRROW5ISTNCazF6R2Eyd0pXYmYybE5hbXdtTzlpcjliUjBnUTN5enYwQmY4NVZvU25qdmRGNzlsZ01GSFZVcXlTdHFxeWlSK3hLejczTG96Y2w1SXcyejM1WlFNTVRYeEV4aUZQbGtvUEF4L0luZ2t2c3V6aEI2RFRXZUFDanlPWGlPbkkyMVJodGtMNm1GU2NtR29URUxoVk5JKzNSTHZjVk5VZzBhbTgrVy83UXd4NTI4SHFQeStjQy9EaEp0T254Mlc3ckVnNjNEUks0Z2hCbFZpM2hwbHAzZE1wcUY4clo1TmJMNThkV1VBc01IZTd1Z0xic2ZlMGFVSWpIOFVDcFVtOEpQV1Z0R3ZVQWR2TXpteENlUGxjMDlocTROQkM4WmZ5N0d1R0JzZUZMUU1CS01IemdrNkdwaXYvcGFKNlNVTkcrTVVyR1MxT0lTemNaZzA1VW9jemhYdjR1NnpkTVJlbGRDTWxvOVlIZ3NwTlZzYzVtZC9hVnFjdzh2RDF1WFVWMFJKb3krdEJYRm8rWUZoMUxldy9xYTk4WXNaZlhsbEt2YlNuYUpJblRhRW05UUMxZldkM2lWMUwrUjF2VnBQVCttN2xIRjFCay9aNFZSaGJIbUtrTlVaZHdKN3B2QVlZVmtXRXhsb0ZIZ1FPMWR2NDBkNERLWEZMMEg3dUQ2UkFVdzlOdkpnRWFZUSsrWms1UVZNTTJaaDIrN1hlYlRra1JvMnpScEpENlhpU3FnSDljYk1weGhEclNabW44Mi8xTm9VblJMRUlnRjhvczRVdjhidmZ4NVFqUG5rSVdYYnEzYTNIc3J1Q0VPMWZTU1duTktaYXBocGJZTTg4U0xNOFpnK3pkWDFnc3JpWGh3ZkxNQStnb1ptTk5Lc0lOTGFIZGpjMWxVeXhGVjg1Szg4c3JTZGFrOFBOSlhrMTM5Y2tlUHNwQzVac08wMjdvdFZra3drbUlUQXMybklUQ0d6d1NZOXM5Zkx4YnBNeVZTeFV6ZXROL0hqT04wUENtS2l4ZzVuNnVsZzBwMVRIdGF1amk0V2NNZU1CNzJJK1V3bkZCa2RVS21vYUpINGx2ZVBmQVIzbkxENFRIbkZxYW5laEFkMUdzYWJvQTBWKzljNkxncytzS1JFTy9WeDZQZ2pldW90dEkrWGJvM0RpYUk4c2FWWVJnTjFRUFBuMHFxeVBsYXRLUm1LRHI4MEpNL0w0Zkpxd01rc1NUNDJ4d09tZGltRlZaTWVMNHVQMlRBY0VRMGUwbXplNmRDUi9BalB1SHQ5UkthY3RMcDU3UStVSk9TUHNVdW5McnkrL2psWEZpcGk3NWpONVZ5MDZYeWluazFzUXNqWWRNR3V0NjZybk1FWWc3QVJ2b05qUGpsODdsUEZkZExCVWI3d0YreU1RZmhSWnZ4VTEvYkpGOEdGd1d5VXZzbkR2K1YxNHlick5YQXUxUFh2SnQ3Yy8vV0Z2Rkpyazgyd2pDRm5KY2U5WVZXNzVzUWc0V1VibHl6OXI0SitYWkEyOExjMHZhVWIyUTVBVkthYWR0QmJIL3JlbzBHWW1raTBvQkxVeXZ6RG8vd0xtZ3hCcE5WRU1OR3JMREpnRlpMVTcwVEdGWEppUGJPRkRhYnBLU0FlR3plRWF5ZzZ2SEpPUU1ldmtvbWw4eG5UbE05K1lObWxGYk9nKzNvdlh1ZEFPVVVOS1JCSTFMVmkya0FNekIyMFpYUjZvejAza3loSWVXbFVjY1ErN1E1THFoakgrbUtEMmtxSHArUDlPWkpxMnVEa1FKc0ZrRkQvc0NvWGM1OVhjbit5NDg5NEdheHdJK2ZzS2RRdHFDTkdkRzFxbUdYU2hNSTV3TjYzQktRVXJmdUQyMVVjamtCanlWUXFLWURTOVY0UzN5VFhhbkkxbXl5eUM1L1NiWWZtTUh2cWZYcXA1R1p4UE13TkNPcnhQVTVSTEoyTG15d29aUzJCZDFkU3REeDFtM2dON2QwK0dySk1QTTBkUGlST1lOSVUxZHVWYm5Ibm4yQ1dSL1REZFFKWlE5aDBjTjNaSEZuYkYvc2kyL1R3dGs3cVpBTUZDSHc1MEpIclFoNHFmcVV5TGNKVjB3U0c1TUNYZGNWcFhzUkNOQVExeStQaFE1RG84VlhzZDB1Qi9DZkNKTDZISVlhU0RSdU51c1hnc0dMbDNzUkcrTjFkVmJ6bkttVWc1b1phU0o0eFlxellWRm9DU0ZtaWhadHIrWjU4dEMwTnh3aTF5VmpPQ1BoaythT3hscnM1RkpPTGhXRkVOWlJFcWhXYzNDZUhvaE9ldlpHRzhpUnBkL083RkNhUFpHa0tQVlE1ekpkRzVnZ1RkNjBySUlkcy9SZUVic0JGTEZLc2xFZEYvNEVNRTFla2RvVkZzSjRaa0pUYzhXRit5RUc2dWpXRTdieXBmTXhhMlRWZ2loK0xoTU9UZmhGNU1sUDFsSVc1M1J4VmZBVTZPYmFiTjc4NGgvSUJSa3psOTJ1WFFqR0pqSGZvd0R2NTM5K3R2YnBQWkthTFprWTR1NVZoZUdScERGcDVMQjhVT1RDWmUxTmdaSzZaVWsxRkQwZjNmUnVDNjJFdHV5eHRVQy9oR2Zad3p3TU5Wek80QmxIT01Sa0tsT2JCTytseGlwS3dhZS8yVG9CMTFNNllKNG5LWHptRDFoWlRhcnVFaDA4aFRjSVpTZ3dBbFJyZkd4QmFnbHRIZlNTZXdpR1UwemNEUXYrL3NyclgxWS9kdjFBU3lDVWYxWWY2WkUyVHg1RGRLV3hLNmpjT0VqdS9EeXlxVXNZcEtvUFBvemxST096a0c5TkZ5Vjk1aUd4RnkzOUhiLzhzRzM0REZqV2pEQlVSM08wUFZ1OURERUIyS2x0Mmh1MjJsQkZWQXZXWDN2em5Qd25BOEswNTRYeXo2RTZia3pHODBFK29aN0x4UkpXTEtGSnJLM29HNXVuSnkwek9BSlEyVlEveGlOMG5zRFFPUjNnTjFMNUxEMWV6TFBmNGNCZ1VuNXRBMTVPNlIwZS9aZEFLQ2pLK2NTUVprYk92Vm9qdXBiL1lSSk1hbkZWV3Z3RCtiUEpIRXd4ZUE0Y0QzdmdVRGlHYWs0ZU9nQmVkL2R5N2RTWjNGY1dadENNZElZdmFYZXNBaUtLdFZxRStJa3liU1JjeEpGcGhWTFd0Z2ZsUzcrcGgxMDB5VjFWeXNHUCtwc1d5Y3J2ZVRBNWEyVnhDMVJwTG04YUtlcmZ4czRwcVQ3SjFqM3lHQ3RuUHZCeGlMK2daZEE0aktwMm9qQjFsV282cEc4NllyN0xwZHY3Z0NUVTc5c0FONk1wMENZMEg0K3BlUW05dzJmMU5DK0pna3ZlMGMwakZTc1QrM0FicU5oUFB5VWc5TDRsdlJFRnBsNk1VVnU5L0xRWVNhbHR5UUIzNEFvTmNTVEoxU3g5dHhMMG5rcEo1UmwySEYxV2NBKy9rWXF4WVE4YWFmenFsZ25WMmZRQjFadmFRcG14ckJBZDE4aEFiaUl4bUlqMC95YUNUQjlDVFd5cHJ2TUI3bmg1Y29ETHUwSGhSNW03c3h0UnJhTWRiV1RjRUdLNmRoYlg5RW00aDl4d3pYZXRmR2dQRjBqVjRIOWF4L2NFZ05BRjBRK25zZk1xVlpLaHNPRWw1ZGhsUGx1QW1PcnJ4YU1wVk5hMHM2SmNQdjR3VzZCN0lpcU1GRXdOZDlWbDZKNHJlQmljWTNGczZBZGFGdnZIR1dHZ2cvdHU2Yk1RQjl5M1lyb1czTi9CRG9TRVIwZXEvb3lHbTFZbVVydUp2Z0JKblQ2ZlJZMWhMN1ZWOWVJdXE4cElLZTl1TVVEM0NaOFFQc3BLSFM5eUxmSEVaY0NNMWNEd2ZyanltMTY5TGk3SDFoalpTVzlmc0hPSnlnOGRVdzVXNTg0bnh1UWVEZjY4M01ZdzJMeHZuNkJyTTJFN2w0a2oyYUhuZ2ZicGV5b0VLNFRaR0pRdDYyYWIyZ25UMDd3VWpFNmNrd0hHbytOd1pXVnE0L1pvc3ZuQU1Db3ZmTmlBR1RYQVFHcGhkL2k1VFVlTVVITUVzK0tSYU5BRjlQTjF6a3VXeDJSUks0NGw5enlVcXZBY1g0SkdqUVBPcnJpRFFQdVZUWkxHK3lSSjZpcE5FSkxhUE5xNk1HdDVHRlZjTTFXdkh6L2VpMFgwZmZmVHJJOVoxbWpiUFhkaGdEaFNTV0tNejByd3F4UDd0a0xXL0N4SU5mL0dEclI4RFIvWklnQzlTZTZpVU45Vk9MQ3RiM2hBMGZDMlRlTnRodTNxMHc5RmhCU0xlNDNKR0NZb2tNN0pkeEI5R3dHd3BnV2xtZ2RqR2FSZ2xBZ1cwWTVOT3JkTCtYcFFoQXduVDcrVFNwdG44OWVNbDBaRjZWcHpGNXZlRU56YjQ1TjZiamJuSFJoanZOMHFTOE9DSHhycE5neWphclBwYmN3TlpxWGlGVk5ORlJoU255elhNOHNQb1JqV2gveGNFWlBMdnJHZnJyRDlaalQyU0c2WHdPTEcyRlRCSmdhRWM0TksrS2RmcVYzdkhWUm1UUEZ3K2N3SXNUb05mckVBNFpzVExsdldzaHc3amgyS0pFMEZscXJ0VGJCODNzMVltaUN4bFdtU3VmeWZtRjlLdGJpRCtIVUM0ZHorT2ZnMlc2TFJJT1VtZ2VxN2kyekp2TUo5dkRyUVZoVHZRdjh3NWJtWG5aNzVFRWR6aDVCdUhjTkhhN0ZNRG1MVkJMMzFhTzlBOCtFSlo5UVRVNWdXK0JQMUI4THFnWlZqdGliL0kvcHVjTnBNRmRUZUxTZFZVc0dVWVV2NlBJZU1ZbmpyaWpUM0xuQTFyQ3h4V2ZiS2NHdjJRSGRtSVg4Z2ZMNGZZVG5lNTJwZ3E0WFI5R3l6TEpEdE1sMDRMOVllOElQRDFKLzBTRHFBTFRpbVlTUjN1d2Q1NloxbE5DSkVocE5zN1lyY2RXM0dBMmNMMHdZck5aZXVrbE5DQnpqVFdKTHphOUFudUxsM2lFeEh3SFdjTzNTbFZTNVNUQjdvL0lpSGJWQmpnZjljb0pUS0RxU1ZicE85MENXR0VZbnR4b0trVFpNTnA4VFgvdVpUMDhYWkRHZG5CWWhITytJTFlzVFAxM0RrRWpiRGFFMFRPNnJCVWFJNmkzZWhwMDVZQy9uc0MwcWhHcHIvTWJycEprTUhFdmlSMk1QSGxjV1lNTFdMWU5KdUpGMTdMRWt1Nk5nbXFHcllLTlc4eDNMSVY5QUs2QThROVBVVkpRV0o2cmlRdnRHUXBBNERaV3VKMFR5TFRTWXpLcDF6L0JDZzZhK25WbDY2OE5lcjdBdVVRUitreWpLYVEwQlJNeGowL1NCQ3c0amRSa0dkaXF5UGQ0MkZWU3YwWTNOMG0rNml4L1d3cHp6MzBYbzNxcGwrdGNBVjBCZkV2ZnV3YWpTMEVYYUZsQ21uTWgrME1veGI3c05NbExoVEdMNmFaZDJOZ2NuMVUyaG1CbmMrN2JMR1ZZNnRzdGgwdUJpdFN0NnU5ZUJNR1EwalZQcmhKRDdnRStlTndrT0xlTXFiaHM4T2k1ZjJJYVJURlZXWElmTys3MU0wTXFIUVRST0JsUmc3R1NIYjk0R3IvRVYyRTl4aFRCYkI2V0QxV3V1Sm9GZjN5TW9hd0owNmk3Z3l6aUNRSFhERjVSRkxtSUtSVDRDVkRuNGE0MDNwb05Va3ZhTWFOQ1k5MnNHeEFhaFVJaFJTL0pSa2F5dTVUdnRMVmtKMVdOeFNEYVg4YXpZYmF4bzBxSjVlaUtXM1BFaG9sWVdvMTlLYklPTFJUSmNlUUJ3TFpFMFF5MDI5TXdTVjdPTERzdlhyMi9OSFJlNEhUWTN0aGxnN1FYM3h0WldaVjRGdmpBNm9EbVZFZVhnRkJkcmhhSEJ6OVd4SURzN05wMk1jK3phM3dScGtxUVU5T25Qa2g1WStoNkJlQ2dVLzlnWHFmQTFJWFNqTDZZNEJ4OXRUNWE3MlQwQmlJZGpkYnc0UVppcWlIL1J1bHp0L3lJSG9mWEwydUZpTU8rWXRoT0dGbmlSQjNYNTRscFFia0dFYlBYQWluN255eGtSUTFPbnZ4MnR5RnA5RlBMOUVCL2xTckxKZmpablU5M0NmOGtWbjFPcGloL0VuMlM5d2JoN01ab3F3OUQyMjJMZnM3QVRnVG5VdVJaSlJEVTJTeGxpRjZwUzRLMndqYWNNME14Tmo4U1JYWDZCODIwSkpRS2o2alFsRHcxaWp3cjZ1MGxjY3I2L0I1SU45YmlBdGxJS2loYk0vYkpJQm9uaFZyV0hLa1ljOWd0TGtKZkVGdTZ1U1ppWG9oZkM1bXIxWkpRR0YrQlZzU01Qa05wYjUrZmhPaVpuc0wvMllhS2I4b3VGNXppRG5jREtnV1dlb3pFc2wrdXVxdXNTWGQ5bTk4ZGZvZ0VpcnY5d3FhMkxTMk02NVQ3V2I0SGxQdXhsQzdLOWNROFcyTVlkR0Zva0Y2UkEzbVlaT2JoU283QU4rS0R6bTZDNGFOTzhhTjZ4RFlHWEQzbEZYbE1QQ3VkL3NwS1A2M0xlVVA3K2xlQ3dPZ1pVMWZoSlBPdno4WGZHOUlkQnJXS3pvbzVySVB0YXNuQTFDM1hFVWtOTHdyenlhOEo4Ui8rWDV6VkY5aGxHZEhySlgvRzZwTWt4VG5xSlorZnJneUJJRjQvaU1GUUxEYkR3SGhNTFUzaEErZlZwalhkQ0tsd1o5M3dKeXpSK2c3dzhLdVhRLzRQa04xTzFEOWNJMlVaU2t4UTlmZ2pvZUNSekdCbnZkdXBlcThsVVQzQXJUN09UbkVDdEhQSXNLbHpPVjBuZE5oQ1NkekJrK28ybDNnTjRLeWpUSUZYMklEblVPbXJUNXJLNGtrNndXTDBacDBOa3ZFZ2dLcXQ2MkFQbWlJcWVKd2xzbDBEY0hzQzFETHBoR2FNODJtSk5lRjVWa2E5blVEd0lzMnNzeDZjMUdNQTYxUWNYdEtTRklCb1JWY00xWFdvOVRuc1RQb2NndklyOTU3QTZHbjB3TjVaRUNlZkF3ajAyZjVBaTYxSmNIb0xFNTVIL21MVEcrNWYwNld6SnNiQlBDYzBiYjNaVUtSNGZ0Q0p1alV4N1pHU2F4cnRWcHNjRTFnN3F1OWYxc05uMlh2aTdwQUxzaDZhT3NxWW5adE4yYitWYnVkejR3Y0E5Ty9rNVRwMFhxYXZsWk13b2ptUVV5TDhtcWVBcXBZeFNxSVgrb2JFdkhZK21ManZ1MVF4YWFBV1NIdlZjV1BXcmFkWHFzTmhaZklLWitscmpVcmxzdEFvZ2xMc2orZkpXbU9EMTRhVkRJekpBaUlkZEtWQTQxS0VzdWVLYlU2RG9CdkFIcC9jSzJLVzlvc3J0YXBKUmRyMDNZRG0yL1F0ZC9TRTBXbDE4WTFWWHJXdjZQQkdPc0pWYXFTbHpwdThUaHQvQ1BwbzRNMzdMbnZQU2xHWnQzK0NSYUZaY2RaTGh6UHBOQjVpZ0cwV3AwdVJWVmpwa29ZaTBEdDBxbnJ4RVRiNDFtd3JCcStzTUI4ZDdZNXEvWGpQZHJHNmdXQTFFa2wvQXhKcmcxRGVCek1mdkVjK3d2MGwvUHM5WDJrOTRiazFlekhudE1sT1JNWHErSDFnOTVmTGMwZ3l2UlJQM3p4TDdNQmJHWkN0eEJPNmtHQmRnTGNpZWZlY2lTUjNzY0preHFsd0orU2U5WWRieU9qb1ZZRnF6V2JzbWlEOWNPL0d0K0I5MVI0RlRuVk1Kcjg5Y24xU2EveUVJTTZ3Njk2SUcrU01RZnBNRXVlbFVwcGpZRE1BOGw2dDBLeTlNdnd4bENuM0F6R2V2enkyb3ppay83U3Z4RDNjL0JlVkVXSDdNQlJRRnBYcVlxUU5JZ3RoR09sbkpRZHJTYytteEJLanFjRlRxekliOHVLc20zR1NraENSY0xzd2ZqVEh6ZGpIdFdGemY3cXhIMXI2OFUrSmQ4Z0o0bzQvRjF2bVdvQnhQWTZNTS8weG82V0tCeEROVm94S25SdURtNnpPRXdVQjY5NGl0SEZWeU9YRXp1MTVMYm9xamR4VHhpSVI3T0lZdmFiZVVIQ3Nxdk9QdnlTSytNcWVpUTZOTEkxbkpYUXh3Skt4K0htTDZMSmxOSFU5ZGJDL3ZvTHoyY3hsY3pkczJ0dU5PcTRua0hOb2REb0d2dWIwZjdxRENTTkhXVmJPWUo1Qy9FSS9HQ1NqUEdEM2s1Rzk2MnpGV3NqYlRycVRFY0JPS1hMTU5HVFI3dno1S28rRXMvdEVTQUJwOWM3Q1U2TTFmbFh2MEZ3TzFYS24yckwzNXQ0T01ORjY1OTZvR2VPOS9TNm5CZ21vMVg4b1BpQllHT0hMU1R0SGxzamlKVkhaWTB3OE9sWVdOS3ZlV3dlNlhCUEdYMVl5a2hhOCt1YW9FNml4YnE4d1RnVWVDdTdsT0JITXpmVnNHSGJlZi9oV1dyY0J5bDN2NndiMlMzV0RjWGdGOFN3NkxoUmRXcEk4emlQcEFiTWNJRkNnakZRaHorS0pCVTdUR080dXQ1OHBjYzc3RDIxVGFIV1RJSFFNS0dYR0pGcHpKZDh2TlpWTklOQjFkT21YOWZSUkxNQnQxK25maVIwc1RGbWpOd0thaldTc294V0VWTk5sT0JuZGM4SDFEZTF3MXIwS2VCSy9uRlEwZTZ5b2xXbndDaFZSRVMxcTlVRWZnYVNBMmR4Zm9rTHlEK3Nxd2taSkE1bkk5bTlmeklNK2F6VFg5bzQxNFd4UHl1ZkYwTjNjQVVSK2o3KzRhT3lGcXpRRHpDWXNac3dXWVJtOEJHVlc3UDNhTThKMUF4Q2FrU0VpSW1ndTVudW5aeDRZcVN5ZnJxdngzOTdRSk9FRFZtOHF3aVF2NW4vbFQraDh0L3FrVU5BQUFlWFVsRVFWUVBCaDAvT084dkk1K1ZTU2ViMzJRKzUzdzhuMkZzdHR6cEQ3SWgrbTdwSGQ4bC92dnlLTlhsV1dOKys2a2ZEUWFURUtQTmV0RUhnZHd2VVZBdEw2blVOMzhLMGdSc3BpUEsxcjhGSEQvOHVUSFNpaWVyMkp3K003bi9hMWR6emR1VXRSN25Ub1dJanhxVkVzUktPeC9wQmx2eSs2Q3NsZU9ZeGcrMnZRUFlPNUEvQnplRTlpZE1KaUJaSlFEc0oweUd4ZEJSV0VVU0hOa2Vwczl5dURyWlNwVGpuM3lUSmVISzIyVjVNR2RpdlFhWURzcmdudnI0RExkYkE5L3BmY2kwNTRDQlFFWGtsanJ6b3VucVZTdGdEVDV3ZldKU1ZTejdWZzdpeXpqc1B0SFVNRXVQck9LUEsxVXJSWWsvdUlud1EzTDNTeS8vc0dwRENqRVN5Y05qNmlMZi9Hc3VDU1pxTEw3N3pzSThzZ3J3cDZVdnJtSmRVTUU3RzNGemVNWnV6TC9ZR3o0VjdzOVZDdzNoRUNVNCt1eU16Y2poZUwvOUk0aml3cCtDSW5lQmdSUENxbHhpcExVdWxWQjFOcnBwMHlUbWx5WU9vOG5DVWRFRStUTm81YTNSbnFpVlpudG9kZHJuSVFZbmJ2M0lWSnZmTk1BUVRYUVhFMktkdEdsUkI0czhJV0IzWnFxSEtaMHdmVHc1QS9DWXZkWm95RlpTN25rQ3JOT0QzTTl5V3NkVVBNampxWlpOLy9CblNQT3M5WTVrSDVCWmg2akw5M2dVM3lrb0U1VFN1SGN5ZlZTdTRFNUVPelRMN0NCS1F4MS9sdzNGYnhVMFN0elgzWHNZcTZGSjFkYVdBMnZ5VVlIQklRY3VBTDVDeFY1dUZuVHFXaWhyUE5HRFh3ZGR4VHBuTzRabmQ5MTh3YytnM0NKanRwMGFGRkpHYUk0eXE3UnVnNlpzVlc0Y1hJY21PVDJ3Ymwwd2hxK0h6UDlsSGJremtzSHh6VWYvVDYzNDlVTnVYM2QwOWI2RFBGYmpiTHpySEQ2bGg2YzhYa28yV3oyV1pMWGYwTFFQTWkrdVNkVktud3NvdGptN3M5WFB0d3N0eU10RTF1cEtxd3NWeGRtcXg0UTl3MENDZTZZQnR3bm56Mk5Hb0ZDeFMxV2s4ZWt3SEdpK2ozUUVRdVc5Q2FXU0I1ZUN1UlhEUTQ1MTNlNlVGbmY2YUlkd0R1MTAwQkNtQjVxclk5OUh2MWg1N0p0eTJDZW9SdnZncU5aMGloc3JQWkU1QTJKL0ZYaUcrODFvQTRwYjhTNmlKempFQkVpZVZXdWRUSVBta1RUTXo4d2NCZzF2c3pJRXU4aGc5dUg4YkFPOWFFWkg3OG9QUEFrUzY4V1FEQ1QwbXFWUTdkbjBRSThlNE5Wb2dFVFl1cU5abEt3V3ZaaUt4TEIxUXdETWxDOHJ5MTNIQlV2VDhERHNiYVROeng0WGxWZG1iRDdwNjRjSzZ0S1JLbU1UUTlodkxScm85Y0w5RlFLTndqQzRZOTZnalBIK2N2M3BHWWZoZnJZM3dIeFRzcEN4YURGYmVRMnE5VjBTVmphT3NjU0tmczhQVDNLTE4xZU9IZ0JvcFplVmdZd1Y5eitxY2h5cElEV1BLaGdyN3BKK2xGMlpqSTdVSkd1azlQMlE2eC9pVWVrN2FZUXdTNzBud3E2NG9LVTJSSS8xNTJzeWRGS2dkMzM1VkhVWVB1cEpOOGN3NFYva25ta0E1N3AvZGdKRnhwaEhnY2hkY3FuMlZQSFpzSmgyaFdKdHJmN1VYNDRnVkRzZmgxaWFjRDk3dGVEQUZhcFpxVHN1VkwzUVN2NFpQb3BMTmFoVUdqSlVqbmdwVHk5bE9oWU9QZFpMUFF0TmtjVXcyd2JWRXM4N3plWUQ2b1N3ZnI0Wkc4cU5sUm5QQW5vWEM1c1A5OTVGdS81V2U4M0ZKczBVWlcrQUlSd2JCWTM1MzBXTVBydmxUYVA5WVdLUjJLaStZd3hqaVBUbHRuaWdQaUNaYUs2ditEcTBSc3VXM1d4OHp5MGV3a1Q0cnRLRnZvMUt1Y2ZZSHgzc0U5a1F0Zy9LMm9FNzBpWituNGNrc084dm5mT1RLemJIVmFPTVduZ2cvdWVKVWhpb1RLL1Jvck1WbEJESVcwT0doZjRQY05kM2NkK1Q2THg5eUYveGZzd3o0ZWFiR1pOeXozUGpYbnNBcHJLVzV2TjNIYXpvcjZPOUF2eWltTzc5SElUd3hBV3hVcU9ZeVBpdy9vYmZCbVg5U2tkaThSdWYrRHNWSTQxa2tVMmRiT1F3cWI3c1NKOEVLUnhJUDFqMjZyWDRPenJrUHNYM1lHbDJZUHdyMFc3SE5jU0Zoa0tGeVhUWEFCVWE0KzZZQmZMUEhsamRDOTlMUXdHMnpVRjhiUTJOSVpRbTJET01ETUU4THZEQ0pLY0FpbU9UQWgxTXp4R1ZheXREbVdnVFlrTVllS1BMNWFINUVnZXU1UDFDdzh4Y1BqWmY2ZWhBU2lqUHRieUJ6VVFEdFRPQncxNUJrNk4zSkNmV0lVbklodTJSYWlwWVhhaFJiQUI0RzVuUkxPR3pXSjNaMjZubm81MDZZUXNERUVkOXZHT0wrSFl3M3grRE1rUjB0VDQzYmRYcUEzSGgrK0Z4bW5VRStjVFhKVHpQM2pqd0V1alh1aWVqNHNOWUNlZGZUU1c5VDRHK1hTNnI1RkpqcWxjME9pODdIS0tYd0NScFNlaFRiVzNLVnM3cUc0K1NmT2dWeHgrS3dzTGd3N3pUaG56cXBieVdQa3hvUklBNmJDK2w3Wi9NT1cyT1FSL3djOVgzbEZ5Vk1kNitKamNFdzh4S3NyM1pETjNPWkQxWUl6RG85UythMm5hS1N4SldFMmw2TGlzUUF4MitsQVI0S0JVYjVsbXZzSENIRVlQdGFDMVdsa3owOUgrdXJVRktLMkU4UmF4ZWxtbHZNRTA5WW5yTmM4YU1xdVFmS1kzT283NmtjblNQcGlKc05IdXZ1aHQrUmhnWmEzYjNjR21raDZFNlpSaGJ1dTZGQmU4RW14REk3UitkWTMySEc3R2hmbFBCUXdzYWRMRWFkQTZKcUVZQ0xwcnA3QmhSRGx1Sk9BMS9QNnBLSFVwS3BsSFl4U20xRTZRc2dlaDAzK0VxT1hidlJPbTdLdGp0WktlQ2wreTRWdkxUOEZ4SlZpUllPWk1QR1hER1FvZENVS1E5R1haTzFvQkRMbDVhVGt3Sy9LbnRGN1N4SDlIQ3FFZlNOY1lEZUlkbW1GSXFHNkxnaWYzcE1OcGZlRmEzakw0MzljMlduQTdNOUI2VUJMZVhodXpFSUZRSW5GR3NGVEhZMkxWQ3F2M0VpMDk2NEVIWldRRGo4cVV3K2FaY1hnV1RZMnNML1hhMmxJTzZ5a2xIY3B6eFdHNjh1OWtBbzhuQ1VhbHZxSndSMG0renNhWkVNdFQ3Mlh5M0lsZHA1a1NzQlgwbFJ1WDlFK1V5REF6VHA4UkNQcHdqVythUXJ6M0ZDSWxidEcxMkVPdVBhV3ludzN1UHg4SXF3MkdWVHQ1ZSs5UHBHR3dpUUJLLzZHV3ZiQ2ZScGd3elc1TXVzK0JzVDl4dXlZNzA0cm04blgxOVZnNzJwWFl4cXNPS1I1ZEFBdUpGVzF3MjJDa3YvWEZrSTlnY0NBWUNJWUVmOUtITFFGZ2dhdVpyQXBjN01SRm44cml3TVZmQlBmeTlDVXVFNlVEMHlNMytRSnB0NEN2ZmgyelQ2QlA0U1JlVmgzbll6aE9zZGNMbnhNRUxWTkNwb2ZVUUkyMHdUR3NnTmIyY1N2SC8rcmJVaGg4elk1dkpoVkN0L1RtbVhxQ1ZDb1ZyMWRjV0pyVW9qNFh4TFcwZEZaZzVzQWJENzQyL2ZnL0RqRlNTZmJVL1VXeXdQZXpEUU56d3k4QUZNZVhLTHVyelBRcnNUaGhtWnFOVjZWYXEvYXp5VmRJR1g2cEw4eHRIWlQ2TGRkUkF5SjJxUmhtd1RydGdYcUR4RjUyQVVJNzBGdTBrNmUzWkdKY0o1OUpFd2JLckdJNXdXU3JrWXg4NVV0R1duUjdYcGJhb0xFbjUyQnk5WEZVQ0twRWlTcFpEQkhPdnJwR2Vua1hvNFFVS2c3NCtNNW9HSUdUUS83SUdTR0wzb3NTZHdsc1lHVVJQUVVLRXVpY1hZZFo1dmVYdFl6ZngxT25rQWMzNGVKUDFNbWdVZmpQWThHL0Z1d2NkY2NUVlBPQ3FFUmFYTmNTVlV4YlZjc2twRkpYVTFFR0JpYll2MFFLT3pBK3I4UzM1bFpGc1NraFZPSGRqek81cWNjbzV6Vkx4aXRLendjUGpHVFo3SnV5OVRtcVFWQ21xNW52cHNoSy9PWUFVUzcvd3QzQWJCTHBTdERjVFFMRVJ4VXl3MjFTbWlveFg1S0tZWnRYMC9TWEhISTFveXhKR1cyQk9rM0NMS1RhdzIwYU1OY2p1eVZGNW13dGZaNU1UTTRWL2htNTVRVnp2Vno4cUp2VDJLTWhLWnZSTURqelhLWjdXSEVsTTdZWVVyZGxFSVpYVUk5c2p2VlNYSHptT096L0hjbmdxcFZQSDdQUzNlLzZYOGF6ekk1SldKbUNET2hQc3RsRVpDZTdicitzZ1UvQk5UTTRIQ1Q1bWd3ZkNLTDdxY3A2ays4WGlEeCtTRFNzcTlGY1F6bk1HdWp5WXFCZzlwbHJRckk1bHMwbUZhKzNneDhzUFBEelByMGFxR0Q0RG9TNy9abE5XaGhTenBWcmZaVmtSdmpYQkhWVklaWlhDc2k4RFdodmpyajVxQUlIWU9vQ2xwUkVCak5OeHVSZUU1cjNPbUs0TkZEays5RjJMenFjT1VjWTV1SWYyWUR4S3F4MnJNK2FuQ2dGN05KSm5ZU0pIaEo1T2UwNHBjbUIrdXJvSXBLR293L3hTRWx1Zmc0QjZ5bDhiWjRSNHRVZ3JkNE0wMUNxYnNzd3NsdkdiTmEzMDBvMm05dTVBUGJNYUh6K09pK0hlT2ZISEJTMlkySTlVczB1SlE3VWkzT2V1TXd5RWowMDNyMHZ1a1RiUEkvMEc4QU5UUitJbldUQ2x2K3o3aVV2bFU1ZDBldG8xSGZqY1RhZmlkR296VjVQU3U2L1JDdjZzaGtPaUdnbkQxQm9SU2V2RkVYK3o1My9ZN3dvMnhxRmhjSGJRbTdVaDdFZVZPZVMrR1hmajRjbnZKZjJXS0VlRVREcm9NNUd4R1dSazIxY1ZMUVpXa1NIanFnSWM3Mm1WamhWclZXWGMrN3VGYm1GbzJBRHRtKzdBSnFDc1dZV29RY0pKeGFOSlc1bElIaTRLTldlM2JDcFRVUzM2MURZNGg3MDFLRko5NlBwVVRWNjFzYVpsTTBWZSt1cjdwSXNYZ0VjLzMwNTZRWGY0OGIxbFozUGJ5SWhWZ2N0b1ZLM1JURi9JRm9uUkc0M21jejh2QTFPTHdYT3RBSDVLZG1JODBPTS9wd0ZQM0Y4YWtKRDJOTkoxbEMvV2p2akxXMDdDc0RSWGlyN2NoTDVKRmxGbEhjbmgzRFlIU0hSWldOLzVWTGtydFZpTzNza096N0JpZ1RSTkRPalMwdzVWSDI0QjVYUStCMWh5ZUY5V3NlOHZFVWVsc0JBb0k3T0ZwaEtzdHFVVTB4Q0FLaTJXS3FIUnlmYy9IRCtNR3JCeTBNVjRpdW41TVpxbHY3UmUrYVd6RFhjMlQ5K2lncWxkeGYvZjJyVnR0N0xiTUhKbTl2OS9jQ3l4RC9aSUJBR08zZFgyb1NzNzhZa2RXeGNTQUlISlpIdGEzMWtEQjZWcWdLRElVRzhIaEZyZ29zOWJ4VVVQWUZqNUdESlpob0k1ZS9TZlBsUTVJUytLb0ZKbktKck1makR1UEtoS0tWc3IrcnJ4WWVRbEdrMkU0ZlhpVFJjeDcvblBrYjZUOXRKVnhjOGZjbXE5WmF1c2owb09GSVdQSlFmOTFSTEVMWVdJRXpHZkRPMi9nNng5RDRJZGE0VEF5Yjh0aFFGN2g3MVl6VFZhb296Q0E4VE5ac3owejBVTEFPMjErR3l2RGx4NzFyc3p4aXVUd2FFOTJlZDlJbGsva3k1eGxhejR6VjBFcXg2azE1Vmo0QW9YVGx6MkhQMjFZRTFiMVNFMmtqQmg1cmdqZHllZDlHWENzN0MvaG56WnNHdXJOZDJlVkhtUlFkS1ZHcDBGRVZIVlB2dkpUdk5oODA1dTlOdmNhdjJTelFDNCtTMW84OEFrN2JYUVowM3NXaTF5WmFPbWdvTVEvNGxTL3pnYzJ4T3JsNldnbnQxRmYvKzB3cWFxT25wL1VlU1dDOXEvRXFURGl2K2dXNEtIWUxKVmZ5aVRIQjZDS1p5RDlCZGhCRWtqSXMxaTViS25qQkc3VWk1MkVpUHZkMWNlbU9ZajRQNlRDeEVXQWdiTnAzc29xMDFQQkJsVXQrK1AvTFFZKzkwTWxWcG5xU2NPTmN2ODFlN0NIMFlCb3c1d1JkTVZyQk42T25TeFd6dmRRSEtNYkFaWFBrekd4bWZuSHlrQ1BrajlOdGFrUkdPZkZpZ09OU3BtbGpSNllIVVVCTllkQnArVUxMNERSN1RLUnpZYnY0Ymk2aHdBeHRkNkppZ25jM0xCMlVzWW5XWjNSanVsZWFsU2p3WUFqQ0RMaUQySmtudUxkMHp2bm00NXphYU5kMVVUZHZqV1VJejN3QmY1K2g4b3ZvaGlLeXR2dzZqcjFSYXFteWVlNzFlNFZUMTVYUGgrMkh6THBGMjBCRkRCSzZXS05UWktXVUppNmFsWGYzODJ2Z2xPK0V6Z1pqRDBGSEhWU0RBZXdEWU5zNUViT04wVkJZczgxTnlDUEpoY0xXS25wZSs5RXU3Qi9tVFNuemJ4UjZzNlFxTGdBaXZ3RWhnUnFRR0lrclhvY0NGd2V0eTdsM2dqbm83RldlbGFpdC92SU5MUmY5U1g5RlZwOUxZVUp0dFpSdHlpc1hZcWxIQlFTNTFVcFFJSGRDaXBpMy9PSXZBdlFzQ3k2dE14VzF2ZWt6emd3aGdpTDFaVzVoMlBWYjQzUWpkVEIvRHMrYkpvU0RkWEc2UEVYa3dsQjJUODFIY1RIRUw1WExXV1NkRGlPQ0pUVldqM3J2QnpqK2QrUHM3M2g1Mk93SGMvTUdMbk91YW4rS1JVcEZaNFo3cmNYd1JxL1V0SkMxTG5nZ3NGNGp5K2pVUkJzUmZwQm9oN2xpQ2hRMU1WWjVFTkhuRWZoMW9YTDdOLzZZeklaY2xNbDhOTTlzdldNOThqT2FONFE1eFBGU3ZmMlhvNnJUL3ZCUlRXaDloTmZFYUdnRXZoTGY4RXFVTWI5SWNNMmxmSExaYkdSMTU0MHFOYXE2eDFDeUdSbUhSOVIxaWNuN04vZ1o0cndHdDB5Wld4ay9Da3hnRVM1QnM3VmxhdDVYY3VpbWVFQzVXRTJkNHFleVRTUHdxSWZFSk9PbHBna0JMbGc2ei9pVVMyNUN5TVU1bmNoMUxwcktuSTZMVWhRVlZLZnZEUmdLZW15RExydmR6OFVSZ1h4S05aUThKTTFXYVVteUdVRnRxYXA0akhPWjY1aCtLOWx2aTFIK0R2cXh2cWN5OWZOc2RPc1o0VW1EeFIxd0NLNjloakFBL3U0aVliU2t1allaMUlvVnk3S0p6T2ZVS2RJMU5rZTNBNXBBNG8yQVlPTXRXeXFpNWtkZ085M0U1aXlycE1vWEsrRGpXL3dtVVNyK1pESGZ5R05PMnpGc2diZDIxSjdub3pOR3drdTRoR0xqRkpDRjA2RFVOeGEzeXF5eEQyY0JMWTJuOVZLTVcvV1J6bUkrRk5zZlU4YmpaOGc1dHIwWHZ5ODhuR1BoNnBGcklVQTR3Zm83dHcrWVRLQnp2alZUVkZLclJBUWUxYm9iMHFINDh2SW5VTFFTcnpxNDBHMDU0STQyUUViRmpSN0xhNkJqNmh5MDhQT25wUEdyWEpmTmtnU2l1UVFuNnczZXc4UFVQVlJkN2dPUXpwRkwxRE5KbEk1Wng4cFJJb0p5ajdoa0ZERHhUek8xNVNTdUV0T0N6bVI5Qm1xWHMrOGo5OXo3Wm40SFV2ak5oclBhOWp4N0d2QjgxWEFWdmNFaFpVaXAvWTljbkVWbUY2dlRTVzFhNmUyL0J0MHBqSms1bHZtM1NvRkFIam1kYmNQMXlkNXpkSmJHYzYrMEo3anFLL1VzZGhQZStkRUtFZk1abXU4UzJzODFRdGJGYzFQVnZRY1JjdTk5S29PNlFud2p3cXN1dHBydnprVWFCMzNZL245THU3bUxIZElpekZiTG1uOFpmTTc2S1oxSUdJZm9zQUJYZ05nUUlpWUFxUkswVUxLT3NEdDhmNlBlL3ZhSERwMWdqdUlac2dpTllFSXNRNG1Dblg4bEFjTFgvVDFJb3ZwY2hKVi9kc3FxT2dDZVB5ZWlaRkRSd29wRFBWQkU5aVpEMnA0cnlKdlREcWYxd0J4S0dRWDBmMDlyVi9WS1FRYVRPc0xlR1JEdS9zRkJTdyttMElvVlZCa1QydFlLa2RGd2xuOFlHUHNpaW93eCsrYXVPNjRqSW92SXhIYXFhM2tzYVpCWjRZc2JFSGhZTTBjMTdQNExIbHVYV0F3VTBZcURnaTNLNEViWHhldk5UVTBVUEtlRFJRa253UG8vRWtsSXBKYWRuUTlXeTVsSmVwSEpONmo5UHNSY09mRTdiSHBkK3AvWGUrYlRvelBaeE1QLzNXY0MyOFg3N3B1YUtWUFpaOHBQMldDZmRmQ1JLZm0yUHJ5VVZKRkFSV0NJWWp5RUVDT0haS3pMVzRmTTBQTFJuRGxFTWRrQ2MydUt4Z0M5TFBCVkd3TEtNSTVRSGFUUzJ5Zm1GaVJSUXF4ZG9hanplamFjR2hyb2oxeWwvWUhod3dMSGJ0NjloUndMeGdPMGViYUVkTFE3OVgvOFBISTZmdnZFLzgrNXBGWnYxLzhndDl5S0VFSVVVTm9hMjFySEVNMXhRYkdVdzQrZTh5SlBKUHlVTmtGVlEwUE5IUDBacHE1NlpTVnVaS0taVEt3SnRKWHpuWUVHd0Zvb2hicWZyMHh0ck1TWFloYnd5K1dHWVZjVnphc052UkZoYzZqRnNzUGMyTzArYW8rSUFwa3dMUDB3WHFtRGZGM25XbHAvM2NrSFhnd3hkM2Y4a1BORktpa3NFQk0vVU90THE4YzZUSDVmdmp1UlFlRXFSMW00allCSUwwTTkwRGxzaXk4aEVjU1BjK3pHQ0VpcHlJaHVXVnlPWlFVbEJYdFh2UTJMdWpCZThnbTBRbWpJc2dGQyswYTQrdWc5VEh3ZnVOMFVaMzg5TmkxRTRvQ05YcXpKVmthS0xVdmJsVjlNYVVITWc2dS9aUWFmV1BTMy94V2IvWFFyVTl5QjVCamkwQnZaSkRkWW9MeHJtYXVzaXg3TW1vRG9zYUNpTEVUVmRleDZObkFCNFkzM0s2UDF2TitiY2hWZXQxUkZ6MGwwZStxRzBJa3R0RTFRSVZaQzIyOXYxSWEyTHJIYzdQUHQxY1p1d3BTamw3Y1JCV1U0a3dYT0tlSTRrU2wxekw0Z3dvSWFyRG1DUGpwTE0vNFI2UzUxZ2ZHaWlvM3NycVFGQW9mYzFNNTVrTzlaUG9NRlAzeHFHT3o3eFAxbXArTldueWg3cUhSNUxpOFpIL2NJak0zd0lGSjZrYnBucE1jUTZQcG5XTy9vN2kzSnBSWVZEYkU0L1p0S093NVF2OHNUQS9MVjRmWnhRemRMTUtHNDZneEwxQVorTEYzQ0NRZUZtZlc0T0VlckVlZVVqVittRWJSQm15Y1NIWW5PbFp0MzF2a3BlV1FiQzg0cG5pQ0F6Z3lCZGZvWGd6SXphVkQ4cFNSeit3dkdWanlNRmNwM3JEN3Qvc0NwdzUrb1BjZjlBb1RxTGgxb3Nmai8zYnZDL0Q3aVN5cG5YTXA5S1MzUDdWVFpqS3pHTGg1cGlZN2VsTml2dmxUTWQzNFY3S004OXQzY2t1bnFndVR5RURjQnNrdmJROUNOMGtNaGN0RjErT2FzZDdJNUpTeURBeUk3SjZlVG5ENVp3QjE3MXNFREFLUno0RzFjNmsrRGVFUlBPS3Y5TGpIMWplTEFFcVMzQW1mRkF1MXRITEdkZzQwVlJITzV1eXRBeHQ1ZGNwY3drTWJ3WnZwdTlscTkzQmRFR1Y1OS83QnZqOGUzbERoSmpIL2VDZTE2ZnVoMFo1c1YzcmIvTnRad3RkUVJyZDhpVGc4VVF6cmI5RDI0VjdUVEF3cGY5cGY0b3F0Mm13dStRS0xtS2hpUk9rVWM1MXpDS1lkekFDbzZLNWtQMkhPNkhVSG81Yll0NWw3cG1XOVVsOTdWRklUTHdaSnRlZnREcGwzVC93bXBxMDArVE9jYVdkRGhXTmtkZk1VRUJRS0V6TVNlb2N2NVZxQVJGSmNkZlp5TFl1UnRQdnMxK0M5d2RDclNDdEN6R2ozV0dkV1lNTjY5Ykpxc2phV0trdkFZMGtINHBlcFdnOVhkQzlzL2JBQTFoVmJjeTBza3NvMkVsYTVjeDV2WklIMWxLNXVOb2hSb1lJTTJWTEJrNDVybXJobFhZajI2TVByR1Q0a3oxeEhORm82c0RKK0dRMEkyazh0dUVLMU9Mc21XamE2Mk8vYVJjdG1pQzVtMXVZSFpmRlVBWGZYYlhQVk5sUGJGdHpiRjZwNzEyQ1JWSG4wYVRQNFZjSUNLci8rNUxKWmM4R2x3SjZrbkJLeEtDUnlJbVJTa0dLNjVyVmx4emJJMnI4WGttclBxMmxDTXFLc1VSNFRUeUFYbGk3bjFSZGxGcDhJbHU4cnBlRFFMblpyT21pUkRJRjZVaERtb25ZSzVkQUVnczJBamZMZm9qR3dtenVUWGpoU2N5Q1o3L1pydGZXcU9Wd2wxMHYrWGJ3WEhQdXEyaUpJZ2ZDQmVmSVBWZEs3ams5VUhYRGdTMDR5TkhRTUNMajlMblUyYXM1b0FQSkd0S0pFcU04WkJOb04xL01RMHRBYWhHcG4yUURHdVRmTnFuRWZ6VXVhT3Y3TDlXR3J1WmhxTDUyNEkrT1pqZzdsQXZMczBETjZGUWUvUVUrRzdxZ215bUx4MjR4SisyTjdBMGFXSG52Zjk1NGYxNDNLOW9vdXludUtkVmt2ZVpZK3BzeS8rRTI2TDNaWnVLZXM0L2FBOHdNSmFQcnJLNXdrZGh1U3JPZUIzeW5xcG9DQzdaUWs4R0NLWXRxZWhXWVlCNElBZVdxSnJBWnlNZm5nYzB1MS9FRDlXM3ZuLzVoM1M4WlpVTkovVUdCdTF5aFBYQ08zdXlac2p4R1A0RVFpbTFncTc4RDJWOFRYZlVGRXJkYVg5eDR2K09ScHEzZDNnNC9LSWFUNWNuN3ZEelM4SlRMT2dlSDBZeXNaQ01hZnRob1RJd09KVkFtaHpEektVcFB3SVVZVVMySGZaSlZCMHJmWkNwZUVIeDVJRWVXQitkbjhuY1lDRExPeHY2dHRMd2pQV3hhRmVTOUtQNlI0eGxmVkxubE1SUlBaaFlEMGRYTytjY0oyK2xDdjRPNkdqZE5xbkFKTkxEdmlrOUlYbFIvOHlYK3NUZm1JODVubGExWlVzQUNONVhYdWNjWk80azFxQVBPRFN0MEpwYW1nU1VTYWdBbGxmdWl0S0V6NmhCWmxPM0JGbkVPbXlveUdPb1lEV2FZdEJkMUZqNWNqSWFVeElBWG9qb0RFVW1uODNJdC9UTVZWTnovOGZlenJYUkpBcDZQZXR1cHpKa2p2Zmk0djNpSWpTbFE1cVE3UjhvbGVmQlg5a2psRXB2dytBdDl5M0toY2dIbTQzMUcrWU1kc1ZTWVNrK3l2VElYRE9vdHQvV1RKclJSUUZnL1NCWDkyZnlnSURKMFIzU0hRUUlCcW5xMWtDaVQ3eWNKNjB1L2V4QkJ1K1JyZitsWEhRajRSRXE3aU9ZRTVXdUhtY2FEcnAxT3U5VzFCL01SdFhzMkJwM0VuUlV3YWphZGNlR0FEN08vbkJCam1JVnE5K3AzdEpUeUFGWVliT0VjcVYvRHNTL0hJWlVrTG5JWFNKUjdEY1RPcE1UVDBKcHRBazY0Rk5MZEdTR1NmUU01NEZMUEJISnpnWXhobExSTXgzMUxTV0d5aG5GRUljdXlPUEhRUFZBRU1mRGs1cHArcERyZWtsU3V3TzFuQ3FRSnJKb2NKVVlVdkZWSkFPdWx6dnlxNGxzeUFLLytRZGovYzg3RDNMZm9WU013ekMwdXM1ZldOa2R2TGltbFR0NW80S3ovdnFDMVhjZkFmTDBBN0lleFBYdFVpZjd5UlhRL0lrRzFrVUNhelhaQ3dkdXUxQW96MVRsTzlPcVJuREVOV1lLRE1QV1hlaGtqL2YrSlpVbE80bmhSRlRDYmR6NHI5UzBadHNsQWdHald0RFdzOCt5SGc2WE1McFZBT1ZyVXpNOTc5VHN4QTZuNDNoaW9VMGhlVGdndHZiV0REOG82SFIzUFlDOG50SW1SMkMyYXdLTmFOQ2ltSVArb0p2MmdoakFLbi9RbmlpQTMxclVWTmpVS0Uvb0NLM2J3a2x0OHBaVTBzQnh5QmUwdmxxQjB6S0YwRUNjNnFWaXE1bGtxTjZoT0M3ektKajZ2TlV4aTlCS2dEdTZiMUhaYkh5QTVuMDdHNGcyYWRENXc4R0FLQzFmYUQ0ZDlxSSs1ay9VLzg3cy81Z05FODB2aTIxVXdGUW45WDl3R0RjRXNPZ2ZIMkpnazBSbFlwSjZwSXMrMnFoTUh3UXhuYy9OVzRheVhRNjBKdjU4eDN4dWRzTGMwN3FYZHpKMzZYM3JBK1JpcU45TVE0OW5IclJZNHlJWEFVeXNwaGw1V1dRNTl3Wjd5Qmd3R21ESnFPZXNoQ0g4blFzcnl3VitLZThwVWRGTVlUbWdJcUxyY2hTWUxxcVdjOWFwcEZ6UXdKRDBHM1I3cGVVdHdaWlVueFc2Q0Q0eXpYY1dKSjF6eVVQUGRSNEs5Vi9PUW95TUx5VENUQ1JlWEVKNHVtVkIydGgwWDFwMTNHUmlWcUVtK05QNndSdmZIbWpNck1pYVJYSG1lY3hLbU5NRWMxODMvN2RYZnpTOTM4YlNGSFlNa2dSQllVUGxQeXByd2I4S2UvMlZjK05mSlNUVXdhWkxrQ29WN3FKdmtvU2M1OEZRZXVBcExUaEZyR1RpaWkzbXJYRlNzVS9aRmNLZFJiOUROYlhYR0RWSURKK1VTUVFPWlEyRkVpMDk0a0xpVnlJeEo2SkMxN2NGMVZ6NS9Xa3Jna2FCM2EyeDViTXM1cmR3R0xnelRnWkRLcHJ4NDdycnB0N3hHVG5UVlAyT2dxRzEyUExsTk9hcG5XTWxNM0J1bHFhak5BeHR5OGV1aHhaRmh6V0loL0VmZW9JNUZ5RUhFbGlWczFLbCtPTlRvWXprZ1RyVmpHWnFjeXNqYXNDZXhKa2ZqZUVRL1g3aGg1TnhaOTMzT0FacEFtVi9wS0NqM2psZVpneitDS256R1I3U2pkUFVkeHdmL2YvOG5UbjBsZmhaZnU0akw1bXErTyt6NWZwRHYzb2xsZ0RXcDFDeTlaQitlUXdrenMrVk9Ycjd2WTVVRGtWamJYT0R6aVhkTFBtWC9FcHZtVFY2QlZQSjBkRUhRQnN2WDR5UzUrR2hPK3JMTjBpdjVEOWIrdWdOaUVhRlhBQUFBQUVsRlRrU3VRbUND","base64"),
        cement1: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FZQUFBRERQbUhMQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUhFQThNYlFkOXhBQUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBZ0FFbEVRVlI0MnUxOXk1SWN4NVhsOFhobFpxRUtKRVZLQUNqQ3BBWWZLKzFiaTE3T1lzekdaajM5UGZvUGZjYlk3R2FsUmEvR1ROUFRaaElwc2trQ0pBRlJCSWdxb1BJUkQ1OUZ4STA0Y2VKNlpra0UyelFjcGhtc1VGbVpFUjd1MSsvajNIT3ZoOS8rOXJmeHM4OCt3MmVmZjQ3UFAvME11LzBPUDc1K3VLL1Zhb1g3OSsvai92MzdlT2VkZDVERjRROEJFVEhFSDJmb2gvNEsvWStJZnEyemNjMWpRSWpoeHduNm9iL2lKQWtoQU1Va0VaTjBBTUJQZnZJVGhCQVFZMFNNazJhdy80ZVFGcFlzeThhLzgzZTk5N3pQOE9mNEgzK1c3OEdmNWUvelQzdVdydXNXeitCOWg2L2Z0aTI2cmtQWGRZdG41L3ZPTmxvSXlMSnN2RTZNRVczYmp2LzRlZXo3OWxsdi9QdzMrOTIrYjg5a1AvbjVRZ2g0K3ZUcFVoRkVJTWFBd3VZK1lMN1FlWjczTm1POVJod2UvQ1lMRjBKQVFKaFVqWHdIWWRBMmdZd1BUMklJQ01QMWpna0EzMDgvTTA1U3lFamtBeUtXbnh0L0JpQUwyV3h5V1dqY3lSMnVtUkpDRXdEN1c5dTFpTjFjQ1BuL0puaDgvOFhjbmxoOGV6OEVZTHZkSlRlcW1mdGkydlZoOXVFc3k3RFpiTEJhclJZUHovcGtGQ0FacEU2S2ZxWmZtQURFZmdxblhkU3JKbnN0NzkzZjA0UnNJUVNJQ0FpMGE0QVk0UXNTQ1ZzSUFTSExrTSswRnhCak4zc08wd0pabHZWakdPd3BYOXNXeUg2Tzl4dWV0ZXM2eEM2TzMrdmFGaDE5bHpXSEp3VFROVHQwM1hSdjFpenI5UnJyOVFiUG5qMXpmSUJ4MTZPd1h6d0gwQ1p4dFZxaHJtdkVya016M0tTZmRDQUVMQWJtK1IzUlp0UWV5Q1F2eTBZWnRJV2tKK3pmSSt2VS96bWlpOTI0MEVCY2pHSCtlNXhONUVKekliQi9SQUxWallJYStqL01kMmNJZ3lvVnplT1lKeGFHRUFLNjBFM0NIQUt5UVNBZzE1akdQWTF3RXVLNU5nNGhvQ2dLRkVVeGFxMjJiUjBmWUhqbUNCVG0rSVU0VjJlUXljaXlESWVtd1hhN1JkZDFyczNUQmVCZDNFOVdSSkRKWWRYcmFZMUp2UTBMbjdCeldaNlB1L21vRHlTbXhMUUEyMzMxUWJ6dm45Snl2WUlLcmwrME1Da1I2RWpUZU5ySU00a1JzZGNrdys5RlVTdzBwMmtzZDJPR3lDWWdzZzg0M3NEVVNsM1hlUGJzR1Y2K2ZMbHdDdGtKOGxTVzV3aDZnbWE2WW1scWdMYnJFRzNpZ05FdnNjbk44enpwZkthRXdCdlBLUUhTNitqbjliNjZLYklzY3hjbTVlT2s3dXR0a3RWcWhjMW1nN096TTJSWk5qcXZ5KytiUmc1a0FrU2wySnNSUUYzWGVQNzhPUzR2TC9HNzMvM3VxRlRkT0J4MUhvNkZaVEl6UHh4c3doWTF6L054WTczSzUvdjFyMzhOQUtoV0ZiS1lqNzZQbXVOQlFTRUNLRVlmT1l5R1pyN3ptZ1p0MjZKcG1sa285SjNEVWZLV09ienlRczRmVEFqK2loZGNYNmIyQXdLeUVPREJPbkVtREJFRnE0VkFnN1BGOXNLc1Z6a2h1dnRQcWRRZmlpQ1l3L1lxTlVGdkFyTVRtbmJ1ZnhXam96SjR0WE5wNmdEa1IxVTRPemFwUWFrSGJEaUQyam5ESG1ZYWlFSWJzMmxOMDN4bkZhekN4ZmZSWjlOeGFjaWxhdjNZdmJNc1ExVlZzem14ZTVqSEhrSVlyNldna1gzR2ZCN2JxQmF0VlZXSm9pakdNUy9uZEs0RGlna1pXc1lBWS96c0xIeFpscmk0dUVCWmxvZ3hvbW1hY1dHeUxCczlVZ1ZEVFBwTkFIaUE2c0I1ZmtLTUVmdjlmcHdNNy9zcEFkRjdjb2lrazhzTGE4K2lpOEtZZ0QyakxZajlUVDN6UE05Umx1VjRYYjVIMHpUanMrbml6eUlxWjA3YXRzWHQyN2VIK0grTnRtMFhtOCt6QjBVY2NRRFBDNXhzaGFya3FxcHdkbmFHOC9OejVIaytHN2lIWnZGazIwSjRDK1B0TFA1czB6U3p4ZklFNWhUODdKbVpsdkFORzVQRjFId05FL1JtOEkyODUvR0Vqb1hGcm12L3lySkVDQUZOMDJDMzI4M2c0bFRZeWNKZ1A5ZnJOYzdPemxBTTkyemJkam11TUxQNUtLWW9NTXp0d3l6Y0dPT0VtY3JNOHh5cjFRcHQyK0xzN0d4MFFsanE3ZUY1VjdCVTJuZHNvZ3pFVUZUTVBsdFYxV0pIZEJJU2VpWW50WE41WitvMUdGaGh6WkxuT2ZJOEh4MWovcDcrdEJDVkY0NFhuODJnTFJnTGpab3QzZ1RMVkcrRm9paVE1VG02R1AxUWNvNnpvVEJYc1k4Q1l0Sno3U0ZIdU5qL2VyMUdYZGV6UmVTSnNDaEMxWkdpVkJhN3BpVGRoRTRoYTgxaDhJUVZSWUVzeTFEWDlUaHhiQ0xZOXZKOXU2NmJxWDRWS0Z0Yys1dXBYUFUxMUovUWpjR214VFNMQ1N2ZlMwM1RzVnh2bG1YSXdsejRacCtKRVhFWTQ0Z0RJTVpaT25pT09uWER2NlVwc01FVlJURlQvL3pnTnBrODhUWnh0dnQ0Sjl0UGUxOFhSdTJ0b20yMjZMb2JUYnZ3Qk52bkZhWGp4VFJuaTlXeDdtNVQ0ZlpkKzhkK2o4MlBKblZzVjV2cXQ4M1NOQTN5UEYvTXRTY0VESVpsV1lhUWhiUVBNS0Nmc1E4RGcyc0I1aXFteDQwOVdKUWZ4SFpCS3AzcmZaL1ZzWWVPcGVEbFZCakpDMmgyMEhPbWVJdzJVVjAzaDJPcnFwcnRRaFlNTlhYMjdPd2JhQ3FhTVg2TlFGajRWUVB3NTd6ZGI4TE5Lajg3a1oreGhGb1JBNkYrUjBMUmxKUElucmhtcktMZ0Npb1lHamw0S3Q3OGcyTWhxT1lkV0RQWWZUUmkwTEd4aDI5anlMSU1aVm1Pb2FjSmxEbUliZHVpTE11WktkSjBjbXFzSnBqcVhKb0FlUDZKUmpmMnZuSUZnb1QwbmhOZ2Z5M0NtQmtNQzIrZlU3Qjkralc0RTJpU2FRTXh0WldLaVcxQ0xleHBtbVowaWxhcjFTak5iQjdVeHF0ZzZHU3l5clJ4cUFreSs4K0x6eXJlUXkzdEdUWGpaK05VaDAxTmhta1NIZ3RyU0JWZ2ZTYjdhU1ozbG5QcHVzbkppL0R6S21GaWhFUU9BNEhlTVZnbUo2WVVyS2VDVmVydGV6WWhoOE5odGh2dDRYa0g4SU94ejJDN2pMV0NmY2N6R2VwSGVQRTV2K3E2WHJCK2JDeFpsczNHcmdrYk14RnMvK3U2ZHUydWpVVmplNGJBVFF1eFZsUWhzci8zSHY5cXhCUHMvYmJyRUNtOTcrVUNtQklHUkJTaldnNk85eitFZmxNb3VQVGdpNkxBWnJPWjdSN2RBZXJ0c3BQSGRsNG5MN1dZWG1UQUdvRERQcmJUeDJKcXZhNU50RVlJN0RUbWVUNEtnWDNlODJOTTJIbWpwQUFhMWtqSEJKelJ2dkZ2N0tqSEJJeE9KaDhoVURJSTgxeUFkeEh2Z3V4Sm0rMnFxbW9XenZDQ215M2w2Q0VWOS9OdXNldXpTZkRDdWxUSXBTRVJSd0ZLMGZJbW5rTmNUajNibU5odllFR3dPVkhRaU1OSVcyd1ZObjZQSXlVMUkrT2N4UnNrbk9MOGwyTEd0RG5pY1hzSWw5cW5ydXRRbGlXYXBzSGhjSmpCdmlZSTlyczVQUHpRdW9zOWI1by95MEttOEMyclRRMy8yRmRSMzBISHc1OWpYTURVUGo4L2oxdER0NVRHc25zcTRmUndPSXpZaGQxWEVWRVdDSDVHanlEcTVZSVFTUU9vZUdSWk5uTHVaaFF1UjJVeC9jZ0d6TDRBUDdRdGlnZkVlSkNxZXU5OFA5NnRiSkpTYWw3aFd6WS9HaTdhQks5V3ExbnlSU01OMDJnYVlkaTRXZVhyV05rZnNuSFkzSmxQWVJHSElhNnNPVmw0WTR3alljWVlWSzdHamhPUE1iQUdVUFZnWExtZVZMbWtpM0hJd292UElSK2pjcnBMT0N4a084M2Y4UkMxWTdDeWdsQ3FXWFNCV1pPWlFERE9iNVBNNC9PMGxXa0RuanNQc2RRNG56VWdQMGRSRkZpdjErUDNMVExTcEpVbDRzYVVQWUJ1M1BWK1FzMDh1eDdhNFd5Z1F3Z1pXYm9XQm9vQTJEK2JLRTVnOE9MeVpLVlNwcXJDUXdnb3kzS01zMVh3MUlsUy9GMG4yL05oTk81WFQ5c0xYeGxrOHNBbzh3ZThzYkVHWUR4Zm5UbEZKNHVpR0oxTk5VVUwvK3dHM0ExRC9RZENTS1N3TWJwT1E4UVVFZWdFTW43TlBEUkR4VkowS05ZS3lnMVFUMXRoWUdhOTZpVHIvOVZQNEd0NjJEcWJCdmEwV2YwcXFLVUxZOS9qQldLVFlXUFM4ZkR6Y0U2Rm5kaXlMQmVaUzRYQ2ovdHZ6UDhnU2hqRUNSeWxQSUNLR1h5eWh0b21qUnc0eGNyK0FDK3lseDdtaWVSSjRzazhKZ0FXejZ0WDcrMVVCbU1ZVnVWRjBseEV5bmxWY0lqSHJidFRoVi9EUkU4WUdWcjJpa3JHNjNsK1FJaGtDZ0l4Z3NRSldOQzZuUWRrTDVXUk9ZOFBrR0xKOENKNEpCRmJFTjU5aklhbFdFanNJM0JDeFJhZWhZc25tUmZVR3cvakV0N2lxNitqeUtlWlN0WXNOcjZVR2RNUVZqZVMvVnhxZ0pnTUE4T2c4V2MrQUJQRFZSMTVML1lEVEJyWmRtbXFObVgzUFFLRm1SZFQrZVlMcU5wWHNJaUZ3c1BrbWVqaFViSTgrK3I5bnFMSWFXaXMyRUlxWWtndHZBcWFhak9iWXc5WU9zb3lIS3B0aWlrYkhHWjBBRmFKWGxtU1FwU3NsampYclpDbnFuUjFZalMwNFFWbVQ5amJrYnl3REJaeFFrWHJGVFFNWllEb0dHL0JKcDVObmtjM1U5YXp4eDFNVWVBOVFNcERFZWRtN29aWXpsRFZOQmFHQk1mQjYrdm4wa1VLN0tEWjdtR0hpL0g5RkRIQ2cxcjFZVGtSb2xXN0RMaFVWVFdPWWIvZnozd1pKVmQ2cXBySG1QTGtGYkZVVGFuZ2trSzYrcGxVZXZzbVBvWW5ERGNwMVl1amM4K0ZJV0hwQTRRUWtpVmp5bDVsNlBJWW1LT1p0eFR5NTRWUFhnakd1OS91WWI0SjR4SjhUeU5hZUQ2RXQwc1Y1azJaU1NXb3BqZ0luaG53dUEwZVdNYmhOdnN0bnFPYjFOckRlZ2NtaElRWTNDZ2daQUdoOVMvR25ubGQxNk9hMXNSSGF1RlRrNmRFRFU4SWxBeGh2c2VwQWhZV051MEZ3RGtOWGdTZTZGTzRnS1ovV1FCNWNiMXhwRGdPS2Z6Q3kxSWV5NG13aVJncmcwQTVmOTNvVTltMEx3Q2VCSEpJYUhiU3pJR0dqY3gxU3lWd2VORjU4Vlg5OHNLckEzYU0vWnZ5OW5VMzgzT21oSXZmWjE2a1loRWUzNStmUS9FSlJWTVYwZFJtRThlTFRLUXVZT1FBaEFBUDdqL20vTm5PMDhWa0RKeHRJRU9nNnVXeUVOZ0NLVWZRU3dkcmFPajlqVTJBVFpoWGlhU1loVmNZNG9Fdm52ZXVaRTRQaUZMRVVhT3BVK3Vnb2FDbjZVNEp3eFFGSUNZcFlaNWtjVUdEQWllbVJobnJUa0hBRE96d2hHbmxheW9FVWhPaDExWHFsVmRRd2d2dklXejZlWjFzRDhzd1I1T3hFY1V1ZUFFOUIxV0xTbmpqc2VrWTd4OU9PNVVoekRWQndacGhVVU53eEpOa2FXWlNvdmJFdVFsZXI4a2RSZjY4bnltYnpQOVBTYjg1ak1lQUpMVzFxWW9tWlRieGpsY2g4SHdvTHoyc0FxSjhCTlpnczN0SEpFbTNUQWJsOVM3WUFzREJBVklDb1lrZnoybGhLTlR3ZTU1MDVlN3BqdktTU09ZY3NsK2dkbDc3RmZEMURGQlNURUU5ZnAyRDFFOG1kVEE5ekVNSE5YcFJqOStyQWZUOEZVLzF1NTFBUEExQUlORFFKQ3JPa2o0cDlhOHFKY1gyVVMrZHExellYemhXVmFNSkk5NU5YamltYXAxM0RLdG5iOGQ3dUh6cXhhRWxmMVlMVFpSUW9yeEFqNy9vNFJFS1hxWENWazRzelRxVU9QekVTSEhnMENFa0VPOVh3aEdpQzNudDRsSnNIaTczNHNubkJlR3NucXBuRmlobDYvRDdHaU43QytsVkh5c0RtTTJDbHBMeDRtdWxzc2MvMEl5aForSzhCRlVxSXRHeU5RKzJqdEpnS2d4VlFWbWV1WEE3K3d2RnJCb3NhRGVKaVdodzA1WXJtZ2t6VzZ1WWdJWjZMQlJLeXRTcTNXTU9YU3FHUGxhODZUMFBteHhONWRvNHRRcGFvd0IyUXRrY3FCQ2tFbWVhRHRjb0piVVpEYjIxOHJBbENqUnhncWJDa0RBM0FJdmVmV0ZaUE1vMlNoTXZGc3B3cUtpMForWDgyK2M0YkdOU2FBcU9Ubm53VE1iMEdqcnFKR29veWNVYTlqdG41K3c5WStid3ptZUNTVjNYQ3hvY1A3c21zZGdCNUdJVVRxSHI4ODBFUHNaMElpZ09uVU5pWHlNNGFZQ0lHVGQ4VnBxTVJmOElONS9OWkV1dnkyVUs0OWJVTTZ2YlZDOEJKWm13V3JaRjh1ci9UeldoOE1nYnlrTG1TSVY1Z1dxNmpOZkhYRVN2dVJQWFAvQ3ptUWIxeHN6T3A5dGxaQ3pvOVIxQjh3VUtVL3ZLQ0Z1MFdVVll4QmxhVXMzT0N0UEUxR2FucU53OGNjd3JUTUhIcWVqRUExbU8rUzBlSm1FTGEreG0vcXhGRXA0M1h0ZTFteTVYeDVEaFlzMG1laUdza2xnWVhiVC9XMjNBQkg1NXFHV2NSWDFGQ2lic0sweXBHbld3R2JyZ1NyaFFLSmNGUUxXRGx3bFVrK0RScjFJOSttejNLZVRyZ1Q2bmV2SXdGbUNaUmI2SHFtZTdualhLVU9jeGhUdHdsVEZYOTU3cWtxS2grRWpRYlR0MFdYYzhINElwNGl2bWJ3byt6c2tMb1lXeWJULzFNcldzOUNwdngyb2RuWmRRNGQzRTNQMVVWSkRTSEZvTm5HcnJ3cXFXMDk2cVdWamxzOUJ5T3hqK0xoZVUybk43N04rYk9LajZMNWtnR3JHQWZqMExwZ2dGSEd1dDR0Y0dLcUJoRTNtcVdvZmZTM1c4VU9lSUhUS0ZUcG5jb1prM3RkRmFlc1dPTEF1ZDhmSDFHdG8xcEtGV2V0NnpXQXNZSnB4d29veDlHWWFTRmUzamNKZ1gzMXVUbElhTEhQRUZURkZBZENoaE0xWVEvQ2JRNmdRWk9LVFpNN1hUTE1WZXBrd0JGRThiOFBkUzFITTFCVHpXWS9FNDV5V3M2WkkyaU9CcjJPNVhkSTRqSVFDemdsSU5sUmxhOTFxOUt2ZUNOOE9NRHhpUUxEZWJDRUNocnd5YWdUOXhybDY5bnNCZWZNMlN5Z1BrQ2RZd3p1dWZ6L0UrSjBSNFVrMHJLTlZMZHdockRTOSsxdDQ4cWVKVGU1KzVnbDRQQTA3bG1xcTN1Z1kxbCtvTE1mZEJjUkY3Ums2cXBYWjZzTDdITVNRMUJCMFpnaGlZRkNvU29CUm1UeHExTWtqRExjWEFtUXpoWlFkNTEzSzBrRXA1Nmc3V3hJeDYxNmVnWG8vMXE0N2JNVGo1L1B4OFZpcW0vWkxZMmRPZUIxcHM2bkVaMU1HMWUzR3B1ckQ3dloxTERMQlpYY0FjNlBIaVlxOWZqOWI3S1lXYnZXbmJ0U3dZNnZSbzR3bUZQVS9sdUpQSkVTeTdtYkNxWjB4Qy8zYU1pOERqNHlvb1RXdHpub09SUUlhVGxhN09KQnR0SkhVNEhNYk5ZWFdEeDV4b1ZRQkdBQnFCSUszOEdiOGMwakNxY3UwVTBsUnYzK3YwWVVKakVLbUdQOHJvVFpNaDUreGsxUnBLVE5WaVQ3MjJwNDVUM0R2TmVXaFZNMS9mYXdObkM4K05NWGhPVk1NZERnZGNYMStQeGF2c1l5akdzQURQWXVBVEVGQkVQcnBGMUt2aHlaR3FTYnpzbU5idm1jMWxlcGpYV2RNcmR2QjJybGM1eEtpZjkzbEZHYjN1bjd3TFU5aENpb0Y3ckc3aVdOMGl6NDkyVW1NazFOTWNOdCs3M1E2SHcyRjBLajN0T1NhRW5ERGRpa0tHTURDTUh1Q2lCRnp5L0YwN24renRkb3ZENGJCb1VLUU1Gd1ZlT0RYS08wS2RyVlNLMVJNQzlmeDEwVlA0djFZb3B5QmpyOEZraW96aUZYVG96ay9Sdkt3ay9CaUoxdHVFV3ArUW9vZkgyUmxLZ1E2TThMcUJLTW9rdTIyMzIyRzMyNDA3aUhGdEJqdlVMOUJ1RjV5T3RRZXdCQXRyRTYybTVYcTlVNjlrV3ZURVoxT1pTSS9kazZveDhKSldxdDFTREdyMm5jeTByZGZyc1llUmx4dlJsbmVKT0ZCYXhXTHBCTTY2VnlYVW9uWUs4UndVQlR4U1JNOFFBbGFyRmRick5ZQytTNFoxRVV1eGRWTnRXVFNzVFBYNjhaeEhyMmhFQlVITDRKU3p3QnVIelNFN3RnWVFWVlUxdy9qVitXTXNoYU1LMnlRV2FtWjVObllKVForY0VzRnRmNHQ1VTRobFltVHFFTEpjZkt2RXNZa3dCOFhnVUZWMTVuaHh4TURtd09yZ3g1Q0doRXE3ZFhvMmxxTVJqLzZ0R3M1VXB4Y2VldmtFdnI3NkwxNFhWQlpHenQ0ZERvY1pOS3dhUTlGTzlzazR6YzVhb1NpSy9xQ0lvVXRvK21pZVlUV2psWVlsa2tFeFJ1a1lza3pwV2lkTkRtVTR6RE1OWU85cmlsWTdjaGxWN1ByNjJpV0Fzb1BFY0tvbW01U0ltZUlZS3FhZldsQXZtY1ZSaDFlNG1kcUJ0bWpjRGxhakp6MUlRcS9GdGw2N3Myb3lia21mTTBHTFEySElTQXFOaTJQSUlxSUxmeXF4SVZVM1p4ckNxK3J4NE9HdTY3RGRibWNMcHFhQ0Y5YnJPcTdBRWQvRFczRHRXYVI1QW81TXVHV00xLzdlS3pUVi9vbWU0OGdhMHVzYXdtYUE4d21LdTl5a05YNFlHNElNeWFCSUFKR2FnTllwdzRLVEViUkp0RVd3WGE5SHBiRUc4TTRIVWl4QUg1eDNvSmtKRTBBek96Z0tnczJqQktaWXE5ZXRzTEorUndFbXh2SlphRktuZ3luTWZPdldyWkU5NUcyUVV3RFlqTW1NNlhES3hmMkh2czkyUUVnUlpoZVkyOHV1YmRHUlI2bUVFWVkyZVlLMDc3L1NybFBIczNCT2dlRlFWdnZjUVZzaFV3MjVVclJwajY3TnBpUVZncWt3MlBPWVVIajR1OWNabEF0cUxPTzRYcS9IK043cnBHcWhMdFBSMUp5TkFtREliZXg4SjVBT29ad2RHaFZ4cE4zSUhFZGNMQUE3Y214LytPQXBENXJWaGtpbllHRWxqSG9Pazdkb3FWM3IwYys5TEdJcTVtZmlwMWM5cklMRXJLbXFxckJhclpEbk9iYmJMWGE3M1JqMWFNKy9GQkk3cDVwMUo5UEJZM2Y0QVEwc1prelNDQmUzVG5VSVpVU05FeE9zK3RsbU1XQmphbDJiSm5zT1cwcWRIK1BFcFJvcHBZUkFxV3U4K0I2R29DUlJCWUIwZ1hqWDJyeHROcHV4NlpQdGZpV2dIanVJaXZtVFZWV2hiU2N0a1M0U25RZ2dFWEhlTEJvSXJnYnd1aytwTThieHNXYi96UFl6UTViVnVlZUZNNUxta1VHVk9heGNmejIxVkFYU2F4SER0bGVkWDYyQ1R2M2tGckNhOXZWT1NsUG9XY21vcVRNQ2t0VHhXYXE0Y3hsQkl3NFlacldCY3hXZzhHNEljNkRZYSt0bWl6MXJYa2dEc01YM0tGUGVRM2xaUUNaQUt1aGoxL1ZPRE5IaVNzMFJNTXVYVTgxZVlrakwzYnhObzlDc3A4SDIrNzNiSlkyZlNiTjdXaFM2NEFQTUhHdW50d0NGZ3pHRzZmRG92aTRnSkZFMk85QlluUjh2aTZiaENQZkQ5UW85T0JabWJXT0lvQzI0UVo5ZXhiSHk1RFFKb3dkU2VFaGdxdTJjcG8xWmFMMnFZYTl3VTAyQWdXWTJ4eGJGOE5sR3BnbjFIc2ZPSFk2SnlHZWhBUWFmZnpJQmNja0puTUFXTE1BR3I4Y2YyM1pWby9aWmc0WlZ0WG45L3pqQzhFNENVWi9DMjQyc0RYalIxR3dwaDhIRCtsTmRVangwVUtscW5pclhneUNZVTZpTUpkVm1IQ2x3eU5yUFEweHpCZ01mSG8ycE5sQnpBZk1vWVBIbkdSU3M1K0lwWDQ0NWdrd0VaU2RMT1g5ZTg0UlVKR0YvUHh3TzR6MDlNOEE4QVUxWHEzT1phZ3FSMnZFYTRub0pKUytpNGZGcmpSL1BCU2Q0dkU3cmJBWjdiZGI2YlcrajlRSVowc0VCYzRhSXB3TEh4dEh3TzN6cEVhWWFBdkw3WFB5cHlLSFhNMEIzZ2FhVjFiNXpJa2NMVnhpWFoxS21sejNUcnVJNmtSekhhKy9mbEQvam9YeEtqUFdxcEt3SFUrb3NwUmpqZU9Da2ZZN05pUjhIOUQ3ZmRHeWNuRFo5cW5DQ1BYcnZuRHNqaVpocTRtcGdGUmdXQ2krRHB4ZzRxMzNOM0xHanlMa0pkYUs4Y25Ndlk2Z29vVmZIWjBMQ1JTRWErM3U4Umg2N050WlM1alBQSTVzdmo0N09CMzR1TUFUcEJGVE1HZ3NtZVB5cHVqNCtINEIzV2xtV09EczdBOUJYeWpBczZ2WDRWUzUreWs3eVJHbmpaUlkySm1TbXVvQnduWjhlNWFiZlRZV3NYdnNaZFU2OVdnS3ZGdkhZZkd1OW9kWksyRWJrcnFxY09lUnl0VEFEL21hazBPWEpvTWUwQVIvOXhpcDF0Vm9OcDFoWHMrcFpuU1N6MXl6UlhydFZYV1N0R2ZEeUN0WnZuMC9wOW5MN25qcGxBYkI4ZzAyZ3NweFZNRDFzUHNWSzh0clpLWUEyMmZObTVnemJuSE1ZYUdsdDR3WXdRY2NoQmRPeGNmRDVBS2Rham5rOWJ2VklFNjJLUGNhVDg5SzJpbWg1Q1JLT09PeGgxK3YxSWt1WjRnUjQvbzc2RHA2UWVJZFBlRWZYY090Y0ZVWVZBTk0wWHViMUdCQmtpODdSRFllUmNQT0JmVWhRdVBxZkgzRFdCd2h1T3RnOGJqNXdRWStJMHl3WSt3UHFCZHMxOUJ3ZEQzaGhLVmZWcjg3a01WdXI1eG1FRUVaK25wNDE1RlVaNjBKN1RDV3YyNWtXa2pJdTROVkJXT1JsMStFa2tER0I3TmhZSU4wcHRDOE5pOVFqQ1BQaTd5bWhNSldGUjRrUzFCbXh5ZUdhK05SaWF2elBPOG5EMGJVSnRVWWMzSC9JUSsxTUlOVjgyRTd4MkVOS0svTklvdHIrUlR1R2FKVGsxVmw0NXlIdys0cG5lRTBydTY0YktXRjJ5R2Z3S1AxakhVRGZCbmc4TjdEUEVTOHpYbEZJb3A0enlJeWVHQ05ldm56cFpzNjh5VWpsNmowVjZMVlc0VmF4cVVTTXBvbTlneHRUTGVCMExOb3l4dXRQbUZwOEZYYmxIM2k5amhpNFNsVXZ6K2JEY2plcEhFS2NDMEl4NTMySkV6TjBCVEZNdVJOMXhhcWUrL1I2VG8ybWlEM2hVRk9od0lvdU1DOCtPM3djRFhpOTluU0IyWlNaQThYMlhjMFlSeUJxanpuOFZGaGNJV3psRVhKdG9jZFQxSU9yTlQxdVBSMk9OWXFlSFJBT0tRLzNUZzBEL0VKRXBZcnJDZGdwZmtCS1JkODBqKzlCdlN3QWk2cG00dTRwVDA2aGJTOVU0L2plcTcvWDZ5amo2UlJMeVhOb1ZWQzFacExIakVTQ0xqbDNlbkRrVkN3YUZsM0NJcGE5ZmxORkNWNnUzMElZZGQ2OHc1TzlGbXdwV3JjbWViVC9ubmQyenpGaDRwM1A5OWNlaFV6VVVKNGhkd3N4WjA1ajltTnNJNDBjVWxDeVpValo0ZlhJb1NjYlIwY3JEZU1RVUpwRWpmMEI0WmRMN2ZmN01VYlcvTGs5cUlaNVdnNmVxb0x4S24zNGhBNVcwOHd2U0VHeWFxZTlJMlJTK1FHRlpUV1Q2YUY3SExXa2lLZkhOSUFud0R6MlZMMmh1OUhGQXNRUkVReFRhWmlkRU83aUFBbEoydS8zMk8xMnM4RjdkanBGOFVyeDdFNUIwTnBuU0p0S2VwVytUQ1JSTStCMUJ2ZUtWRGxrOU9vTFBBS0taaHRWdTZYSUhTblNwMmxXemxITTBVaEs3WGxkVllNSlFlejdBd1Q0U05DRTFZZWtLckdRejQ0eFp6V2E2dHpsTlh4S1pjKzhVemhTeDh1bXNtMk0xYXVIenBpQlZ2Tm9qMEFXT0dZa015Ujhhdkg0N0FSdjkyc2FYVW16M2oxbmFlTFlnVThNOVIzQjZTamc0Y3lnNkRvSWt6T1Y3ajF2a0tzUkd6MTZFNGRkcC9JTCtwQ2V0NTQ2eHRWcjdjcXFYWHNaY3lyYThIUHpZNHlZcWRRc3RmMXNoMVBkVDlsbUs0VmNONEl1OXJHalk5UVpuamdkSVFrQThScFBmUUpqSUhUSUV3Q1NSb0VMMlhOVzBxZEhydlFlUExWcjlUNWVWM0wxa0ZONHZDMnVXeXA5NUVSeXpyUnB1emNWUmozUmhLTVFieEd0cWNOTjJ0MnFwbE1jWk5iUUlnQlpOblYzOVdzREJ6TVFBemVKV2g0S3FUM3c0RURCTmhuZUtSMktqdkZFZWJudFZOZlBteHl4bHVMZGVlY1hjVDJEWmpZVm5PRzZCRjUwejg5Z0ZGQUpHNXFsWk1IbTRoZDlUaVdiS0lqR0dzM2pieTZSd0xuRkh6dUVCRGt5cUI5WWV5T1AyZ3VQamprMXFXNGJ1cXU4TUREVlI1OC81eldPU3ZVMFpQNkFubXZFNXlCcnJvQ3A4RnozejBBWFJ6MUtoR0cwVWxYN3NTTmdGSm5razhSbkR2eEEvVm1VaGtVRmdueFM4S0N1VDJla21LN2tkUVZqNy9nbURRODB0UEVBSWNZYlV2bCsvcXpYbWRzN2VVdEx3N1Y3bDljWlZLTW1qVEk4b0VhQk5VKzQ5VDdlZFZOakdITTRSM0VnNlJRYVJBTFl5VW5SbXoyVnhHcWZVNVBlWkh1TzM3RlFVWnNrY2hJbnhSZjB5SkdwSStEVm1kUjZmR1g4ZXU5cDZ0ZWJ0MlBPblpvZzcweGgxYUNMdFJyek5xZU9rWTlhSHE2azBQd29yc3lIRnlydW4rcUlvYVZPQ3Vha0RsVmtOSkpKS09vNUs5VmJOWWdIVjZjU01hblRUazN6cEk1NFNaMUI0SVhUZkIwdUp2SEt6VHhPZ2RyOVFOUStOM3dQM0NJaVVIV3dHNWVhNnB1YUR1bEVNRERCdTBYNzd5b2pKbFh6ZHF5WEgzZkowUDdBM203ekRteEtaU005WDBTRlVWdmNlVVRQMVBuQVhuMmdwMkZadTZUNkRpVTd0WXlDY0x3WFloZ2p1amdkR3VXeGdyUE1ZTjJZYkQ3SUlaNEJRaDdlN3pVL1BBWjVjaTllclN6MmlpTlNUcWNIcXFST0llVklSQVZBTTRTcExtSGVrVGZzVjJpa283NlNIalhqcGNhVndKTHFjT0llL0NXeVU4d3NRbEJQbmRWL0hKQ202VlZWMVVoSHNyYW9wcHBUdVhKVm1SNENxQlZIbnZid0tGakhCRlFadEI0VkxMWDc3Zm00TXdtSGgwcGhNKzJnYWQvVWFXYjhlNG8vY0lvaU5vdkVoQjA4ZHdKbkpFQVdnTGhnQlkvc2tobDhzQVNDeGlaRkRyMmE3YXpIbWswMWUvYnNxSHJRYlA4OFVxbnUzbE1aTXUvWWVMdTI5UzZ5T3Y3OWZqK2pwREZ0T3pxOENjL21ueUtyZXR4Sno5Rmx6UmFsMDhleU5DeEtPcGhBQWUwUHdDZUhxV1d4amw2TUJ1cURLZm5EODlhOXhneDZyS3ZYNUlGeGZJWmF2WXliVGpMZng2c2U0bEozZThiMWVvMnpzN014K2ZJZFhaQUFBQTM0U1VSQlZNVzVBY1lEUFBLcmNmeVltNkM4ZzFSNDdGVlpjWUpOTllzS2VxcE5YSXl4cDRSRjR2c0ZlTW1nTE9rb01TSERCSUJ0dEtaT0ZhNzFIQ1ZMK1hybFUxbzR3di9VaVVxRm5ubzBxeEpUbVpYRDRJcDE2T1JRTkZVSmRDeDVsam9KWE1lYnFwYnlTQ1plQVUwS0NCcitNdkFHd2RYQmMrWEFaSWJPa1NadGIyS05DMVZnV0VWcDJPVFJxclMzZnlwWjVJV25YdE1JM1dYYVBuNUpnc1VNdVd2YkZ0dnRkcVlWUEpwWTZnU3ZZOUVHSHhiTkF1NHRmZ3B0NVVob0hoTDIyem5aTE5xNmhZT1BEWE02aEljUUVNM21BdmpWcjM2RlBNK3gyV3h3Y1hHQjgvUHpzZUxYWTc1NlhjYzU5dmJvVmZ3d1hyWk1uU2F2eXRqREVUaFo1WFgvME9KTXhUYThJMlU5dmdEZlQrbHBPdVpqemlzem9WTlF1eDRVWWFkL0pVOXJHL29Eamo1QXBBTUVrRGd4Wk94aVhaYTRkZXZXS0FDM2I5L0cyZGtaTnB1TmE4ZlVEbmtRS0RPSHRGVzdUbmpmdkhyS2RPVlpoa3ppZEcvWGRkUTRhZEZRSVFUMzkya0hoaVMvUmhkcDFsbTFpNHNPSFhQZ0NtNXovNVJtNjY4LzVuekhFMXg0aDYrcUZVcnh4WkxFME9FalJZanMzMGZYWG5IZlB5Q2dLSEtVWlRXR2Z0cTcxMENKNkpRdzg4UjBYWWUyYVJCbHdyWFI4VXdBR0JZTllSU0ErZVIzZHNPK0hyNkw3cmw2VVJFMVlNR3FuWm12T05uVlpaZzZjU2M4Sjh6YjhhT0dNMm1JQVZrV1hIQ29vL0F1cFpWNnN4VkdDTmczUVFQZUUyS2ZEcDZXM2o4d3dvbzliU0ZYcXhXeUxCdHI3OHF5SEZ2S2h6aFhQWkVJbXlaMHJNN2FyaDBYUE10elpBcnRrcVRxNlZyYXdXU2NjTVJ4d2NmbnlPZDlFT01nQUt3UlVvUU1qN2d4bnFNd0hLWm5uZGU2UlhXdXdyQVRYSnU2OXNqRGQxQlFWM1BaTk1YbG9aUXhkV1JNaUFQL004ckJrWTRxV3EvWDQ4RUVaVkVNN0dHZ3lQdFpQZXozYUl0bUJocHhzY2tVWmRqZ0l0cDJlZURSSUcwTFo5RFRBQUdZN2NRUVJxR2VFVmhuQ3hBNHl2RlAxZlR3ZGIxL0Q0bjdaSXV1aXhQZlRtei9US2hJMDZSWVFmMkMwdWxvaUVtSWR6cmFyLy9pZUEwUEI3RER3WUswaVl0eWRuQ1daZGp0ZHJoMTZ3eHQyeTNTa0NFRUhKb2FSZGZoME5UajRHWjJLZmlMb3ExZXNpeERMZ2RWK2pTMGVibVR4eEpLaFdicXNJMjlrSjNFeVhoZU1wbUtpVElaWEcyaHUyODJGbXZlRkpZSGIzcE9uZWRVZXM4NHVnU0JFenJURzArZlB2Vmg1RGtmWURvM0xvUWw2ZURiYjU4ZmJXdVc2dDZ0cmRxV1RsSzNlSEF2UmFzNzBJdTEvWjBha3Q2MjZ5Z0s2OWRUMFo2am1Jb08xTHg0anA1MzlEeXppWmFuZ0lTajE5WnE1MU5uSkF4dDRud1A5K25UcC9qeDlVTjhzWWtCc29nd0l3bisrUHFoci8vRUFRd0J5UGpVc0lENDR3VDlmNlFIWXFUekFpeWUrTTF2Zm9PN2QrK09mV3k1N3Y2bXIzYTNSYjdlbkh6djcrbTEvZlFUVkhmdjNXaU03VzRMQURnOC9ncXJZZE5rSVVOVkZEZzBEWFpOamZXN0g3eVNjZFdmZklTejFRcUhwa0g0eFlQdmZMMy85cy8vVEQ1QXBCNUJnMXZZTjNlbzBUYjlPVFpOMitJWTdUSmkzbis2M1cwdDRKLzNwYTVXZmZpM253U2h2cnBFVnBiVHBNL2JGYVArNUNNVWVZNUQwMkwxN3Z2MEViM3JqUVlJYUVBVmdmMmZ2MFR4Mmh0WTNmOGxFT0FESjNLSDNaZGY0SGFSWTVYbnlFUEE5dTdiS0Y1Y29xbFdLUDd5RjFSWmh2MmYvb2p5d2ZzbnI1VWEvL2JmUDhGWkVaQ0hETnY5SGxuSTBIN3lFZXJOR2FvNzkzcE5IcmlCUjdqQm95OTdQQlJobGljTytNUHZmNDg4Qkx6Mit1dFlyZGNveXdwRm1TTVBHWkJsUXpnelhJY3FEWU9GSHhZMnZYeEJsU3B4T3AwT1FQUE4xK1AzNnM4K1Jhd0h0TERNa2JVTnFxS3ZXcS9yRmpFQVZaRmgrOVdYS0M5dUl3bzBPeFcxUnNUaC9pTkFNOE05Z3FVOHg5QzAzVzFSM0xxTnVtMkI2eGRUOHd5T3VNT1VQUnNCcmJmdTRNbkhIMkd6S3BDSEF0bUxQK0pGM2FCcEd6UWRFSXNjV2RzaC92NS9ZZlB1QndNUHI3OS9mWFdGYnZzQ3hlMDNrRy9XQzJ5MjIrNFFubndCeElCTFJDQUxJMlU3enpMRTdSYlhUeDczd2pWMStaMkZxcncyZ2NrK2NaNFRpSE5DU0grZjl1SG5lUFRvTTlULzViL2lmSE9PMWFwRVdWWElzeHc5UzN6YWZ6RktSUkZoMWZFVU15MzJDMUEvZjQ0UWdGVmVZbzBDWFFTNjdvQ3VBdzVOM3h0NDIzYm92cjNFK3QzMys0V2NFUnZtSUhaWTVtQXhJVVhnWkdqLzN0RE5aTnd0Y1NxZ0hORWx6SjhiTVFKMzcyRzcyNko1OUxELzYva0ZWbmZ2RForTDZBYWMvOFhMbCtORjQ4Q3R4SzNiYU5vVzhlckZpRzJ3ZHNKYmQ4Zk52ZjM0UTZ6eUhCSEEybmdQdDg1Ui8vRVAyRGMxT2pOYmthajl3ZEVEcnBJZ0V4Q0g5cUdYK3ozeTJLSCtILzhkOS83VGY4WjZ2VUsxbWxyQzBrWS83bUtZaEN6ekQ3MTZmM0dKOXF2SHFLcThWOFhZNGtYSVVSWTlDNmx1RzdSZE4zd3hvTWdETHYvdGZ5UDc1YnZ6aTQwN2VyNGR3Z2h2U3dlVTZMMm4vdzh6VFRFZk9YMGhBTGo3OW1ENnJuSDVmLzRWcTd2M2tKRWZFV1pzS2dmaUhmeUo4VHM2dVhmZXhuWVFxbWVmL2pzMkJWQUNPTngrRFdkUHZzVHUweitoYTN2VThJQ0E5UzhmSlBOWDdXNDdlMFFnVEpWQnBoSyszVzNSWlJuSzdVczgvdDMveEp2LytFOVk3eXNVWlFWa1hEOFFoczFGT3lSTys4UUVhcncyMmF2RGs2OVE3ZlpZRnpucTh6ZlFWQ3ZFTE1QWjR5K3dieUsyZCs0RElhSzZmSTc2K2Jjb3Nod3RnRjFUSS83bGErU2JqZmdBdzc0bU96T3FhMU9GSVl3YUs4N1VJMjJOd0wvVHJqM3E5VXhkMXNOYmQzRGR0Z2lzVld3RHhya2VpU0ZPUjcySE9Hb2lPOHVuSDJjWVRTNEE0S2MvdzlPUFA4TDU5Ujc3ZXpsZTNuNTkwb1ZkaC9ENXA3ajZ0OThqb3ZjZGVtWFZONDhxUW81RFd5OFV3WFJxMlBBWTE5dHJORm1Pc0kyNENBWHFmL2tYYk42NHdQa3ZIcURZbkwwYWwvdldiZXp5TGI3OThoR0taOC9RZEIzeUxNT0wwR2ZEeXVjdjBIUXRydG9XSVdTb2Z2SUdEcmR1by96cUMxejk4UStvM3JrLzIyVTRtclQ5SzRNanJaRTdsa3U5ZWNEMTZzS1ZPL2Z3Rk1EK1gzK1BpL1VLdUhnTlhWV2hxVmJBV3o4YlpMUkRkWFdKN01VVmR2VkVxdGx6VnhackZzMzJ2OC9SUjlUb1VCWTVYdDlzc0ZvVktCR0FyNzVBL0lmM1h0bHpaS3Mxc3VGNk5vajY2aEx0azhjSW9VYVg1OWo4OGdFaWdPdmRGdGp2RU45K0I4VnVpLzNEejhkNUxkKzVqM3k5ZVVWVEhHK3dWcWZ2WkdGaUg5MThQOWhLOWVBOTdBSHNQLzRJWmQ1RHlxdWl4T0huOXdFRTdDOWV3L3JxRXJ1NkhpT29DZ3RDRUo4WTBrdEYrYk03cVAvOEJJY0FYQjkyT094S3ZQYmdQYlJQdjBGNWRZbnk0dmIzRm91WEY3ZmQ2MnRzSGk0dWtKM2QrbDdIOHJlKzJ0MFc5UmNQVWVVNTZxNXpRc0ZYUEdkNVpta3k0T0xDRWhzb3YzcUVxLzErWFB4cG84OUZnSTZPblhpLzFaMTd5Ty9lUWZibW0xZ05ONmp1M3V1N1o5NUFDR3dIZUl2M1hWLzVlcE84NWltd3FkMXQwZFUxdWo4L1FSYUFQTXR3VmxYb0luQm9HdXpYYXhTdnZmNmR4bng0K0JDcnNzY3VnaTNJOXlsc1RZdFYyZS9qdzdObktDK2Y0OUMycUgveEFLV0xCRS9uQnNjSUZISGtBMFI0UFVQenpSbnk5UnJkbzg5NkRrRFhZZmZrTWZJN2QyZUMwTzYyQ0krLzdGVjUweUxQZXNyV2Y4UXV1S213TlY4OHdxb29VSzRxNUZuV2g1eEQzcjNNTTJDM0EzYVBzYXRyck4vNzRLOUdNdHZkRnFzeUh4M084clhYdjlmbjdiNThoSFZab2l4NmJrWTcvTnMzRGRaSERkZ1FJd1dnQ0I2aTVnVHczYTF6SEY2K1FCNEM4aXlnZWZ3WVdWbWllZjV0Ly8wWFY2anlIRzNYb1NyNk5PU2hhVkcrYy84L0JNYk5OaHVzN3R3N1BtRmQ3QmM2aEg3aEViR3ZheHlhRnV2M1BrQjlkWW5tOFdOVTk1ZGo3dXI2cUFEcy92UWh6bFlWaXArODJiL3g3Q2s2MFlhSGh3OVIzYi8vbmJYaTdrOGZqblBjeFE3N3VrUGRkc2dDMEdSNUR6NGxmZElwL1IvajdNQ0laY0pvMWpKbXUwV0dmc2QwZVk3Tmd3ZmpReFY1d05scWhaenlCYnU2d2FvTWFMNThoTzZuZDc0M2UxMWZYU0xiYk5CZFhtRjdlZFdIMFVXQjZ1NDkxSThlams0aUFHemUvd0QxTUlHbU50dXVHNFUwNVlQWTMyN2szTDY0UWhmUmI0YXZuK0Q2Y01ENjNRK3cvZWhEcktzQzhmR1g2TkF6cXRxdXc3NXVFQzR1VGdxdlBTdStmb0oxV2FKdUczUzN6bEVPMzF2Wk9HL293OGFCV0RObkJVY3hBTnd3NHMyMzBENTVncXJNQUVSa0R6OUZrZVZBTmQweVpBSGJ1KzlnL2VWRFJFUWMxcHNiUGRoM2RSeHhjUnR3N3BPLzUrOEVWdS9aYm92bStiZmZlVmV1My9zQUhZQ3JxMHQwMXk4UnI2NFFJMURkdjQvdHA1K2d5SHNmYTFPVjZNNHZjRGkvalpCbFdBT29Mci9GN3RPUEVlKytQWTdETXpubHhXM3NuandHMEtEdEl2S3pXMzlEa28xSXdERktxMWdOWCtYbWVWVWhQUGtLcTZKRU52eTlldU9OWGhQY2ZoMTJMa1VYZ2QyaHdlWVg5L0QzL2pybVZMNEtnV3gzVzZ3UXNhb3ExRy9meHk2UlZTM3lITTJnSFFDZ2FUdlVNUzU4TFJQZUVzRDJvdytSWlFGMWpBdWY1V2FpRUZBRUJqdG5FWUprd0Q3K0VFV1dvY1BVbTc2TEhmRDBHNnpLRXB2ckYyalB6b0dycXo1MW1RSDdKMTk5N3hyZy93VUJxOS84S2E2L2ZvSmJYMzJCTFBTYXNtMkhhcUFzb0g3alRhektBbDBYUndkMFJZN2w5dE5QVUx6NTFzSU1GWGZ2L20ybWRjalo5SlN3NEtEV2NRbDRsRCsvM3hkanJEZG9kMXZzdm5qWXc2a1hGOGp1M0VNOTJLaThQbUJkVmxpWEJkcjZnT3RQUGtMMjlqdC8xMXlBNy91VmxTV2FXK2ZZYmEvNzBqSnI3SlFYZlV1M3I1OWcyL1hlZTM3bjdzeTVYU0gyd3ZETjE5aCs4eGRzZnZuZ3IvWkxYSEJ5d0tlTFdTb3ZVbVl0aGhtTE5WOXZwdHE4OVFhNTQybWErdHZ1dHFnZlBVUlY1TWl6RFB1SEQ3RjUvN3NUSk5qZS9iMFRUSTZaR1hiVW1IMFEvL1FoOG0rK1J2Zk4xelBIYmhTa0c3YlR2WWtDR0ErTm1xTkVDb3ZHdi8yQjMvc0F1NDgvUk80Y05mUFh2dllmZjRTcXlGRm1HYW84eDZGdGUwY0Q2TDNoQ0JRL3Y1bVdXWkJRL281ZXNTaVFoVERHOVhYYnQrcHR1NjczcWQ1L05TeWowY0tIZ1A4TENiWWs4cE5DRXZrQUFBQUFTVVZPUks1Q1lJST0=","base64")
    }
};

counter = Object.keys(images.tex).length + Object.keys(images.sprites).length;
interval = null;

Number.prototype.clamp = function(min, max)
{
    return Math.min(Math.max(this, min), max);
}

function loadVert(v)
{
    return { x: v[0], y: v[1], z: (v[2] || null) };
}

function loadWalls(l)
{
    let res = [];
    
    for ( let i = 0; i < l.length; i++ )
    {
        if ( l[i].length == 3 )
            res.push({ begin: loadVert(l[i][0]), offset: geom.point.sub(loadVert(l[i][1]), loadVert(l[i][0])), height: l[i][2], colType: 'flat' });
        
        else if ( Array.isArray(l[i][3]) )
            res.push({ begin: loadVert(l[i][0]), offset: geom.point.sub(loadVert(l[i][1]), loadVert(l[i][0])), height: l[i][2], colType: 'flat', color: l[i][3] });
        
        else
            res.push({ begin: loadVert(l[i][0]), offset: geom.point.sub(loadVert(l[i][1]), loadVert(l[i][0])), height: l[i][2], colType: 'textured', texture: l[i][3] });
    }
    
    return res;
}

function imageLoaded()
{
    counter--;
    
    if ( counter < 1 )
    {
        main = function main(map)
        {
            window.d = false;
            window.l = false;
            
            if ( interval != null )
                clearInterval(interval);
            
            var walls = loadWalls(map.walls);
            var sprites = map.sprites;
            
            for ( let i = 0; i < sprites.length; i++ )
            {
                sprites[i].pos = loadVert(sprites[i].pos);
                sprites[i].image = images[sprites[i].type];
            }

            var camPos = loadVert(map.camera.pos);
            var camAngle = map.camera.angle * Math.PI / 180
            var swipe = map.camera.swipeWidth * Math.PI / 180;
            var camFov = map.camera.fov * Math.PI / 180;
            var mapSprites = map.sprites;
            var lights = map.lights || [];
            
            for ( let i = 0; i < lights.length; i++ )
                lights[i].pos = loadVert(lights[i].pos);

            var curAng = camAngle;
            var angDelta = 0;
            var velocity = { x: 0, y: 0 };
            var fVel = 0;
            var breath = 0;
            var breathDelta = 0;
            
            var i = 0;

            var keys = [];

            var cnv = document.getElementById('rayCanvas');
            var ctx = cnv.getContext('2d');
            
            interval = setInterval(function() {
                raycaster.raycast(cnv, walls, camPos, curAng, camFov, ctx, mapSprites, images.sprites, images.tex, lights);
                
                if ( checkKey(39) )
                    angDelta += 0.12;
                
                if ( checkKey(37) )
                    angDelta -= 0.12;
                
                if ( checkKey(38) )
                    fVel += 0.9;
                
                if ( checkKey(40) )
                    fVel -= 0.9;
                
                curAng += angDelta;
                
                if ( checkKey(16) )
                {
                    fVel = (fVel * 2).clamp(-2.2, 2.2);
                    angDelta = (angDelta * 1.5).clamp(-0.1, 0.1);
                }
                
                else
                {
                    fVel = fVel.clamp(-1.2, 1.2);
                    angDelta = angDelta.clamp(-0.05, 0.05);
                }
                
                angDelta *= 0.5;
                fVel *= 0.8;
                
                velocity = geom.point.mul(geom.point.fromAngle(curAng), fVel);
                
                // document.getElementById('camPos').innerHTML = "(" + camPos.x + "," + camPos.y + ")";
                // document.getElementById('camAng').innerHTML = (curAng * 180 / Math.PI) % 360 + " degs";
                
                var collides = false;
                var colliders = [];
                
                if ( Math.abs(fVel) > 0.001 )
                {
                    for ( let i = 0; i < walls.length; i++ )
                        if ( geom.lineSeg.collides(walls[i], camPos, 0.8) && geom.point.dot(velocity, geom.point.sub(geom.lineSeg.closest(walls[i], camPos), camPos)) > 0 )
                        {
                            collides = true;
                            colliders.push(walls[i]);
                            // document.getElementById('colDot').innerHTML = geom.point.dot(velocity, geom.lineSeg.closest(walls[i], camPos));
                        }
                        
                    if ( collides )
                    {
                        if ( colliders.length > 1 || geom.point.dot(geom.point.unit(velocity), geom.point.unit(geom.lineSeg.closest(colliders[0], camPos))) > 0.8 )
                            velocity = { x: 0, y: 0 };
                        
                        else
                        {
                            let slide = geom.point.unit(colliders[0].offset);
                            
                            if ( geom.point.dot(slide, velocity) < 0 )
                                slide = geom.point.inverse(slide);
                            
                            velocity = geom.point.mul(slide, geom.point.len(velocity));
                        }
                        
                        // document.getElementById('slideVel').innerHTML = "(" + velocity.x + "," + velocity.y + ")";
                    }
                    
                    // document.getElementById('camVel').innerHTML = "(" + velocity.x + "," + velocity.y + ")";
                    
                    camPos.x += velocity.x;
                    camPos.y += velocity.y;
                    camPos.z = Math.sin(breath) * 2;
                    breathDelta += geom.point.len(velocity) / 25;
                    breath += breathDelta;
                    breathDelta *= 0.975;
                }
            }, 65);

            function checkKey(c)
            {
                return keys.indexOf(c) != -1;
            }

            keyUp = function keyUp(evt)
            {
                while ( keys.indexOf(evt.keyCode) != -1 )
                    keys.pop(keys.indexOf(evt.keyCode));
            }

            keyDown = function keyDown(evt)
            {
                if ( keys.indexOf(evt.keyCode) == -1 )
                    keys.push(evt.keyCode);
            }

            document.onkeydown = keyDown;
            document.onkeyup = keyUp;
        }
        
        download = function download()
        {
            let host = document.getElementById('mlhost').value;
            let id = document.getElementById('m_id').value;
            
            if ( host != '' && id != '' )
            {
                mapList(host, function(conn) {
                    conn.send("RETRIEVE:" + id);
                    
                    conn.onmessage = function(msg, isBin) {
                        if ( !isBin )
                        {
                            msg = msg.data;
                            
                            let res = msg.split(':')[0];
                            
                            if ( res == "ERR" )
                                document.getElementById('mlstatus').innerHTML = '<b style="color: red;">' + msg.slice(msg.indexOf(':') + 1) + '</b>';
                                
                            else
                            {
                                document.getElementById('mlstatus').innerHTML = "SUCCESS";
                                main(JSON.parse(document.getElementById('jsonin').value = msg.slice(msg.indexOf(':') + 1)));
                            }
                        }
                    }
                
                    return true;
                })
            }
        }

        defmap = JSON.parse("{\"walls\": [[[128, 104], [128, 120], 5], [[128, 120], [144, 120], 5], [[144, 120], [144, 104], 5], [[176, 104], [144, 104], 5], [[176, 104], [176, 64], 5], [[128, 104], [104, 104], 5], [[104, 104], [88, 88], 5], [[88, 88], [64, 88], 5], [[64, 88], [56, 96], 5], [[56, 96], [40, 96], 5], [[40, 96], [32, 88], 5], [[32, 88], [32, 72], 5], [[32, 72], [40, 64], 5], [[40, 64], [56, 64], 5], [[56, 64], [64, 72], 5], [[64, 72], [88, 72], 5], [[88, 72], [104, 56], 5], [[104, 56], [144, 56], 5], [[176, 64], [168, 56], 5], [[168, 56], [160, 56], 5], [[144, 56], [144, 40], 5], [[144, 40], [160, 24], 5], [[160, 56], [160, 48], 5], [[160, 48], [168, 40], 5], [[168, 40], [200, 40], 5], [[160, 24], [200, 24], 5], [[200, 24], [200, -8], 5], [[200, -8], [264, -8], 5], [[200, 40], [200, 72], 5], [[200, 72], [264, 72], 5], [[264, 72], [280, 56], 5], [[264, -8], [280, 8], 5], [[280, 56], [280, 40], 5], [[280, 8], [280, 24], 5], [[280, 24], [304, 24], 5], [[280, 40], [296, 40], 5], [[304, 24], [344, 56], 5], [[296, 40], [320, 56], 5], [[344, 56], [376, 56], 5], [[376, 56], [376, 96], 5], [[320, 56], [320, 96], 5], [[360, 56], [352, 72], 5], [[352, 72], [360, 88], 5], [[360, 88], [352, 96], 5], [[320, 56], [328, 72], 5], [[328, 72], [336, 88], 5], [[336, 88], [328, 96], 5], [[320, 96], [328, 96], 5], [[352, 96], [376, 96], 5], [[352, 96], [352, 120], 5], [[328, 96], [328, 120], 5], [[328, 120], [304, 120], 5], [[352, 120], [376, 120], 5], [[376, 120], [376, 152], 5], [[304, 120], [304, 152], 5], [[328, 120], [328, 144], 5], [[352, 120], [352, 144], 5], [[368, 160], [376, 152], 5], [[312, 160], [304, 152], 5], [[312, 160], [336, 160], 5], [[368, 160], [352, 160], 5], [[352, 160], [352, 184], 5], [[328, 184], [328, 184], 5], [[352, 184], [328, 184], 5], [[328, 184], [328, 160], 5]], \"sprites\": [{\"type\": \"sphere\", \"size\": 2.3, \"pos\": [336, 176]}], \"camera\": {\"pos\": [136, 112], \"angle\": 0, \"fov\": 80}}\n");
        
        let url = new URL(location.href);
        let id = url.searchParams.get("mapid");
        let mlhost = url.searchParams.get("maplist");
        let map = url.searchParams.get("mjson");
        
        if ( id != null && mlhost != null )
        {
            console.log("Loading map of ID '" + id + "' from map list server: " + mlhost);
            
            document.getElementById('mlhost').value = mlhost;
            document.getElementById('m_id').value = id;
            
            download();
        }
        
        else if ( map != null )
        {
            document.getElementById('jsonin').value = map;
            
            main(JSON.parse(map));
        }
        
        else
            main(defmap);
    }
}

function mapList(host, callback)
{
    if ( "" in host.split(':') )
        return;
    
    let conn = new WebSocket('ws://' + host, ['soap', 'xmpp']);
    
    conn.onopen = function() {
        if ( !callback(conn) )
            conn.onmessage = onMapListMessage;
    }
}

for ( let i = 0; i < Object.keys(images.tex).length; i++ )
{
    let k = Object.keys(images.tex)[i];
    let src = images.tex[k];
    
    images.tex[k] = new Image();
    images.tex[k].onload = function() {
        /*
        let tex = images.tex[k];
        let tc = document.createElement('canvas');
        let tctx = tc.getContext('2d');
        
        tc.width = tex.width;
        tc.height = tex.height;
        
        tctx.drawImage(tex, 0, 0, tex.width, tex.height);
        
        images.tex[k] = {
            image: images.tex[k],
            canvas: tc,
            ctx: tctx
        };
        */
        
        imageLoaded();
    };
    images.tex[k].src = src;
}

for ( let i = 0; i < Object.keys(images.sprites).length; i++ )
{
    let k = Object.keys(images.sprites)[i];
    let src = images.sprites[k];
    
    images.sprites[k] = new Image();
    images.sprites[k].onload = imageLoaded;
    images.sprites[k].src = src;
}

}).call(this,require("buffer").Buffer)
},{"./geometry.js":1,"./raycaster.js":3,"buffer":5}],3:[function(require,module,exports){
var geom = require('./geometry.js');

var fogColor = [0.6, 0.6, 0.6];
var wallColor = [0.9, 0.125, 0];
var groundColor = [0.01, 0.01, 0.22];
var ceilColor = [0.7, 0.85, 0.9];
var nearFog = 48;
var farFog = 104;
var darkDist = 96;
var brightDist = 1.5;

function lerp(a, b, x)
{
    return (x * (b - a)) + a;
}

function interpolateColor(a, b, x)
{
    if ( x > 1 )
        x = 1;
    
    if ( x < 0 )
        x = 0;
    
    return [
        a[0] + x * (b[0] - a[0]),
        a[1] + x * (b[1] - a[1]),
        a[2] + x * (b[2] - a[2])
    ];
}

function between(a, b, x)
{
    return ((x - a) / (b - a)).clamp(0, 1);
}

function rayAngle(angle, x, fov, width)
{
    return angle + Math.atan((x / width * 2 - 1) * Math.tan(fov / 2));
}

function angleToX(relAng, fov, width)
{
    return width * (Math.tan(relAng) / Math.tan(fov / 2) + 1) / 2;
}

var l = true;

function rayDist(pos, camAngle, rayAngle, dest)
{
    return geom.point.len(geom.point.sub(pos, dest)) * Math.cos(Math.abs(rayAngle - camAngle));
}

function rowDist(y, height)
{
    return 15 * height / (height - y);
}

function flatPos(y, height, angle, pos)
{
    return {
        x: pos.x + Math.cos(angle) * rowDist(y, height),
        y: pos.y + Math.sin(angle) * rowDist(y, height)
    };
}

var textures = {};

function addTexture(name, href)
{
    var img = new Image();
    img.src = href;
    
    img.onLoad = function() {
        var canv = document.createElement('canvas');
        canv.width = img.width;
        canv.height = img.height;
        
        var ctx = canv.getContext('2d');
        ctx.drawImage(img);
        
        textures[name] = (ctx.data);
    }
}

bLogSpr = false;

function colorHex(number)
{
    number = Math.floor(number * 255);
    
    if (number < 0)
        number = 0xFFFFFFFF + number + 1;

    var res = number.toString(16).toUpperCase();
    
    if ( res.length == 1 ) 
        return "0" + res;
    
    return res;
}

function raycast(canvas, walls, camPos, camAngle, fov, ctx, sprites, spimes, textures, lights) // :D
{
    var id = ctx.createImageData(1, 1);
    var data = id.data;
    var planeX = Math.cos(camAngle + Math.PI / 2) * Math.tan(fov / 2);
    var planeY = Math.sin(camAngle + Math.PI / 2) * Math.tan(fov / 2);
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 1;
    
    var y = null;
    
    for ( y = 0; y < canvas.height / 2; y++ )
    {
        var color = interpolateColor(ceilColor, fogColor, between(nearFog, farFog, rowDist(y, canvas.height / 2)));
        var bright = (darkDist / rowDist(y, canvas.height / 2)).clamp(0, 1);
        
        color[0] *= bright;
        color[1] *= bright;
        color[2] *= bright;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width - 1, y);
        ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2])
        ctx.lineWidth = 1;
        ctx.stroke();
        
        /*
        for ( let bx = 0; bx < canvas.width; bx++ )
        {
            let fpos = flatPos(y, canvas.height / 2, rayAngle(camAngle, bx, fov * (canvas.width / canvas.height), canvas.width), camPos);
            let bright = 1;
            
            for ( l in lights )
                bright += l.strength / geom.point.sqlen(geom.point.sub(fpos, l.pos));
            
            bright = bright.clamp(0, 3);
            
            if ( bright > 1 )
            {
                ctx.fillStyle = "rgba(1, 1, 1, " + ((bright - 1) / 2).toString() + ")";
                ctx.fillRect(x, startY, 1, wsize);
            }
        }
        */
    }
    
    for (; y < canvas.height; y++ )
    {
        var prog = (canvas.height - y);
        var color = interpolateColor(groundColor, fogColor, between(nearFog, farFog, rowDist(prog, canvas.height / 2)));
        var bright = (darkDist / rowDist(y, prog)).clamp(0, 1);
        
        if ( bright <= 1 )
        {           
            color[0] *= bright;
            color[1] *= bright;
            color[2] *= bright;
        }
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width - 1, y);
        ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2])
        ctx.lineWidth = 1;
        ctx.stroke();
        
        /*
        for ( let bx = 0; bx < canvas.width; bx++ )
        {
            let fpos = flatPos(prog, canvas.height / 2, rayAngle(camAngle, bx, fov * (canvas.width / canvas.height), canvas.width), camPos);
            let bright = 1;
            
            for ( l in lights )
                bright += l.strength / geom.point.sqlen(geom.point.sub(fpos, l.pos));
            
            bright = bright.clamp(0, 3);
            
            if ( bright > 1 )
            {
                ctx.fillStyle = "rgba(1, 1, 1, " + ((bright - 1) / 2).toString() + ")";
                ctx.fillRect(x, startY, 1, wsize);
            }
        }
        */
    }
    
    var nextProx = null;
    var screenDists = [];
    
    for ( let x = 0; x < canvas.width; x++ )
    {
        let ang = rayAngle(camAngle, x, fov * (canvas.width / canvas.height), canvas.width);
        
        let ray = { begin: camPos, dir: geom.point.fromAngle(ang) };
        
        let curDist = 0;
        let realDist = 0;
        let curLine = null;
        let curInter = null;
        
        for ( let j = 0; j < walls.length; j++ )
        {
            let intersection = geom.lineSeg.split(ray, walls[j]);
            
            if ( intersection != null )
            {
                let ipos = geom.ray.intersectionPos(ray, walls[j]);
                let distance = rayDist(camPos, camAngle, ang, intersection);
                let rdist = geom.point.len(geom.point.sub(camPos, intersection));
                
                if ( curLine === null || rdist < realDist )
                {
                    curDist = distance;
                    realDist = rdist;
                    curLine = walls[j]
                    curInter = intersection;
                }
            }
        }
        
        if ( curLine !== null )
        {
            let fog = 1 - between(nearFog, farFog, realDist);
            screenDists.push(curDist);
            
            if ( fog > 0 )
            {
                let normWSize = Math.round(2 * canvas.height / curDist);
                let wsize = Math.round(curLine.height * canvas.height / curDist);
                let startY = Math.floor(canvas.height / 2 - curLine.height * canvas.height / curDist - camPos.z + 1.5 * canvas.height / curDist);
                
                let proxBright = geom.point.len(geom.point.sub(camPos, curInter)).clamp(0, 2.75) / 2.75;
                let bright = (Math.abs(geom.point.dot(geom.lineSeg.normalTo(curLine, camPos), { x: 1, y: 0 })) * 0.7 + 0.3) * proxBright * (1 - (curDist / darkDist)).clamp(0, 1);
                
                for ( let i = 0; i < lights.length; i++ )
                {
                    //if ( geom.point.len(geom.point.sub(curInter, lights[i].pos)) <= lights[i].radius )
                    //{
                    let rs = lights[i].radius / geom.point.len(geom.point.sub(curInter, lights[i].pos)) * lights[i].strength;
                    
                    if ( rs <= 0 )
                        continue;
                    
                    bright += rs;
                    //}
                }
                    
                bright = bright.clamp(0, 6);
                
                if ( nextProx == null )
                    nextProx = proxBright;
                
                if ( proxBright < nextProx )
                    nextProx = proxBright;
                
                let color = null;
                
                if ( curLine.colType == "flat" || !curLine.colType )
                {
                    if ( curLine.color )
                        color = Array.from(curLine.color);
                    
                    else
                        color = Array.from(wallColor);
                    
                    ctx.globalAlpha = fog * fog;
                    ctx.fillStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2]);
                    ctx.fillRect(x, startY, 1, wsize);
                    ctx.globalAlpha = 1;
                }

                else if ( curLine.colType == "textured" && Object.keys(textures).indexOf(curLine.texture) > -1 )
                {
                    let tex = textures[curLine.texture];
                    let wx = Math.round(geom.point.len(geom.point.sub(curInter, curLine.begin)) * curLine.height);
                    let tx = wx % tex.width;
                    
                    ctx.globalAlpha = fog * fog;
                    ctx.drawImage(tex, tx, 0, 1, tex.height, x, startY, 1, wsize);
                    ctx.globalAlpha = 1;
                }
                
                if ( bright > 1 )
                {
                    if ( !window.d ) { console.log(bright, ((bright - 1) / 5)); window.d = true; }
                    ctx.fillStyle = "#FFFFFF" + colorHex(((bright - 1) / 5) * fog * fog);
                }
                
                else
                    ctx.fillStyle = "#000000" + colorHex((1 - bright) * fog * fog);
                
                ctx.fillRect(x, startY, 1, wsize);
            }
        }
    }
    
    var spritesToRender = [];
    var theta = rayAngle(camAngle, 0, fov, canvas.width);
    
    for ( let i = 0; i < sprites.length; i++ )
    {
        let sprite = sprites[i];
        let offs = geom.point.sub(sprite.pos, camPos);
        let depth = geom.point.len(offs);
        let ang = Math.atan2(offs.y, offs.x);
        
        let invDet = 1.0 / (planeX * Math.sin(camAngle) - Math.cos(camAngle) * planeY)
        
        let transformX = invDet * (Math.sin(camAngle) * offs.x - Math.cos(camAngle) * offs.y);
        let transformY = invDet * (planeX * offs.y - planeY * offs.x);
        
        let absAng = Math.min(Math.abs(ang - camAngle), Math.abs(camAngle - ang));
        let distance = geom.point.len(offs);
        
        let screenSprite = Object.assign(sprite, {});
        screenSprite.camDist = transformY;
        
        if ( transformY > 0.1 )
        {
            screenSprite.renderX = Math.round((canvas.width / 2) * (1 + transformX / screenSprite.camDist) - (spimes[sprite.type].width / 2 / transformY));
          
            //if ( screenDists[screenSprite.renderX] > screenSprite.camDist )
            //{
            // document.getElementById('shadow').innerHTML = screenSprite.renderX + " (" + offs.x + "," + offs.y + " [" + transformX + "])";
        
            screenSprite.scale = sprite.size * canvas.height / spimes[sprite.type].height / screenSprite.camDist;
            screenSprite.distance = distance;
            
            spritesToRender.push(screenSprite);
            //}
        }
    }
    
    spritesToRender.sort(function (a, b) { return b.distance - a.distance; });
    
    for ( let i = 0; i < spritesToRender.length; i++ )
    {
        let spr = spritesToRender[i];
        let img = spimes[spr.type];
        
        let x = spr.renderX;
        let y = (canvas.height + canvas.height / spr.camDist * 3) / 2 - img.height * spr.scale;
        
        let fog = 1 - between(nearFog, farFog, spr.distance);
        
        /*
        if ( !bLogSpr && spritesToRender.length > 0 )
        {
            console.log(spr.type, x, y);
            bLogSpr = true;
        }
        */
        
        if ( fog > 0 )
        {
            ctx.globalAlpha = fog;
            
            for ( let wx = 0; wx < img.width * spr.scale; wx++ )
                if ( screenDists[x + wx] > spr.camDist )
                    ctx.drawImage(img, wx / spr.scale, 0, 1, img.height, x + wx, y, spr.scale, img.height * spr.scale);
            
            ctx.globalAlpha = 1;
        }
    }
}

module.exports = {
    raycast: raycast,
    addTexture: addTexture
};

},{"./geometry.js":1}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":6}],6:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}]},{},[2]);
