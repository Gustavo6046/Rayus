(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * Geometrical Structures:
 * 
 *  - Point {x, y}
 *  - Line Segment {begin (Point), offset (Point)}
 *  - Ray {begin (Point), angle (Number)}
 *  - Line {begin (Point), dir (Point*)} 
 *     *used as an unit vector
 * 
 */



var opers = {
    point:
    {
        add: function add(a, b) {
            return {
                x: a.x + b.x,
                y: a.y + b.y
            };
        },
        
        sub: function sub(a, b) {
            return {
                x: a.x - b.x,
                y: a.y - b.y
            };
        },
        
        mul: function mul(v, x) {
            if ( (typeof x) == "number" )
                return {
                    x: v.x * x,
                    y: v.y * x
                };
            
            else
                return {
                    x: v.x * x.x,
                    y: v.y * x.y
                };
        },
        
        div: function mul(v, x) {
            if ( (typeof x) == "number" )
                return {
                    x: v.x / x,
                    y: v.y / x
                };
            
            else
                return {
                    x: v.x / x.x,
                    y: v.y / x.y
                };
        },
        
        dot: function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        },
    
        cross: function cross(a, b) {
            return a.x * b.y - a.y * b.x
        },
        
        len: function len(v) {
            return Math.sqrt(opers.point.sqlen(v));
        },
        
        sqlen: function sqlen(v) {
            return Math.pow(v.x, 2) + Math.pow(v.y, 2);
        },
        
        unit: function unit(v) {
            return opers.point.div(v, opers.point.len(v));
        },
        
        fromAngle: function fromAngle(th) {
            return {
                x: Math.cos(th),
                y: Math.sin(th)
            };
        },
        
        inverse: function inverse(p) {
            return {
                x: -p.x,
                y: -p.y
            };
        }
    },
    
    ray: {
        intersectionPos: function intersection(ray, seg) {
            var q = opers.point.sub(ray.begin, seg.begin);
            var r = {
                x: Math.sin(ray.angle),
                y: Math.cos(ray.angle)
            };
            
            var t1 = Math.abs(opers.point.cross(seg.offset, q)) / opers.point.dot(seg.offset, r);
            var t2 = opers.point.dot(q, r) / opers.point.dot(seg.offset, r);
            
            if ( t1 >= 0 && 0 <= t2 && t2 <= 1 )
                return t1
                
            else
                return null;
        }
    },
    
    line: {
        normal: function normal(line) {
            var cn = Math.cos(90);
            var sn = Math.sin(90);
            
            return {
                x: line.dir.x * cn - line.dir.y * sn,
                y: line.dir.x * sn + line.dir.y * cn
            };
        },
        
        atPos: function linePos(line, n) {
            return opers.point.add(line.begin, opers.point.mul(opers.point.unit(line.dir), n));
        }
    },
    
    lineSeg: {
        slide: function slide(seg, vel, camPos) {
            var res = opers.point.mul(opers.point.unit(opers.point.sub(seg.offset, seg.begin)), opers.point.len(vel));
            
            if ( opers.point.dot(res, vel) < 0 )
                res = opers.point.inverse(res);
            
            // var n = opers.lineSeg.normalTo(seg, camPos);
            
            return res;
        },
        
        corner: function corner(seg, pos, radius) {
            let a = radius - opers.point.len(opers.point.sub(pos, seg.begin)) / radius;
            let b = radius - opers.point.len(opers.point.sub(pos, opers.point.add(seg.begin, seg.offset))) / radius;
            
            return Math.max(a, b, 0);
        },
        
        normalTo: function normalTo(seg, point) {
            var normal = opers.line.normal({ begin: seg.begin, dir: opers.point.unit(seg.offset) });
            var normDot = opers.point.dot(normal, opers.point.unit(opers.point.sub(opers.lineSeg.closest(seg, point), point)));
            
            if ( normDot < 0 )
                return opers.point.inverse(normal);
            
            return normal;
        },
        
        split: function split(line, seg) {
            var n = opers.line.normal(line);
            var sgend = opers.point.add(seg.begin, seg.offset);
            
            if ( opers.point.cross(seg.offset, line.dir) == 0 )
                return null;
            
            // p + tr = q + us
            // p + tr for the line segment
            // q + us for the infinite line
            var t = opers.point.cross(opers.point.sub(line.begin, seg.begin), line.dir) / opers.point.cross(seg.offset, line.dir);
            var u = opers.point.cross(opers.point.sub(line.begin, seg.begin), seg.offset) / opers.point.cross(seg.offset, line.dir);
            
            if ( 0 <= t && t <= 1 && u > 0 )
                return opers.point.add(seg.begin, opers.point.mul(seg.offset, t));
                
            else
                return null;
        },
        
        closest: function closest(seg, point) {
            var sq = opers.point.sqlen(seg.offset);
            var atp = opers.point.sub(point, seg.begin);
            var dt = opers.point.dot(atp, seg.offset);
            var t = (dt / sq).clamp(0, 1);
            
            return opers.point.add(seg.begin, opers.point.mul(seg.offset, t));
        },
        
        collides: function collides(seg, point, radius) {
            return opers.point.len(opers.point.sub(point, opers.lineSeg.closest(seg, point))) <= radius;
        },
        
        splitPos: function split(line, seg) {
            var n = opers.line.normal(line);
            var sgend = opers.point.add(seg.begin, seg.offset);
            
            var t1 = opers.point.dot(n, opers.point.sub(seg.begin, line.begin));
            var t2 = opers.point.dot(n, opers.point.sub(sgend, line.begin));
            
            if ( (t1 >= 0) == (t2 >= 0) || opers.point.cross(opers.point.unit(seg.offset), line.dir) == 0 )
                return null;
            
            // p + tr = q + us
            // p + tr for the line segment
            // q + us for the infinite line
            return opers.point.cross(opers.point.sub(line.begin, seg.begin), seg.offset) / opers.point.cross(seg.offset, line.dir);
        },
        
        lineFront: function lineFront(seg1, seg2) {
            var res = Math.sign(opers.lineSeg.pointFront(seg1, seg2.begin) + opers.lineSeg.pointFront(seg1, opers.point.add(seg2.begin, seg2.offset)));
            
            return res;
        },
        
        pointFront: function pointFront(seg, point) {
            var sgend = opers.point.add(seg.begin, seg.offset);
            var res = opers.point.cross(opers.point.sub(point, seg.begin), opers.point.sub(sgend, seg.begin));
            
            res = Math.sign(res);
            
            return res;
        }
    }
};

module.exports = opers;

},{}],2:[function(require,module,exports){
(function (Buffer){

var geom = require('./geometry.js');
var raycaster = require('./raycaster.js');

var spriteImages = {
    sphere: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FZQUFBRERQbUhMQUFBQUJtSkxSMFFBMHdEVEFOT25BN2J4QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUVGeHNyOFZtbWtRQUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBZ0FFbEVRVlI0MnUyOWZheW5WM0VtK0ZTZDkxNjN1OXZ1dGpGMk1FME00Y1BnekJBRkVsc2tBbnRKNHF5U0NCTEVUUGdZSEd6VzVBOGlFYVRWU2w1UDFtWkZOb0VKUVpGUUlrR3doU0VUa3VXZlNKbFprbWdSa0IxSERSanZoc1ZzSUI2WUVCdkdIMk8zN2NidC9wMnEyai9xcVhQZWEyT3djYmZkQm43VzllMTc3Ky96UFhXcW5ucnFxVG9TRWZoZXUvM1JILzNSaFp2TjVxSk43eThNOTJjNi9Nd0dQVVZiMjlWYTI5SmxrZFpFRmwyZ3F2a2dSMWhZdUdNRDcwY2N1RmRWYjFQUnIyclR2OS9lMnY3RUpiOTJ5U2UvMTY2VlBOa040QS8vOEE5Ly9QNzc3Ny9reUFNUHZDeDZmN1l1MjZlZWROS1dxQ29nQWxIRkFvVXFBRlVJQk5vVUNrQVhCYUFRRVNnVTBQeGRRejVXVmFGUTZLSVFBSnZlNDV2Zi9PWTk3bjV6YSsxVFcxdmIxNzNoRGYvbXhoOFl3T044KzNlLzkrK3V1UCtiOTcrNjkzN2U5dmIycmxvb05PUUNxK2FYS0tRQklwcUxIZ3BSQVZTeEtMajREYXJnL1lFUXdTSUs4RGxEWXp5WGFob0xBQ3k2QUF0dzc2RjdqMncybTV0VTlhTnZmT01iZitjSEJuQ2Nici83dTc5NzFYMzMzZmQ2ZDMvTzF0WldMZ04zcVloaUVZVTBoVFpBMFlBbVVGRkFrQjZnNWFMS2FtZWpDUVJjZkhxRUVJVWlQVWVEUWlVUXF0RFcwQlNBSzNRUmhBREtFS0lBUkFSSGpoeUorKzY3N3g4Qi9NbWxsMTc2OWg4WXdHTzh2ZnZkNzc3NHJyc09YWDNrL3NQbkwxdGJMUmNQRUN4UUJWcHI2ZWJSb0F1TkFZQTJSUk5GcUdJUkFFMndSQU5hR29BQUVGMXlRV1Y2REVEUkdvQ1ZGNUY4UXVoNFhIb1JrUXd0c25vT2dRRHBJSEQ0OEdFN2ZQandwN2UzdDY5K3d4dmU4TmMvTUlCSGNmdnQzLzd0Sys2KysrN2ZNTE96YTdmS3dwMnRndGJvdW9GY2pDWVFiZGppd29XbUFZaEtMbzQwNklMYzlTSm9FS2ptYzZua29pbzlBVlFoTFRHQkN2TDFwQ0g0ZDVFTUlhcjVmREs4RVBJNWhVYXp1cTUzM25ubnJRRGVleUtHaUJQS0FONyt2Nzc5WFhmZWNlZWJJMkpmZ2pKRmE4STRuUmU2NWJhRkx1bXFSN3pYTkFKQnhYeTY2T0FPMW9CcUl3Z1VLQnEwQ1FKQVU0V2thNEZvTHI2bzV1OUZBRWlHRnloVWZlQ0dBU0RMMkJSWVFoSEt2d2NRbU5mM3JydnVPbVJtNzd2MDBrdi9weDhZd09wMjlkVnZ2K3IyMjI5N201bnRhNnFBNU1YWGxzaTlDVjE4WkN3R2hCNUIwZWllTmQwQnRDMW9vSnZXY3VmTEFIb2lTbU5LUXdHNDJ4Y0EwaVltMEFaSUdnY0FORmtBamZRV0lva1RXdjV0L0U3ejJkRGF3QVhBd3hyQ2UwNEVuUENFR3NBNzN2R09WMy9qRzkvNGcvdVBIRGxidUl1YjVNVlh5UVZwaTBCbHlVVVRJRnJEVnN1ZExDMmdxTDlOZzFIazR3TkFXNVpjeEhMWkFOclNFc1NoMFlVbjZCTVJ0SHhoYUZOSVpFelBrTEEyb254TVBvZXVQRUxkdHpFa01CWGw1NDBBSUlHeWhUdnZ2UE5XRVhucnIvM2FyMzMwKzg0QWZ2TTNmL1A2dSs2NjZ5Vks5NnNpV0RSUmVHc0tsUVpweUpSc1dVYk1IYWhiVzdwcmJYVGg1YnFGc1YreE5FQ2swU2dxMVpQYzh3dDVnYWd3QWdBTlRmajdjVjlCVzdpelpSWHphU1JRcHA0MFdGRU1IaUg1QlRDOHlQanNnWjBZNGJiYmJ2dTdONzNwVFQvMWZXRUFWMTU1NVZWZis5clhybkQzazNMSHRVVHRqZkZiTTk3bjcvUEN0MFZIWE01VXJtRVphQnhvVFJFZzRsOFdMQUlFRWo5VVNqZlJQck1HVVlDUDEwUjdhQXFHbU5WT2x6U09RdjZBakhpdnNneFhYL2RQM05qU01ESUdZVkVnWktGWDJubTk2L3JmYzg4OUR4dzlldlIzSHUrdzhMZ2F3RnZlOHBZYjdyenp6aGZsRHNvRmJuVG5iV0U4MWtZUFFDSm5tV2hmdGFGSjV1OExRWnMydWx0WmNzY0tFckRWeFY4YTB6TlpnVDBobUVTK2hnQ1FCVTBqTXdPZHBKSHlkUnE5U3UzMjBBV0tHS0IwOEFzS1JEUWFqVUpERUJXaUpERUVZbVVHRDhJSHQ5OSsrK2N1dSt5eUYzOVBHY0JWVjEzMXVpOS8rY3Z2ZTJEendKNG1pdGE0V0lOZ1NYRFdKR04yVWJpTnUwMmFvdWt5TWdIbDdnUGpyRURTZGJjbFBZSXVnd0ZzQklkTmNnSEhUbTJUTTFCVXBoR0FMbWdTQStGRDBtZ1dYZjJPYWFZaTZFWDRuSnJoSlZQUW1LOFhDVWdMWnd4Y3NEWUV4SWdLZDk5OTkrR0llUE1sbDF6eTc1LzBCdkMydDczdG1wdHZ2dm5TMWhxZ0RWdExMaXgwaXpFYTBMWkFtL0RpU3lMcUJqVGRvdXNXWGxRbGpjc2RMcG5hWmY2ZTl5dGdOM0FCNC85Z0FibndUWFBSSVEwaU1YYXNyREtCR2UrRDhYNkJSR1M4UnlNcEJIb2VZaEFCc01qRUZxR0lKYUJTbjV2R3NzWUVxelhJZndZaUFuZmNjY2UxbDExMjJXVlBXZ080L1BMTEQzNzk2Ly8xL0dUdEJOSzJrbmlSaGkzbTdWcnNYRnV3QmJyMDJwVkx3d0pBbGlWVE1jWm5hUUtWTFRTdCtOdWdraGNaTFRNQUNVWGJBaVFXWUVsU3A2VXZ6eDBMb0JWeG96RzRmdXlJNmJuUXFrSERZV29vaVZYV0tlQmdLV05oVmhFRE5LS0lvbFdvZUlnUlBBZ1kxcnJjZHR0dG4zN1RtOTUwd1pQS0FONzV6bmN1LzgvblAvK1Z1Ly9iZnp0UUY3MXB4dTdXRW9CbC9rNk92alUwQ0JwUmUrR0FOSXlHSnZQQ3BTZFJOQTBJUVZnQlBwSEVFZ0o2aUZhSXZBQmx2cGNsRVJ3YWlhUEVFZ29FZ2FDc2RpcGpkbVBXVWNXbWdEQVVKZktYWWhTRFJhVUNuQ0tEZXlqakd0VkgxaUxLRUFJelJWd2J4QjEzM1BIUEo1OTg4ck5lODVyWDlHTzlWbnJNMmJ5M3YvMjhnd2NQM25IbjdiY2ZjRE40cHRWd0VjQUZZUUYxUVVRZ05DMWRlMGVFQTk3SXBRZkNBb0tBZU1BakwweEV3Q0lnRVlnUU9Ed3BXZ2xlV0FCOG5JY2pJaDhiWVRQV2VzRGhrQWk0K2JqSTdzamZSY0IwNVpZamNqZUhJd2pZSElHQThYM2s3ejN5T1FJR1EvMCtFR2FJY0xnSDNQbTd5UGNIeTg4aWZDMkJqR3l4aWwwUXdSbG5uSEhnNk5HamQzejR3eDgrNzRRMmdOLzZyZCs2OE9CbkR0NXc2TkNoZldHUkMrOE9NUWZjRWN5eEhRRkk1TytSNUk1QTRKcVhOaEFJQ2JnRERnY2NDUEVFVDJGNUVUMEFxNHRKNHlDZTlnQWNnSVFnU01PRU9SRENSZU5paWMrRmNrZEkvaTA2VmdzVmNBTXNKSmVlcXkyNWZqUTBHcEliRERJZjY0NEl5ZGVvNS9lQVdRQklZKzRBalBjdmQ3UUdpbVVJcDUxMjJyNkl1T0ZESC9yUWhTZWtBVng1NVpVWEgvejBwLy9tbS9kOWN4ZUFYTXpJeTk4bFA2QkVBTjNoNFJBSEFvSndCOExUNXhseTUzc0FTSU9SM0pvSUQwU3ZYUlVJOGZRUUVSQ0pzY0FlZ0V0NkFUT0h1Q0Vrb0JKd3BDZVFDTGc0QWdLREFKYWZ3Y0lSY0VEVzNvUFBINWJ2SVFJR3o0VVdod2h5Y1MyTkx6enk0L0N4SnVrQkFnR3g5RDZBNVhQRFZvYVNqNnR3SU1DRHZBR3dmLy8rWFNMeU54LzYwSWN1UHFFTTRNb3JyN3p3NE44ZC9NdHZIcjUvS3o5UUFKM3ZPZ0xOMDYwYm5iWklvSFAzUUxnRHhCQmlRSUF1TkxsY0Y2RnJGWVFHSWhRaEFRbEZ4Tnc5K2J1ODJHb1pNa1FBRXdFczROQmNHRXNYcnVGMEE1N2VCWFFiTG1PaHdTK3pRRWo5bUx0ZkdLYWNxVndnalRpTk40WUJDQjl2c0xuVFF4QmhnQUZpbGdibURndUgwenVzbG40VkhnVDc5dTNiRXBHL1BGYWU0REVid0wrOTh0K2VkL0Rnd1k5OTg4amhMWXpkNDRBQ0VZN3VnazdyMXZUaWFTQW9ONW4wdURsNE1SbVR3d0R2ZVVIRW9IVDF2TlJ3TXlJQXdBeHdvNkdJd0VIY1FBd0JrZm1hQW1SVTBUUkh2bWJlM3dFeExoS0dGOGpMUCtOMzBPMkxCSnhoS0hlL3cyVGlqN0VaUWhDOTdpUDh1ekFFQmN3RUx1bVp6UHU0TmhNMDdzRHQyTGR2M3hhQWp4MExUUENZRE9BZDczakg4dGtiUG52OW9VT0hkc0VCRjhETG5ackRXUHpRS0dBVzhPZ1FEeTVqUUhpeFZJUVhQWU40UU9FaVVFMXZZRjdnanp0UDhzN2xvb1dlQlN2WEhlWjVQMk9NRDRJNVJGb05Gemtka1NFY3lNQXlkM0NrdGNHNlFDSXhpd0d3OGhJU0E1TTRnREJMVElJWkJnQkxNc2hzaGhLemhBMWdlREVmbjZVVFU4d01iUmFVV0ozRy92MzdkN243OVIvNXlFZVdKOHdBUG4zdzRGZHV2KzMyZlFKQmgyUzhKbWlEeHZnNW9MbVRIQkEwT0hLM1pyeE9UK3h1RU10ZDZBVzB3bUV1ZExGenArV0N5M0RKaHNRRVlZbnU2c0s1Q0NRQTExVklvWkdaY0tIcFV5eFl3TGRoQXJuVEplQzgvRGF3akVIcTlWWTdQU0lYR3BnTG1uOFRXR1FJY0djT0VVQ0V3VmIzQzNvOEdWNWlmdVoxVlZINDMybW5uYmJ2L3Z2di84b1RZZ0QvK2wrLzV1QS9mZTFyQnlCcDBmQk1kY0l6UFhQTE41M3UxVEtHSWk5VXVUdmh6Z25wZ0F0Y0V3OVdUdXdocS95S3dOQ1pVWGdDT1lCeDF5UVhpcDRFM08wbzBEaHlCQnRwWU4wbklzR21NMFFNWEJHWWp3MkhsTHNQZ1Z0a1psQVdKV200RnNiSFRHQVhjSmFXWmJqM0JLbVpsU1FJelBodkxqQkxvM0ZIWmd3TVEyQjFzdUNCQ0hER0dXY2MrTUFIUG5Ed2NUV0F5OTUwMlRVMy9YLy83L251bm12VEFvSk9oS3U1MHlQZzNwRWhqVHRFS2liV0tpdlJ2OElrUnFxWXU4YnlNYng0Z1V6RmlpU3A5TkJyb1ppcnU4MjBEaENZSnk1UlNNYmR5dGdBaENWM1gveUxJRE9VeXYvVEpSdlRSODhGSHlGR0FMSFZUaVdBNUdJRjd4c29JMCszNzRnVnR1ajVuQlZHUkNEaXVXSEMwdE9zTW9WRW1TdWhDVFdJWjU1NTV2blhYSFBOTlkrTEFiejFyVzk5M1gvNnYvN1RwZkJBMDR5WmNNd0ZsWTZRUlB3SWdjSXJ5OHBVaU1ESjNlRk1oeUM1MEI3S3NMR1RGREhwQTVFWEVTTW1LL0tjQ3g2eWVxWGN5V0JlYnU0SXQ4a2xtS1hyZDV2aHhRQVlGNWtBTTBMNFhobXJoK2V3OUhJeDhZS0wwY2ZZRGh6aE5HaGphSXVvakVBeU5lVy9SNG9MaDdobnlJZ0ptczB3U2FPUkx1YjNNODQ0NDlMcnJydnVkY2ZkQUE0ZS9NejdvQW5VT2dtZTlBVHAzZ1o1TXhhTEpVOTZDL3FJMWE3aHY0M1dEM0IzSkluRTdRMm4yeHc3VEp5N0FzeXpRY2JQbVMzUUM4SGducWxqeHQ3Y3lWSVlRRmJJWGpMakNCTXVWS1Y1eVM5QVpHUUkrYmxxa1dMbDdnTVNBRmF4ZllTWkVJWkpNTDIwdko4bEJ2SWl1U3d5L1IzZXhXR1dIcUhYYzdvL0pFVVVrZmNkVndONDVTdGZlY09kZDk2MlI3bVFSV0Ftb0N0REFNUWxVVDkzdXE3Y0t0eGg0bm1SS2l3QVVCSTM2NFdXeXIwOXNLTld3bHgrb0hnYVRZaEFWdGxDZ3M1TTRUSnp6emV0Z1V6ZmZQMGNrbUROTTBmM2N0M0VLc0kwcjRpZ1d1endHSWpmSXhmVXpQTStLeERuNGJBd2NnQzVxRUp5b1RJRCtEUks0L3NySXdBNUR5RmVpQ29teWNRRCsvZnYzM1BOTmRmY2NGd000UExMTDcvcTg1Ly8vSXNNcEdVSnhMSVVrMHVZR2d5bVdUN2RiektCdVp1TG9zVndzNG04allzRXhta2dZT1R0QThXWHozaWF1SUMvandtbXlvTVVPZVNSb0hQUXRUSEk1bndPajFXNkZ0QUEwMG51WnZlSk04b0RPZG5Cb3BrSHd6Z1hFRDROSm5hOG4ybGNDUm9GSGdXV0U4TjRuMGJzbnJqRU1PbmpyQ3ZZTk9JVmFmVFVwejcxUmRkZWUrMVZ4OXdBRGg0OGVFWHZtY09iY1gyTExBSGczb0h1dzJyZE5Ra2MxWXhyc2VMWFlhUG80OXpwaUV6N0pQSURlKzA2dXRUaGFqMFlQMzNtM2tFd1d2ZlJ1YlB6T1lFd3pEb0RYOU5scG93UnlRMDRZKzE2MFFDSHU0Mkw3Y3pqblVXbU1JYTRZamVLYWw0dGZnYnpHQUExdzZGQnhKS3VacUVyU0IzYmlwREsxMHRleFZIWEV0eUVOTmdWTHRqZTNyN2ltQnJBSzE3eGl1dnZ2T3V1azFReGRtb3VVdEsyU09KdllFRVBBR3JEZlJmQUFaSU5oQ3M2MFQ1WUdjdGtLM0VrQmtaSWNvYjdLeGRBTWl0M0JFUmw3R3dwWGw1WWJjUWtqV1lzam9FNXpHSmtLN1ZBcG9vSWcySkZPb1V3dlBCem9JeEhJQ2F6bUJSTWJSM3B4VmF2YTJNbnI3d0JnYUxGTkdpNHd5d3pDTy96L211Z0s1WXNxWHZQN3hKWUZUVWhJamoxMUZOUCtzQUhQbkQ5TVRHQXQ3emxMYS8rekdjKzh4SUpSL2NzNHNBTkthUE5TbDhuQ0JSeTYxVnhDODlVQ2N5N3d4MHVuaVdZc1hzemZjb0NJVjBnNCtQQU9USGxVazRnTlJtL21mYURHWWs5aUF3eUl5RVZtWk1YNXZCWTc5Z0VkVW5heE1yRE9ZdFdkUHVyT29IcittZW5JVnU2QklZaWo4aEZZNmw2OEFzK2kxK1RTQ0wrQWFuaXRkR3crbW13c2FsY3lEeGFob1FDaHdMZ3pEUFBmTWtIUC9qQlZ6OW1BL2kvYjd6eER5b2RVa1o3cndJNjk3eHFSV29kSEx4bFZnMnJ3c2xNNEtmN1k2d1BDYVpmbU82WnlCa0ZmTVJRcXkzaENKT3NBR0xtMjVuU0NkMTJBYmdaSDR0NmxRSlg0ak1rbENVaFdVWmZZUTZ4MkZtMXEvS3hZV1FUdmlvY1ZYbTZoQVloRG8yQWtReEx4bkpxQ1hhbWkxV2l0dkU2NXA0TEw3RVRWN2l4bURXNUFoUFM1R25ZZi9DWURPQ05iM3pqVlYvKzBwZk9UdmRsM0R1T05lTmJwSWpBazlIakRoVm4zR1IrUDNodlJKSSt4bUpJeFVWSjNsNWkxaE1nNlZLOVhESlRyM1FhTmxQRlpJUXkxcnVSa01IY09TaksxZ2RRY3hHSTZ5QlhFcHM0VTFrZitLVFlUR0JpaFRYWGJ6R3pDYXQ0N0pncEhERktwL2NwRUd0Q1pqSjgxQk1Lb0NhRk1tbG1NTVVjQUpBWmwxbVdzMzJ0WDNBQVBUbVJwenpsS1dkL0owRDRiUTNnaGh0dWVGdm5SVTVDd2t0cE1XbmJvR3NEQlJJWVhDNGtHaGZEeUxERmNPOEk1TTVDeFQ5bUI4WE9yMVUveGVveTVYSjRZZ21wKzFJSE1OTE5GYmlUV0ZVSDU4NVV4dUhjUk90NFg5S3NGWEF0b1luN0FGOG9OVUVpeHZ4Y0JJVE80byt2S0dVaGtJdnc0ZmFOU3FGWWc4NTZ2WTdoU1lMRUUzcEh1UEM1WXBKVE1qRUdJamRZaGNIVzJ0dStLd040L2V0Zi82NS8rcWV2N1ZNRzRteWUxb3c1RG5oM3hxamN1VkhHNFpodlJ2cHdteVB0Q3pEOThheThSVlhnY25jWVJSVzU0WHlRTDdGaURPdmlabURGQUlHQWpucjdLRGVubjBqdlVFYmdSVmpGenRKcmVaT0lZWWdEU0ZvcWZTTjhaQXBHaGlFN1VGZFl3cE1OckRyRXVzd3RWUnV3dW4rTURHTmRidmJ3cktrTVdaa3dTMGpNbGFYa3lyeFdxaVp6b0dPa3hhZnQzNy92Mm11dmZkZWpOb0FiUDNmam0rRXhrYjE3TGpxRVc1OS84WlcrM1gyeXdvaE1CV05xN2FpWlNLQWlQcndDZkRyWmRKRjg0alVKaFBJQ1dTQVJaaUpCQTdYS3dkZmNPbEoybHN3YWR1d3d5SFMxbVFKeVI3SDY2STZkSmRrcTlJVFFMcE92QjFJeU5qV0lSZm1tNnkrUlIxUXFKeXZQNG9samtnUGkvYXd5aWd4cjVrbHdGU1lvdGpDcmhsV0NMd05pa0JWRDl3ekg1ZzRSZWZPak1vQkxMcm5raXYveVQvOWxYMGh3cDROQ0pxUHJZL1dQLzBYWmdVU0tPSWhFYWU1WnhDbmFsM0t2aXI5ZU1aQzFBU2ErUSszam80R0M5L1ZTK3ZBaVNub1VpZHJCTVFvK0dRSUlBTjEzOU8xSC9jMHFXM0NJVjRLSkFleXFvQTFpamtvN3JVUWpGbE5BNGdFeEhaWEcwdmlMVkhaUVhIOVJSemFGSVZiMUVFc0YwUkRMekhoZll0a2dnWlcwOGlvTDhVQkVuK2tuMmNqOTZRV3VlTVFHOFBuUGYvNDNuQW82NTV2SzlDSUxJell5Z2RxWm5TbGdTcThFR1NJUVNLeEFEQkJDc2lTU1Q2QURIU1ZWS1FQaDRxWkl3eWord0NDR2l1Y0hBVmpWNzMxY2JCODBMVmlqanlKd2ltTndUOWVxU3M5Um1zQ1kyVW1zR0Vqb1dGQW5FMWxBT0ZaTW9ZdXR5c2xVTEhtV2ZrTmtFRVFDN3ZnVkp0aFowNGhWSm1BRGZBOStwRjZIaGxPdmFUMUJJU2g2S1NheHUvL0dJektBWC8vMVg3LzRDMS80d3Rsd1FNM25QZHlIVW0wVVlVWnZXMlBzVnU2WGZGemw5RkZsWEdPdVRYZnVBOWdGMHpmV0VNcnRPNHNjQnFMZjJpV1VXV1BGeklXbkZzRW5pQnQ0bEVvYnJCWS93NUJRVHpiSjFPQUNUOTZobE1FK1hleEFwWmgxLzBycExOTmVHem04MFJzYXpLZ1Y4Rng4bWR6a01DSm5XTm5CbnJxUS9wM01vRWVDd1I1R2JzU0p0OG9BNmJrb1dEM3R0TlBPL3VBSHI3djRPeHJBbDc3MDVhdVRURW5PVDJtbFhzVVFCbjQzaDlEQ0lwTFk2ZWhqY1lOMStLd0ZHM2VMSVl5R1JRRkZwV2lHb2p0amhvYUIybVBkUDBPbE1COHFqcDNMVjNGY1pnYUFLU0d2K08raXBLM1hhaU9DTnA4TGdraFBOUVVlTWRoT0d3b2dHWVlsSy8xR3NQS1lJcEVLU1ZQRDRGWFZjK3hnS3l1amNVckZwckd6ZkUzczQyNVFZak4zR2FBM3N4c0hqQ3FrNkFoM1BQREFrYXUvb3dGODduTTNuTytqdHU1RFFwVVlJRWErVEJVM0lDbHZzdkwzSmNZWk9vQ1loWU1xNHhhVnkvSnhwVll1VTBJRks3a1hLSi95d1lFN1JaN3BoaXZuOTVVU3dFZmVQK3NWczVTYnFwTVNyODZkVm5aVWJkeFJ6S0JMZXFNVlJWMEdhVzRzNVpheHJlb0dnU0VOYzZrMGVsVm1waXd1S3BZN2kwTm1vM3p0bExzbDBNc1VlS0IrS2V4bGtPZ3NuMU5aSFpaMHdLcjh2R3Q3MS9uZjFnQmU4NXJYWEhYUFBmZTBOU0ZpVEVmZ0RnM0FlaTcwU08rcXVjTWNqcDRjdFRCZUpTdEJ0WFZ3MGNqOFdzWkdESmZQMGlpTEw0TmRZOGFBVmRQSGJLdjJJZDR3MXV4VHdNUEZMdU9RbFlFVW1WSmlDbDl4N1Z3TW8yQVRMQ0lMc2NVSWZTNElNejVEREdCWjJBRWlxMFZLalo4VUZ2R2lwRzJFS3BkSy9RTGlCTnFHVkJLdmpNWFFFU1owK1dsNDVwa0tUQXpBeDVrUElYNEpVazQ2K2VUMmdULys0NnNlMWdDKzlBLy84UHJhd3AzZU95MWFaeFVybUd2S0tzLzJuczJQWG14UVdyK2F3b1pHa0lzWUdUb0dSZXNGdkZhN1JtTDB4c1VLMVljN0w3aVBkaXRVYzBpVzVPQmEydnoxODB4UE1NSkFsRG9RTTMzMDJhWTFhd2R6cHhZNFRTQkkwQmd6dFUzbEVURUo2V3hoZlNBc1E0RkhFVUtsSzdSaGtHVUVneld0cGhPbk5NeXdvb2t4OUlaVkJ5aXVwSXRURUR2TDNXWUp3bzdhNXZVUGF3QTNmZkdMenhtUjF2b2dkV0NwOXpNNGh5dk5uZStZcWw2anhLL29TaE1XajJ3Q1NZZFFPTHJhaWVVVlFram5ybmFzczlvMUtvMXBnTUlSYmlNTmdwSTY1azZLVmJhQUdIekVrRmFUZmhvY0JOUFI0WWxXNzJIa1E3SENKSVBmd0lyeU5lNTRIeXhwdUZEM1p4UFV5Y3JySUZGK2VCV0xrczUyWDNFVG96aTF3aUxFVFc0eCtKQW9kWmIxalA5RHJlV1U2UmwyYmU5NnpyYzBnRi85MVYrOTRvRUhIcEFkZjdCMWpSZEFaME1HRno5MWRuMDBWOGFHc3FvUmt6T0VEQjU5eUxkRzhHUHFhRXpzcy9DQm1NOGhzaE9Fb1RJR254eEVlQmxkVmdzTHBPMFFjS3BQVHFIQW4wK09vSEo4SjdXOGsrdVg3QVphbFdXOVZFRXhHVU9qNjdmcS9CbmN2cWZDWjZSNXZIODFNUkpYdVBoNFBaVFUzV05ILzJKdXBxb3labk5LWmtuQ2pNWFM2Q3JOcmJWZ3FOamUzcGIzdi8vOVZ6ekVBTDc2MWEvc0tCM210YkhSMzFheUx4T2ZZSVNwWHhWUEZKUG9LSUFybGZlVEpTeUFpTkxjTTBnYnU0cXdtcHpCZnN2SklxNkFVM0l6c3NvU0txd1VOcGhTS3NBSEVDcDNMMVhqRjJLQmxjZ0NGR1dXWGtES1RhOFZSVkd5OUNKa2ZFckh3aEdocXpvL2hpeStzSUdUdmk1QVBOeTBaMkF5Vy9jTU1KTWdHNW5wWktmZTBaa0tjcWZiTEpqRmltYTJvZUFDamg0OSt1cUhHTUIvL3M5ZjJkRm1OTnEyVU5XNWJKdFNVNVNBS3drS0d5cFk0d0pXS2RkSGFkU0hNRFQvb0JsL2k0V2pvdGJYVmJSS1BTUEhzUlUzVUVndlZuUmZ4blJCdFcxRzZmOHdha01KdEVwc0lxd2VGdnBlZFNRWGdLdzAwc0xoS213dXFjOGpFSmNFWkw2cSt2SDVoRTBmYThVd3pGZWJJOTIrc1Rjd3pBZWg1V3loSDZDMEpPSCtZTDRBN0ZyR1RFTlhZaE80b2JNTzBSazJ1M1ZFR0piV3p0dGhBSmYvRDVmLytCMTMzTEhyd1NrQ2pZbkNUNS94UFJFVTB3MUFRMHZ4UkJlZW1BQ2ovZG9KMGpKTnNpRHRXa1drSWJQMVlSRERoUlJ3eEZvZ0dhTVU3V3REQ0VCREtKeU1rWm9WYXhkZThuRWFoTEJLdHlyRGVwV21Zaldwd1FOS3BlN2tEUGlaMXVvaHZzZmFyYk8vZElMTklhQmxBY3pIUzh6YWlLbU4xdk9Td1kxU3IwLytKQUVnYXhTbEkvQkFOK0lETDljZm8zblZMSER5N3QyN3JyMzIyaDhmQnZDTi8vcU5TNzVscFNBTW5vRWZnVURmS0J3OVV4SlA5Nk1EQzFoV3BqQVhFdUVKN3JTU2d5eDlTdlhWTXdOd1Q5ZFpjWHd1SGtaS1pKWFB5VW9kckQ2YU9rcHVQWXluWkNDZW5ta3FlSVVHSmF4RHlNNDVQY0dXOGRIQmc4bDVFS3lOT0E1Tm5nRFlLZWdZY1g3bTZ6V2tRcmxJZUFqeGhGRWlockdQY0NVc3RTaVdqL2huUnhrWjFDY0dYUHFnNG5XbGpxclVzemJhQXc4OGNNazBnRzk4NDJYZnJtS2NLakNIYWs5QVpUSGtXdDA3Qk1ZTFIvN1ppZ1BYNUFjMlBubDRGbDZ5ZzV2eXJ0V0hLVUtvd0phTnJoOWh0ekZKSFM4dVhhYVlvOUkyeUE0UG9DYkZRKzNvL0EwYXI2KzAreVdwbXU2VzRhTHkvd0hNaE9MV1dCRk1KU0RaMlRBUzlIaE80QmREdUZMekExYXQ1MUhFRW1ZdElIem9JUUFiMDBhOGhtd1lpMmM5Vy9MTWZKQkIyZGpTaVJHQUhnYnJnYzFtODdKaEFGLy8rdGVmL1hETGIrWnNhU0lXOEtyOUVYVDRUQU1uK0tpZnM1aERlRGpaT1FJeXR6aysxWkJqWG9KQ2tmSUtza0xRQ0Q1VFZKNDdXVDhaYnJ5a1lhdjZQME9SK0dUN1JvZmFTQm1GN2pYckEvWFVUcy9sRktUT1hIemRYMWlwMk94RXJ2QVdGc09kRjZnSzFyV2p5c1RjM2NYeEQwOHdLbjVHYjB4bUVTdDFNWHN2MTRXdTBrc2FrZ2F1N2lMdnFjZGtLSDMyTUlEYmJydnQxSWYzQURHa1lJWklBU2o3NmNZTHhTU01ITTQzdVRPVUNQTlJzT3FHcVFEZ20wK2tLbzdWRHJJQkxHZVh6aFFIRlB0WFdRSWx1V01HMzJ6K2RFZ29oWi9KUUVyUnhWV3BKbElYbVhuNkdCeUJ3WXdQRHFCSUc3UFpUMWhBVWp3M3kreGhETkltVTd6cEprTk9OdVZvTm9EeWRQc2xuQkdXaVZjc28yVkdVR1ZnSjlLUGVpNnJ6SUNkeDJIb25uaHVlM3Y3VkFCb1gvbktWeTY4OGNZYkwvMzJvOFE0Z3IzT3o0a2NnNmFhRTdJV2JXaHNuVXB0ZWcxS0ZHZzA2Skp1V1RpSXVZa2dvRWtvY1ZTclJIQ2VYNDZIRlEyZUNUQm45ZVhFTG5BcVYyT2JPRWFIaklqbTVCQTJVTlpjWU9IUkw5VTdXR1BkcEpJZ3JkazgxYjlJcTJEbm5ReVJVZFV6TVA4dW1EOExyYVNlcHl4SDJQdmdzNW1FblNTai8xRmpkbHJWZFJ6SzV2cGZVZUxEczdHQ3l1eGxQV1lPTHFpTzkvVndpZnFGcXNxTk45NzRpZVh1dSsrKzZEc3BSNnYxcW5teWcvbkVDOXdkVFRRWlB6UmdjWTV0eTRsZkVnN2JNb2psRU9id0FGcFNvZEtZbTRzbVpiclFjRnpnWWhCWGhGcnlET3JaWUJJMGdrb0ZYZURheU5mTGFDdXJ0YkxJMlVBUkJ2VWxKNEh5aXJzREtwNlRQaDFaYjRoa0U5MDVoN2dXcFR3Q0dxdUR3bDdpcERCYjBkZDBJem56bVBJdzVEaWJuSkpRQzEyREpkamdtV1BIUjMyam5pTlpTODBoR1VYdGptRlN6czdtSEVXYjRhWHhkVGpWSk1ld3dRRzBJWjFqTDRNS2JHTVg2YUZEaDE3NGlGcEl6RWNNeW15YmVYdTFLVEczamxYSHJHVVpmQkJGVlVsenFucWpaRjJUZWNwQUl6N0hxY2djK3VBbGp1QUVzV0I0aVJWSll6S1ZPQU9YVlFsN2hBVEdjNzV1NFlFNXhHTE9Bc0NNSkV6N1ZncmlGZEUxcXA0clFjb1EwNFp6L29ERFdKcU5VdEZHUHUrNkI5Qjlzb2doaVlHTUhWSFZqRHRCWWJYUVpYZVdsRmFpdElTbENlZ1p2cTJURkxMQVpyTjVvZDU3NzczUGZDVHJINnRTY0JWOGFzb1ZvbFEvR0ZYQUhsV1BwdmdwcWptREZLakZiSTJ1bW4yUkowV3cxTVNQUVVyRVNQbEFBY2hRQ0NGbUQ4R1FhZ2RielNhbkhrTzBLRk1xWHVRUXhTc2VhNkdHRDFLbWxORlZUSEtrV2lsZ0E4Y1VQdkVkRFNOVnRjUG9kVEQzZ2Nnc045QUFBQ0FBU1VSQlZEV3NHTTZLMlM2c2YzRDZHUmN4ZXlobmhkREMwV3R5MnRBS2N2NWd6eUZVYml4VlN3M0g2R05Pb1hkLzVuTFB2ZmVjK1VqN3lOeFh4NlZZZ2hNWmc0d1VLdWxhUEJScWdHMEJpeWVMSnU1d1U3Z0V0dFFSYUdnR1lDc1hTeU9sNXNvWVE5RVV4RFJoYU5QRUlnWENOSVdaSVBDVWFEQUZsb1cwcmxENnpabDdCUUd5U21kUXRKd3dLcm5neXRpYkNwNjIwZ2RVeGJLTlZ0QmhSQ29EOEZZc3I1NUdxWFp5U3R3Z1NlZktDRmdZQTZqQXVRbVZCUTN1MkdRTXJoQUl2T1YzaWRXQWlOS2xpUXhqRmg1OVU1bVBWSFd3NWpCSmhpTUxPN09kZE5KSlY5MTMzMzI3SHVGa1dZZ2t5QnJEbURsak55S0hJV3ZqeUhZRkQyZmlqRjdPMm0vVm9pMk5DRHpCR3NOVnh2aTh0dU1BSmdHbmJkZUlGR3J5Wkp6SXdVWFdVblF3cEJiWWs3U1lKblA2cG9xc0d0em5Dc3BLV1RUR3pZaGcwbEp6TWdjOGVPakVxb1ZOYXBnVTVXMkZBMlVVUW1ZbXdSbEdPNUVhamNFeEFhUE1KdGtxRkUyV2hqT01pcGpKd1lXam5EeG1xaVR0bWVwR2Vyak5aaE50V1phcmp4dzU4b2duVGFubUlqb1hWN1JCeEJQWkMvZzlULzRvSkEvbFFRb2hrSllMQzVWNXJvNkE4L1FUVU5YNUsxcmdhRFZuVjFlWlJoM01sRmxFTFd4ZUZxbE1vQjYzTW82aElvT01Nd2FxdmJ2V2RxRHc5VGdXTG9sekQxZXY0SmprS0ErV3hzOUpmMEY5QVdTMXNGVnJ3ZXhZbXZhaG1CVXF6amdRSFNYcXFya0l3NUtTYTZuNlNYcXVhV3hPZ3FabUtJUUNmZE9saWNqYmUrL3lpQ2NLUkl6UjdPSUxkMmFtZEhWcVYzQWhoRk9VVzQxQWJWeElsUjJ6Ym5KMzBFdHdPTE5JRm1PYVZNcUg4Wmp4QVZjR2xQT2ZwM3A0elBDbngwSk00Nm5qWldZcGpDa2h1NHRyMldTVkJoWDZ6bSs2Z3o0T2lUSDRZVkRWWXdCMG1Vc3Q3a3pYcHA2eFpPamdkWnVOSkRuSWREYTdWR3FaYmx4Z0lrTmNPakpWOVRrMmg0WlU3ZkRqWElJQXpFeVh6V2J6eUJkL1ZiZ1FhNURXSVpieitzTUZhSmw2dFVHTnpzbWNhUXVKSVVDK2V3NkdCbnpKOGxZZTVaSVBWMlNkdTZFalpPRjhRY3NqWWdWQXRQazZrZmRWbll5Z2wvQkxGRkJPSXFuU010TSswYkg5V1hlZ1I5Q1lsQ0VpUGRxUXJQdkVHVkl5UEV0ajlQSU10Y1VWQW9PNWpuRzFZem80RzFQWWRBN1JRTGM2ZnloOXc3S2FCQkxWSnltVzZYSkpyYlhSNVdjSWFqM2RQYlJSdjBodlVBYXV4ZTJJdElpNCt0SE9sY2tITytmdTU5dlBvMXQ0Z3NhY1daUFR1VVk0cURLdERzOGVxZ2dGeDcvbnYvTzRseGpmZzBlOUNHTm1McG9tM2dBRy8xN2oyVGxDZkV6WnJQTURoQmRXZUViUVZMOVU3U0hmSzFZVFFpcmpaalBpSE00Z3dSbEVPLzJGeTZwVENxdlJOcHlyTkkrU0N6Yk8xQnpBS2lYRUdDZFhRTEdZU3RHWXdsU0dKSTlhVkIyVDBWd3N3MmM0UkRIVFhaMDRoTFN4TkFDUDJnQ0dJZkRxamd1ZlJ5SU1OeHNQbXBFUDFHRUxHUnFDNS9xMEFuRmpNbGppZ2ZTVVBKQWhBcEVBSWMvNXFVc2syUEVhd3ZDQjhUT0pxd290TzRZcVRSWndHQTJSdEU4RVJXL0IxMXRWQ0lYeGRoQ0hTQUhvY0NnN2h2L1RZOVFRcXlxSnJCZy8xcW1IeUVXS0IyR3pTalhXaktaaTRkQnNuMjUralQxU2lUekZMeE5Zemg2Sjc5b0FCQldqbVo3eDJKYkdWWmFRZVZSYmkzRjYxencwS1dua1NyOThSZjhXUUZkT0FWR05zZXVGTHFpT2VTdXdKNlhuMWdRNnVtWS91ZHNybTVqNGd3ZEFFSkVQeVhHQnY2SDJqVlV0WURLcXZrT1F3bEp5MGRPWUVyUUt6ckZxcnFtcDVSSVlhZUdZQnhua0RWY2piQVo0WE5IU1EyMmtxd1lidHVvUDJUeG1RK3k2RmI1UWFCT1I3OW9EdExxc2RXZ3paajFBSkUvNnJNbmVkZmh5Y0F5TThnaVZRQjczQW8zaGxHdFJjOXdMeFo2cnNES1BjdkhCKzQvZGo5WDByUHEzQWkxa0h2UmNpeTlqRERTbUNQekJhZGtxOWN1Z3pSUVJZMXpNWUI1OU9wUGhOV2hNamxYUklPYjBVTWZPdG5WTTFlTU9ucUFVeWtORE9OSlFHcTRVOFRWQlkxU2FFZXZyNGJQcnlRTnRXWmFyM0YyK0d3UElPa2U1ZTU2K3ZiN3dMYy96aVVybmlNcWxlQUhKUlJRb3o5amoyWjRTRTErTThDRTVrVFJXMDdObGtpTEZDd2dUcUpxZnBsaTdhQms4ZmpXTnpqSXlGME93czVWODFUbyt5dHBWbTRGbk04eEtUU3dTc3l3KzkzWnlBNlBLaU1FUjVJa2tXRFduMVBSaTRwOHhwejVWVEJwVGIrQ0QyUEhWeE5PWXhTdVNZUmx5TEJWTk1sdm0zRDNhOXZiMi8vS28wc0NIeGdLZXBiYzY2YUpTTUw3Wk9tcDFoSTV5dlpLcUd0UTVQUUZFOHdRd08xSzJpcysxK09tMjZ3eWZvcjhHMWhxRFN4T1J5enF2cnJmdEdCaGxCL3UyeXIzWGg3cFpTY3hsUmVRTUE1R2hBWENzNXZwV2YxNzFRYm5zMEREcW1BUXlsVDBpTWp4SkZiZksyNkRtTDJvTm84d1BJcEhVTVhnSVJoRStxSE1XK0w2VDdhN1VKZEI3ajdabno1Ny8rWUVISG5oTUk4Y2pDNjZabm1raDh6Wk81VlR1M0VMZ0E1bXJBaTFEaEFSbkRyTUZ5M1VldXhyVTRvbE9nc2V4a3dDcU1CREF1Qi9xZ3NxWTRiRERyOGVRaE1VRWxCd0toWlhDQ05WbEpPdURKRGdVYTBmWmxvS1dBbTJZOXcyWml1SEp6eFZKSXdQRVZYT01zUG0vS2lWcHNERjIrSmltS3BHVlU0YWNBb2tLbmZNWFZtUVVaTDQzTXp2YTl1L2YvejhlUG54NDEyTXhBT0ZaUUxyS0FqSVAxYW0yR2VlZkNFL1FiUE9jZ0RxMlBSZ0N0TksyR0dsZTAzWE5QVEZGdVVtTU0zWmkwS3N5eHF2SG9Jb3JkazkydEFRWmsrUnlUQUZBck9UcGc1eUpTZlRFbWlUQ1NsMFVuRTBhazFLdWFXTlNJM2FHMFFRUG81RFJjVlNIWWhRSElZTTlsQ3oycUF6RmR0cVRZZGFUWmZSZlBGaFRFQzZrZ2F1KzVJZVgzYnQzM3d0ZzMyUHlBT3lMSHVweEVSWmJOckJseVJxQVR5R0ZlU09QSURBVE5LUytUalM1bmVZS1ZZTkZ5MklHREQwYWxxVUdPQWtMT2NsMDFlK2tjUjV2Y2VPcUxLcndPSmR4WUpVQjZoQmJFSTNjZU0wUGp0UTJhTTBLNE9IUXdmZGZES3V1cW9KcjJqaVBpcTI1bnNKeE50bFg2ZUlqbTFBK1JpSVBTNnV4dVkxWVVVd0h2QkNUK2tkKzNrNzE5T2lNVXFqa3hBWGxkSE8wbEppTDFneUYzS1I1cm9PVko3MjNIVGh3NE4vY2R0dHRUOE5qdktYckkzSW5nU050S2NqRndzN3F2Tjd3Z1JYU3l2TUE2RUdyRDFSUHRtNGRXMWx1MDBqaVNOYlp3M3B5cXN3cElUb0tLckZTeHNTWVVWaXk2Vm45cTFHeG5HT1VCd1hOa3REb1ZLMVB5S1BvNkQzRzdoeEV6MnFnWkdrV09Hc1FScExINi9sM3prV1MxWFEwZFptak5ZSmdPZXBRaTVtV0RnSHJhbEpLK0p4eGpBQmFhLys0N04yNzk2c0FYb1JqY0ROek5EUVlIRzFwSEtlNjhNTVZTNlhRTUJpb0ZSY0RaQUY2WUZrTXdES2JJVVRITElMVzJtZ1ZDZ0JiU0NYU0VpMTNtSUxqYVlNcEtUOThBK2NDQ2oyQTh2TGxBWS9wZVlwaFRKV3RpN0FzemRFeEFLSnpONVZwREpKSlVFZkMrSEFQUGQ4TDVXWENnZHFsNUhHU1JVMVNSeWtJU0MvakU1ak9rZm53NGhZeVliVVZXRFFOTlBOa1NsZHFhbFdaelNzbHRwVjAvNkxUY0pmbHBLOHVwNTU2NnQ4RGVCV095UzNWUWNJQm9abmVwWkxXbW9HenBPR2k2WUpoOUg4R1dmS2lkTThTYzgyVkwzNTlJR2xwWEtTTWpkYm4vZHc4dFlnSWROVnhTQlVrZ1dTVEdEMEJ5VWVra1NsYnlsTlowRGptWXg0ald3V3VDbStqeHpBRWpRTWNFUzFsNG56ZFVlcUxPYUVrWE1rYjVLSVlmKy9FTC9BYWZ5dXJpZWtGYnNkTWRlb3pNU2FRZVhnZVdWOE00Q1pyTGk0N2V5ZENPWnBQRlJhT3JXWHI3NWRUVHpuMUV6aUd0eDBITGtWMnVNQUVDNnRhaldkcktuZHdJWGp2aG82TVpaa0YxS0lhbWpZWUFzcXhMcUdLYm9MbWx1Y0lnMktMcFRFRU9KcmxQQjZKZ0xZRWY3MUt4NVloYURTYWtNOHdGb3RFTkdYcVdteGRIbG5ua1VKWWtIRENxbmdUYWZHVWZ2RkVWRlY2Sjg0WDR0d0VsV3ovRW8yU2VsQmN5cUZWSW96Zm1KMVJFWWpHelNDVXJ5dkc0QXNUWDRsekdIODBlUW9selcwOTZmVHczSXk3VHQ3MUNZa0liRzF0K1dQaUFoNmNGYlE4N2J2cGd0Ynl6TjNXR3BvMnRLVkJKUCt0aTJCcExUVUd1dVQ1dkEwOE96aFA5bDVhcW9JWHJUT0RCU3JMdUoveXVaVnNaRnNXaWxFMHk5T3JFOFNsdFJXYldOekUvRGt6RkozOGhwU0tPTEdJSTdqVGlwQ2k0b2lwclJpcmhvcEJQY2RxVVlUS0hhK1VkaHhnZ0IzcGJEYk84cjJYb1dyVitXTXltY1JkM2lZWGxWZ3FYNitORXZOYWFRejJWa1Q4M3UvL3ZpNEFjTnBwcDkxeisrMjM3enRtWHFBT1d0UVVKb3EwY1Z3S3d0QWsyNjhVQ2pkS3NHQXdGU3cyV0hTMEpubFFwRHRjbFUwTkRCbStPaW1CNllkS3k1TTFtTk9MQnpRbzc1SUdSVTRGRTJvVGdpVmE4SWpaVVRQblFkWEJneTNkQk5FczBVTU9DRWJRbTFYZld4UkJoWnhqUEhMMFF2dEN0RjZkVGlVY0NhV3FoM0l2WXptYzNjYlFXVndxRHNvY0k0dENPTlExTVk0RUFoMUNXWjZ3cEcyZVJtTVJlZTFGSVUzdUFZQ0Zod3pjZlB2dHQ3L29XSVlDZ3pGOXlVVmVhcUNEdGZ4d0xVT0N0RWFCcEdEcERtdkthZUlabzkwRDNoYkFITTBCYnlrZmE1RUxtQzdjRTFSS3RvaXJDSU1NZ09aUTBaekVrWUVuczVHZUx0WlJSOE1uTzZic044aDBtem04QU5Kem5MelVZUlU4ams1R2s2bU9FWElzWXpIbkZzNDFyTzRseXRpWXAzdDBUaFlUWmpROGxCb0o0c1pRekNxWGk2QnhWSC9paHdZMW0wUzNDdENwbkI2SFlXbGVZK29hbWdpMlR6cnA1bWtBWjU3NUtkeDAwekUxZ0ZTY2RHQnBVRFQycStVd0NWbm91b3lHSWtnUjZaS3MyR0pJZkdBR2w0YWxkOWl5SktpMDlDRGhnR2xIV0I0cHIrNHdzcEJpRFNFOTZ4T2h6SU1wbWdwSzJaanVDZHBBK3BWMTVIYnVQTGd5UFpDeWRPVXJIV0dIb3ZINGxod2NLNk9vRmV4L3JDeWdxbkhwd0tqbUdkb0c1cThXQTZnNWdGaVdNWmpUZStLRVZzYkV1b1N3WDdORzdLVURVemFDWm0rQUVKektPTjdPY2ZMSit6ODFET0RNcHo3MU9nQy9pV044QytRWVBrWFN2T1lPYlFZekJXQm9EVEJwYUQxNzhGV3o1ZHBDNlA0TjBRVmRHcmFrbyt0V3JwRjFSQk9JYjBHVlE1MWFBa0R0NU1vclpZdEE4MnhhOGREUnlxMVFvQWtuZUNxbFdJWXVRc21pNUJ5RGN2bFVBVWtySWllcmZ6MWs1WTdaTUlzT0ZkM0JJSXJTL1h1SFFORlhwNlg2Nm9oYldBMm1VcUQzeEh4REQ5ZlJzVUE5NXlrSVZVclZtNUJabDR5bW1SVE1aT29vQnNRU21SUkVZTytlUGRleEdKYnZldi8rL2ZjZk9uUm9GNDdEVFJaQnc0TFdjcmNtU0NRb2JBa01Fd2dLb050b0M2QllvQTFZWk1uN2EvNHMydEEwbGNnUWdrdkpITDhKUWFRb3NBZ2FXcEpPTEJhMUFRSUJhRU1yZlNJU2tPbEM5WkxFVkJDVXRuRUZzb3FzU21FclI4aFE1NmpPTnJSQmcyUEtzYWx2RU9pbzBPcGdubVVIWXg1OGJ4S1RLRU5naWxHSEpqSVEwdWpkVnRvSWxNWkZCenRHd1JZZzdjaDcvL0M5Snc4UEFBQlBQL3ZzbXc0ZE92U2k0MkVBWXc0dVAzVHpsdWxJNDBsYkRnZ1dXQUFOSGI1UnlGYlA5alBwME5pQ2VVLzZ0eWFGVSt0dk1LQzFIR2dwaG9VcEpBakVvbEVPRWl3NnRlcjlNM29USFJlMEdTK2R6bjZDNEx5ZlVpUUhpYU5rbEpPdURmRThwbWJVRjBCbDBVcHFYdWNpb1ExZDRKcE1US0NubzJvSG5UZ2dzd0FqMlNVa3Q1Z20xK0ZjSlJjamJTd3RzNVdPZkcrb2Flb09uSExLbnB0cWJhWUJQUDNwSDczcGkxODhMZ2FRakpvTm1iTHFuT2tIYld3SU16UlZkTXZtanVnT2EwWmF0RU1YOHZxZUpFMzBEVnlXeEFNOStTUVZRWGRCSzQ2OTFMRklyeU9SOGJJMVpXOWVnOENHTjNHZTNBa09mUkRvTEdOTFZkZlNUU3NvMXpLbVYySWpMZ2RKN2FvdmxKSkFJT2ptZzE4SXpMNEFZY2dURjNnTE5BNStHc3JwRUhSaldiYzNhaWJyRER4S3hLalFCZ0JzRExJQTZBSG41MVBKc1QxN1RqbmxvMVBmdVZLaUhHcys0RnRwQ0xPaFpFSGJRcnJvdG1CcENpeUtCUXB0TTdjWEtOclMwSnBBcFRGRXBGdlhCV2l5QmJSRXRhcnNBMTRXU3RFRm9vMWxaM1lsdDRXOURia3ZHMlZzcVUxUWRpYW4ycWhKTVl5S1VocEVVNmpIN0x6QjdEZ2FuSUd5N3QreUpiMk1wMVErSlQ4dkQ2QVVhUWdiWllWSVhldHNJeUwva3NLQkZVWFJWUWlJUnRLSVFMREV0REVJemRHdFpCRng3YlhYNmtNOEFBQ2NjODQ1LzNqenpUYy85M2daUUIzaDJzS3lPN1hsTUFZVG9CblFCZGdXd0tVQjVybW9ZYkRlRUlzaHZFR2pRNXJDKzVMZHlKd3dsMlhFSEZvSlpET0tVbnVvTFJjenJLT3BzR1lBbmxaTzZRZjVBSlVFb3p6SVBPdU92SHBoYk1SZ1Q3Z3Fhd3lzQTBoTjg1SUc2WkZ1T3pSbkJESjlWTFhSM1pQRVg2TW1Bck04SGgxZEt1dklUbWtldDhxeWNSMWlsWjVVZlFQRU1zNUFrdFdnVFpFMmp0c0pFWng2eXQ1L2ZOaEJrZWVjYzg2ZjREamZ4cWd6Snpid0hITFFlZmFaR2NhNWZRN096a2ZQNzVaSHZQUTZkTEgzUEQwamNvanl4b05ERkRySDNCb01IZDA2WiswYWVzK2hEdUdHamp6bDB6bDRHWkdqVk13N091Y2h1bk1zamVkUXhqNk93YzMzM0t2cjFqamF4Y0VobXB3TzR2a2V2ZGZuOW5IMFREWFNCcWVnZ00rVDQyOXNIQ0JoYnRoWUg3Ti9UZkkrMWp2Z2pnNWdZMWswNjU0Tm9kVUZiWnZPcWUwQjJBYjc5NS8ySnpzbC9yRlRLblB5eVNmM0kwZU90T050Q0trV1pqZ1FvRzF0b1lrUXlXZWN6bDREeFpJOWFHaExTc0pieThFUldKSnlscWI1SFEyeXBCcEdtU2xJMGJ1QzFlOElESnVPTHFHU283Y2hKWk5SWDI1b1UxMWM3SjZtcEt0MEdNb09KTW4rT0RRWnNTSHJJZ28wenk0bmNJZU9waFNDMDlJTGFzRkh6VlEwQjFyTDhHb1BsdG9MUitrbExtQ1dRVTgweXVEWmVtY2Z2TzZETzd6K1E2Umd6Mzcyc3ovOWhTOTg0U1hIMndEeVRPRkFMRm5jaVkzQnlQS3B0akdLRmhESXduSnZaMk5CZFFkWkd3ZUdtMlJzVjFPZTE1T2dxa21ETjZQZ05JK3hVNEFsMUlCNnp0SlJNcENkS1ZzcjlVZTUvTWJCZk1wTzZPbzJOaDJEb2thbDBIUjBFRld6NjVoK1huV0Jhbk9uaU1NdFVLU3dWYTJpNWdWYUhkc25VNC9nSlluVEpMMDh5KzdtZ2REa0d0UTNxVGRpZyt4VHpuanFweCs4RHQvS0FLNyt3aGUrOEZkNEhHNFpKanNrRnFBNW1yV01hUWlZTG9BNkdoSUQ2R0k4cVN3Z3NxQjNZRkZEWjIrQndoR3Rxc2haUGxhV2ZKdm56dTFCb29RaURPVlpRdHFFVEZ0NnBUd0ZUVWJPSDlvaFhVZGphY0NvR1JBRU9vRWN6eTl1RGMwdGhSN1NXQXRKb05ranVmcW1tV1UwU2NEWHZaVExUQTg5SU9yVU1IQjB2cVltUVZrYUZoRllueWVaQXB0TWtkbFVhMUlIVU9vUTBEejF6S2RlL2RBdXI0aUhMTXlCQXdkdXVlV1dXODdHNDNRVEJacHVwU3R2aWZxYnNHcElhZm15RUoyM2JBelVscTY5aUNKUlBrWVpFdWhDMCtXelV0amFRT1dOUkE3WTRwN2tUNExISFBtaTgyKzVYTWhLc096b2FKNDlnano0bXB5OWtxdVFHaUxVYWp3TUFhREtnR0hWSEZ0dFlaVXpRT2NZVzVWVS9qYlpPZE1JSVRsQ0ozU2xyQUtsYVpTc3FlRFV2YWZjK3NjZitNRFR2Nk1IQUlCenp6MzN2YmZjY3N2LzluZ1pRRGE0OUp3WjRJQTVlL3dYRmdnaVVzdFc3bmxwby9teUs0VW0wVmhCWkFkT2RRQjc1TUxSZFRibTdLWU42QTJ0QlEraDVPS3hNQVUydE9SaERKd2R4UGd2MUFkR0pPT25ISWVqckZFRTFiMURJYTE1N0UwUERJbDduVHFhcVVZYnlsOG9DU1VPNFpESWVvRGxHRlJLdXhzZ2ZiS0RuTlNXUnRHaDJuSk1MN0pTR0JFNDY0ZCs2TDNmdXMvelczZ0FBRGpqakRQdXZ2UE9PL2ZoY2J5cEFxb0xaRm5Rd05yL2twQm9XVnIrRGFDbUFGQnFEa3R6SU5xd1NQTDZVR1VkUEhldXRBU0pMUWNLb0dsTkNXT3FSTVp3RHFnb3NVanlES01YcFlaU3FhWTRRejJiWDlnb290REVGeXpsRG4wZ3BoZkFvSUtEWW8xcWM1c05vVTJSdFF0NnArQjlRd1dJeGtNMGNreHZOR29HeVI5SXFZT29oOSs5ZTgraEQzLzR3L3UvNVRWL3VNVTQ3N3p6M29mSCtaWURrQjF4dENQTTBOMWduSUhUeldCK2RLUm80UWJyZmN6S3M0MGhlb2ZiQmtjOTA4TE9OTlBORUVjZHdmdUhHOU84VGtsVlg2VjhPYksrY3hSdXp0cnJtY1o1d0t6RGdtbGZkSmc1ekhpU3QrZk1IdTg5NDcxWmp0UU5qbTd2eGtNakxMVnNZNXk5STJJREh6UCtrWU9lbmEvQm1iOVdaeWxaNTRBdWgyR1Q2U1VIVXZzWUQydm82TEJ1ZVByWlo3L3Y0VHU5SDhZRFBGRmVZRENHclJwTDJ2aDVGcEsyb0NwWVJCRk5zb2UrdFl5WFpBYnpNVG9rNmtJV3NVbDVBQjAxK1BYT3o2SVN4N2NnMDh5YTU1ZWw1UFFBVVNxajBSOHBRd1FhTzRwSmJIUWhVYVNVZVVHcVdOUXl6TER3VTQydHBWRXN6RkdIVkNObStsaktvUFFPaWxBZlZMQ3dIM0h2bnBNUC9kbEgvbXovdzNyZGI3Y1EvK0pmL012MzRBbTQ1ZXo4bmllNldSMmp4am41UGRENzBTU1BZcE5hUW5kWU4vVG9lWElKcDJkM00vaW0weHVRdkhGRGJOSUQ5T2c1ZDUrUEJ3a2VzOXpGZVhKMzd2NmNoRnU3UGQrUDk3bER3enJDQXAzMzcrR1Q1S3BUVnptbk4wbWxIQmNmeHFsZGZSN0hZOUZobXo1SXFweitaVHlwTE1aQlZCdDZLck1zUWNNQ1podWU4cHJlN29lZjhjUHYrZmF6SHI2TkIyQ1I2SlpiYjczMTdDZkNFR3IzNkNJUTNVWnJZRTBnSjVVbGFxZHVNSVdBRUN4b0hGU1Z4RS9WRDJSMEx5dTFoMEJMcFZLUlJhTi9VZEdVdTVCMWhKcFJnRFpvbW9FVmdzUlc4UWF0Y1ZpREVJZ3kzb3ZtT1FuVUtqSCt6NGJUZks3eUVpU2tmUFpJWlArbmpDYVhHalRWUmk5Ull6YVQzdXIwMC9mZit1OC84cEduZjd0ci9CMTdBbi9zeDM3c3JiZmVldXYvL2tSNUFsQlVJdEZITzFZZUxLYUlabU8yOEtZMXFBbTdFb1IxZ1hTeHdxNGxsNWJUUWlNUTN0QzBZd09CdGx3RU5RQ0xqbzRkcVBEWTIyVDNvczRkVW95RmRRSkxLK0pLVS9HcmxJb2IraGcrQmZic0c4VWNBYVRFWGRtMlRSbDc1L0d6SWdLWHJGaEdwRUIwM1EzdDVBTTZjOUVtUFUvZVliaDYxck9mL2RidnVNbStrd2NnSUx6K2kxLzg0a3Z3Qk41a0plaElDcGtjQVdmOVNjc0tuclRHSFYvNVBtY09aOXBBcXJneHpuTEdRZFB4dmRLMnhnVnFFTGpxbUJJNFJDSDBNTUt6ZjlIWUZoYjFmRDZtY3BXRXJTam1tdDdSVnQwOWF4Vnl4QlJ5VkZPVWlZNGVwQ0JsN3NFaFd1d3BiS2llUk1FNXovemh2N3ZtMm10LzZwZ1lBQURzM1h2S2tjT0g3enZwaVRTQ2tqZW5iRndoclkweGNDVU5WNUpFNEh3QlJRT2FZbWxUNGFPdHBwbHdKb0draGgvMEJqVlVRZHQwNFZBdUdKU3RacXZ4Y2dTQnlScm1FS3djZWJjZWswTnlDVDdtRlNXRDZFQXM1VHlHZ0tUNkFndVFWdWtZN0JLdXVReGdhcWpENElDOWUzWS84Qi8rdy8veGlOUmQra2d2L290Zi9LTGZ3Uk44cXk0WTg1bjYxWG04M1RyTURKc2U2SmFnTHN2UE9XdS85ODVEbUh3Y3ErcE1HNTMzTSt2WVdLYWVzS3BTWnZvV0cxYitMTlBQQkk2TzZEeXdxZk9RSitzNW9hemJmSitWUm01c1ZCS0RxV3FlRzdGSndPZzl2eUpUMUFoRDcwdzVDZkEyMk95NEJwRW5STUEzSE9Wdmp1Yzk3L21QZUswZXNRY0FnT2M5NzNrM2ZQbkxYMzRSVG9DYlVGNjhOTEJxS0tQUzE3VHRBSHR0TmFzQXNuYjNNZ2dqSVpDYjl5UDF6Qk5UdE9VNDJpS1paRFgrdmdSM3lubjNNdlI0TmZxZWN3VXhaeG1WWkV4VWtrOGFrMm1UZWc0c3BJSmpIRllRcWpsSXN5WURpbUJSaWwwcFd2bVJIL21SejMzNHd4OSs4WEV4QUlwSDd6dDA2TkNlRThJSXh1U3h4QUNxcWZRVlo4bTRaY3VKVUZBS3lmSnZsbmRqTEk1eXRtMHVmTEp3Z1RxclFFYlR4OEkrUTlhVFo4WUF3SnV1QmxOUnNEck9MaUxxMTREWFRLVFZ2SUo4aGx6a2tmTkxGYlJXa2pTMnJvM3F0SEVJcGdRV1diQjMzOTdEZi8xWGY3MzNVWVhWUjN2Ukw3amdnamZqQkxuTkV6UjV6cDV2ZVBxbXcyekRzL2V3Y3UwWk5ucmwyTVVOUkNlcjEvUFVyWjdocHNLSzl6eWY2R2lGQUlwRnd1anFMVElVZEV1MmNKT2hvVnV5ZnNhdm8yUUVPOThUd3FhUXhEYXdtT0hMdW8xempLMk9mT05ad2RZNTlqMXNIRTJ5c1Fmd3duLzV3a2U5Tm8vYUF3REErZWVmZjgxblB2T1pTM0dDM1VyOEljT1Z0MVZJVUxSV0NMK05YTHhwZGh0cGFlckpCQTZtYlpYM2E5VUp4cEJxWkx2WHdoRTRXcGxEdHFTaE9ZYzNWTk5ZRFRPaERvQ0Zuem9xUlZmOUZEa1JwVGdDaFNwUEUxT2xSb1JpMEVXQmNQekVpMy9pMnZlLy8vMlhQUzRHQUFEUFAvZmNnLy93cFMrZGp4UE9DamkwU211Z3BFQ1dMQlExeXJPYjZqeXFwclZVOXJSTTZXcDIwUnhaUy9Gb3RYcU95V1p0akpMSjhqTlBOb0V5b0xjSHVkYzB3TldJb0RRazlnck81ZGRSR0lzcUtHRTFRaStBVlZVSkdvcHpYM0R1cHoveVp4KzU0THU2WE4rdEFWQTM4TFZiYnJubEFFN0FXeXZpcHlIVnhHZ3pkd2VCSXcyaVBJWHl2Q0p0TWdpZTZ0UklHVnJxK21NY05hUTVBSnZhZmxWWjU2d2MwOFlCMkJ3TnFycGtyTmQ1THBHMjJWVUVCYlRtLzlWUTZwcUNUcUpLM2NjczRXY2NlT1kvLzhlUC9jZG5mTmVwOVdPNXlDOTk2VXVmZGZycHB4ODZFUTBnRHhpWjZhSmJIK2Z1bWhkbXNDRzZORE5zckFTZWdiQ2pUQnQ1bjI0NDJvR2p4QllSaGsxc1lQMG9BcDJ4MnRBN2NjY200QnZHOE0yR290WkE3NXZ4UHZKa2RyNjNlbCtiVkNSbnBrb2hiQ2NXZ2NIc0tDeXl0bkhhVTU1NjZJS1hYUENzeCtRd0g0c0hBSUJYdnZLWHovdjR4Ly9QR3g3NW9STlBYR3hvVXNHVkpKQUtkUUE2MDhnaVhHcDNjNWRJYThuMHRhcnZLNTlxVEFHZyswKzlvTGNWNTEva2ZoMU14U2tpdnBwWUw3SmtwMHlzUEVMOTBhZm9WQ05Kb3RQMzd6dHkwVVgvM1l2ZitjNTMzdlNFR2dBQS9OSXYvZEtGSC8vNHgvL20vdnZ2MzhLVDREWVhPMEdlcm42WHYwbzFiaFdNVkhOT1FJdXRuR1ZZUWJ4cGFndHBGRW5mMXFJN0ZBdHhRWnBSZGh0VGowaGNBWlYwNlhWbVhnRStueWxlSGdyR2dacXEyTHRueitabmYrWm5mdTdkNzM3M0p4L3p0VGdXQmdBQXYvQUx2M0R4Sno3eGliOThzaGhCMGJOUVdYbUEzTWZSMkRqS2ROODFPWUVHSUZyRzhGYWtUMEVBWlgxaE5ZU3F0ZElRckJvMnEvcjRvRUNzem1xazUvdHc4Z2FESEtZK1llOHBlemMvKzdNLyswdnZlYzk3L3ZxWVhJTmpaUURsQ1Q3NXlVOSs3TVFQQjk4Q05MSmpXUGlEa3RDUmN1MnRzZ3VtR3RvRzJGUnA0SG1xdVpxTHp0QUJyTTQyS3ZQZ1dZQWxCRVVKUWpNVE1SVnNPV0RxV0xDa0ZGd2RUem50S1VkKzV1VXYvKzkvL3ozditlUXgyd1RIMGdBU0U3enl2TC85MjcrOS9xNjc3dHFISitGTmlwbGJwWHBLeWpneml3d1Zyb3BsVEFHcUIxS1BLSmtFVnFFb0IwQm0xUjZ0aGczcVZBZmhvZWNxaEFaYTZQanIwdytjZmVqQ0N5LzZxZC83dlhmZmRFdy83N0UyQUFCNDdXdGZ1M3pxVTUvNnlxMjMzbm9BVCtxYnJOSkRJTENWWWt5dDVsSE5LU09xRFAwcm1WaVRxUU5BY2c5ZVloQm1oVnAxaG9VLzh6bllIVDRlZSs2NTUvN3poUmRkOUt6ZmZzYzcrakgvaE1mREFFYng2Tnh6RDM3NVJDU0x2dXU2UXhFeXVlRGFzaFBGQ2M1MGZkOEVEeFVOQmhmZ0xERUo1LzFxWlJLeDd2aVZNY0xtSjM3eS9FOS83SzgrZHNGeCsxekgwd0FBNENkLzhpZXYrZXhuUDNzcHZzZHVVbkt2M01xajdWczFZL3lpaWpxMFN5VXJOeXdpL3dBQUFxeEpSRUZVaVRWRnBPWUxxOWJzL3EwVWRLNFlQNmppNG9zdnZ2YlAvL3pQTHp1dUgyUU9kVHgrWHovM2N6LzN1bjM3OXQySDlabngzME5mMUd0a283aElpTFJvVFdLN3RWaTJsOWplMm82dDdlM1kzclVyZG0xdng2NWQyN0ZyZTFmczNyVTdkdTNlRmJ2MjdJcmR1M2ZIM3QyN1kvZmV2ZkhjNXp6M3Zzc3Z2L3gxajhmYVBDNEdVRi9QZWM1emJ2aGVOWUtIR0FWN2RrUWttclJvalY5YkxiYmFWbXh0OFd1N3hhNnRYYkc5dlIyN3RyZmpvb3N1dk9IeFhKUEgxUUFpQWk5OTZVdXYyck5uejVIdkYwTjR5RmRETkVoSWsyaE4waWlreGRPZTlrTkhYdnZhMTEzMWVLL0g0MjRBOWZYOGM4KzkvdnZXQ0I3MGRlR0ZGMTcvUkszREUyWUFFWUdmLy9tZmYvWFRudmEwVzc1ZkYvNzV6My9CTFpkZWV1bXJuOGcxZUVJTllCMFdUai85OUx1L1h4Yit3SUVEZC8rcmYvWHFxMDZFYTM5Q0dFQjkvZlJQLy9TN3ZwY040Y0NCQTNmLzhpdC8rVjBuMGpVL29ReWd2aTY4OE1JcnpqNzc3TytaMFBEYzV6NzNsbGU5NmxWWG5Jalgrb1EwZ1ByNnhWLzh4WXRmOElJWFhML3JwSlA2azIzUjkrN2QyeSs0NElMcjMvQ0dOMXg4SWwvakU5b0ExbDh2dS9CbFZ6M3ptYy84MHJJc2ZxSXUrdmIydHYvb2ovN29sMTd4aWxkYzlXUzVyc2VkQ2o0ZXQ1ZS8vT1ZYM0hycnJhKys5ZFpiejd2MzNudWYwTkx6NmFlZmZ1U2NjODY1NlJuUGVNWkgvK0l2L3VKM25telg4a2xwQU92YnExNzFxaCsvL2ZiYkw3bmpqanRlZHNjZHR6LzdycnZ1UHRYTWpzdTQyMlZaNG93enpyam5yTFBPdXZtc3M4NzYxRmxublhYZGRkZGRkK09UdXFieFpEZUFiM1g3bFYvNWxRdnZ1ZWVlaSs2OTk5NFgzbmZmZmM4OGZQandtZCs4Ly81VEhqaHlaTmZSbzBlM2V1L2k3dU96czdrMGxtV0o3ZTN0emNrbm4zeGs5KzdkOSs3ZHUvZTJVMDQ1NWF2N1R0MzM5L3YyNy92RW4vN3BuMzd5ZSsxYS9mK25PdDVOQTFlTDNRQUFBQUJKUlU1RXJrSmdnZz09","base64"),
    bucket: Buffer("ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEQUFBQUF3Q0FZQUFBQlhBdm1IQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRnUUVGeVlidldqZWd3QUFBQjFwVkZoMFEyOXRiV1Z1ZEFBQUFBQUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQmtMbVVIQUFBTUdVbEVRVlJvM3NXYWY2eGwxVlhIUDJ2dGZlNjdBOE56cHFVV0FsWFNsSlNHZHhPUVdFTlQ5SjlLVFdzMFRkVDRURTJHaUdrN0l5Rm9hZ3cydEVsckU3VXlBNGpWMUdqaVB5UDlvLzdSNmxoUVdtbWNpSzNSOUwwR1FyV2dMVWdyTUV5aE0vUGUyV3N0LzlqN25IdmUwQ2tNRkhxUy9mWTkrNTRmNjhmM3U5WjMzenpaMk5qZ3BSNi8vNTRGVjExR3ZPMG40YUpyWVBlcklaOERKRUFBQXpzSko1NkdiLzQzL1B2OWNOODl5SHMvOXRMZkxTL1dnWTljditEMUZ4RUhmZ2xlZXkxc1B3bGYreng4YVFQKzh4dncrRlBJc3lmcnRlZXV3SVhudzJWdkpDNjdHdDZ3Z1BOK0dJNC9CcDgrREVmK0Z2bkFuMis4Y2c3ODFlOHM0cVozd21zdWhVOS9CdTcrTW5MZzlyTjd6cDAzTG5qSE80aTMvUXFFd1YxL0JwKzk1K3dkT1dzSE52OWtFVDkvSlh6OGMzRHR6UnZDOStHNDc4NUZYUGNoK09iWDRQZCtGN254TElMeGdoMjRkZitDWDNnejhjUngrTHVORjUveTczVTgrUitMV0x3RmJ2c0E4b3MzdjdEbjZ3dTU2TGJmV1BCelZ4TC8vQkQ4MkkwYkw0dnhBSysrWWtQdStrUDQ3ZHVKSTRjVzhYMXg0R1B2VzNEMUc0alBQd2ovOVMyRWwvbTQ1c0NHM0xvZjN2TlIrT3NQUGI4VHordkE1UmNSRzErSHg0L3pza1grOU9OZHQyekluOTRJTngxNmlSejR5L2N2UWdVZVBZYmMvSWxYeHZqcDhaVy9XTVNQdkFuT3Uvck14ZUtNR2ZpRDl5N0lDZjd2R2ZoQkdBL3dtZnVSM2NDbmJqa3psTTdvd09xYytQWkoyT3BmZnR5ZjZlZ04vdWJ2NFdmZmNwWVErdWl2TDloN0x2SHNGcnovNHp2VHQ3NitmZ0h3SnVCUzRCTGdJdUFDNEh4Z0QzQWVjQTZ3MHNRRVZVeXdCWndBbmdHZUJwNEFIZ2NlQlI0QnZnbzhjUGp3NGNlbjcvdWo5eTA0OE5QRUp6NkgzSERIYzIzTjM4MnJMaEY5Z1dMSSt2cjY1Y0Mxd0RYQWp3TVh2NGhnNWpiT0JWN3p2UzVjWDEvL0J2QkY0QXZBM1l2ZGZPVmZIb0pMWDBzMFpmWDhEb2hBY2ZqeU0ydGZBcTU2aFpGemNSdnZBdGg0ZHUzZlhuZHNremRlK0FJaHRMNisvdVlITmpmdk4yQnRiWTNOelRWK2tNZmEyaWFQYlc3eXk3dmh2a3ZXZnVMdzRjUC91c09CSTBlT0lBZ2g4SkVQZjVpdTZ5TGxSTmJNWisvK21RYnBPVEJyOC9UemRIN3VXdGNKOHpuTVpzdVJNK1BhN3QxMXJLNHU1OVZWdVBkZTJMZXZyaTBXRDZBcWlDZ29LQ3I3OSsvSDNTdUVjbDZpU0pNaUFvcHd6ei84VkRNbXQySTF6S2QvMWduRTgzaFBTa0xPUEdkTW5RRlFYWTZjbC9OdzdjTVBYNGE3Y2ZubFh3ZFZGRUZrU1lXY2N5SkNFQUVSYlo0S2IzLzdGOGhkeDRNUHZwNnZQblJsTXl5ZFp2anNOT1B6Nk55WmpKL1BkNjVOSGFqR0J4ZGZEQ2RQQnBkYzhpMSs5SFVuMFpSQXUycWpwdXFBQ0VTUVUrb1FDUWdRcWQ0SmlvaWdBb3UxLytHS0t4NGxwMFRPTTU1NmNwVi92UGVkbkRxMTJxQWlNQmFJT2xJQzFSZ2hjN3F4dzJlb2h1N2FGWWhzY2RWVlgrVENDNVMzdmpYWXUyY1BzMTI3a0RRbmR4bEJFQlg1dGV1dmJ6WUtRU0JIang0ZDB4RUVIN3psZzVGU3B1c3lLU2R5eXVSY1IwcVpuTFdkZDZTVTJsb2lkWW1zSGJsTEpFMlRleEk1SlhSNFprcDE1RXpLbWF6S3lzcU0yV3lseml0emRzM25yS3pzWWo2ZnNXdGxoZGw4anFvaUlySnYzM1dZRlVveDNJMmNja2FvblRwcUZrUkZvbVpBbGxrUlFScVpoT1hhUUxBa1dqK2pxTzRja2hUTmFlZTZDRWtFVmEwSkpCQ0VyVk9uT0dmWExzQmJtVkZVRTJuV2thVkJuVHFQSEdqMkU5R2FnTkp3cGlOaDJuSTkxNmxEdzlDSlE1TzVqVFE2cklncUtTMGRFdEgyQWtFY0pGaXU1MEFGWmltaGFjRC9BSGZRQVNJcFZ5aG93eGZ0THl3TlpPUklmWkNPMzdFalUybHdTQ2ZPNldsT1RqT2tncElRNE5peDQ2TkMweVNrU01PMThxdnZmamRMWkZRcHB5bFhQRmFTcGgzZHVFYTVSb09Ka2FvRFg5dDVpOHo0NEhaZVV6MUVXZEJVRFU4a3REazFPSUhVUW5EOHFTY3FsRlVnSUtSQ1l5eWNyVllNNGEwWlNFdVMzbnJyUWJUbWYzbmhhRXpMemVuUlozTGQ1QnJSRmdBUlZKWTFYRk1OZ280QnFYQUtncjNudjZwV1JHUTVLOVdUQWY4STBkN2RTRndyb1VjZ1lrc2p4cHNtS21xSThtanNBS0hHRHhwY1lDekhUSXFBanVmYW9LVWpYeVNFMWRVOVNLbzFYclRWUmhkSXk2Z3prRmdnNTVUR1dxNFJ1QStrbldhQWtiampBeVoxZi9TU1pVWnFBWGp1ZmFvTkhrT0dBR25FRmhYbXN6azRSQVRoZ1VlZ0tseTM3enJHaHl1SVZ4dGFCb1FJSjJvWmFnU0pKUlJHZ3lmWkdHMmZScmxwZzhINFdsVGJNNGUxaENCanNVZ3B0ZmhVUjdlMnRwalA1d1NCTnhMRU1wN1ZrcGdFSktmV3NQTFFaSlNEQnc4UkxrUkFoT1B1UkhoalZOMmRCSUZFUUZpTlZyUktIdEdDMFlKQzFLc2pKbDI3bll1TTg4Q3hpT0N4eC80WER5Y2N3Z1BjUnhCWFJNU3l0S2VzZEtsMlQyblZRa1N4S09KaG1BY2VqbHRnWVpnN2VEdjNtalYzSjl5aE9ldm1SRmp0TGQ2TWJaQ0lDRHhhMDRubWpEdUJNelFrOXlDSzQyNEVSdkhsZDdFRHdrSFcxdW1DZ3NSWUhhdUI0cWdZTG9KaGlDb3VpcnVqNHJnTDVvNDBKOHg5TEt2ZW5Cc2NkQjJ5VUExM0tyNGpncEFZL1RsNThnUjc5cXhTM01obVdERis2NmJmWkNpa0E1M2FrOUFJeDgzdzhFb2VLb0hjQ21hR1dZMkV0K3ZNQzI2T1I2bEdoK0ZoWXhZcStaeUEwU21QbWhFbjJ2UHFpeXBKS3lhcm84SGV2YS9DSS9qT2QwNVF6T2lMQ3l6N1FJdzVxTkpEU3pHS0ZidzQ1bGF4RHR4MisrMjRPYVU1WVZiRjA3QldTb09PT1ZIcTkrWldyelBIU3FuR1dvV09HYmdiRmcyUzdrUjduNGUzYkxUWm5XTlBINk9VbmxMNjc3cFRHMUNZelJwV0p3KzJGdkZpdlVpU01HdXQzeXFNTEF4MXdVMHhFVVNOTElvWHg5V3dVTVNsY2lVTUQwSERpYUlnaG90aTZxZ3Fab1pxaFdXSTRHNnNyS3h3L0psdjEyQ1Zmb1RMWUhtRllqM0pWbXhNeklCYnQ0R2tJTDFCS0VtTUlpQ2xFdDJvOVZ3Y3JOUk9hd0ZTcFBLRHdKSWhybmd4UWhVTFFWeEpEVzV1aHFvUUZwaVVXa3JOY1hGKzZMeFZuajF4Z2orKzg4NlJOeEduNXdCeUtYMHRaOFNJdy9DS2FTdWw5ZzZEWHFBVE1GSEVtcHhRcDZnajBualNnNUZRclZHMXdsS0M5SWFndUJvMUprMUdsS0Jvb2ZOTWNVZXNLb0d1NjhoZEZzWVN6WWlVVVRrRHVUUUlEVjlXWWpVY1c0OUlsYlBtaXZSVkFZWUlTcUcwN3FJaGJZdWxpRnVGbGxxVDg0b1VSOVV4SzBpVDZ1WmVJU2tLUlJDTWpPRHRKNTFhY1pRZFdyL3hjN3FrVmdwV2pGS01VZ3JGQ2xhYzRzYkJnNGZhdXRHWFFuR2o5NEwzUFgwanRwbTNlN2F4MGpmeTFzSmdidlRENTk0cStjMG8xdU45WHd0SEtaZ1YzT3I3Kzc1ZVczZGRmV3NWTWFrL3kzSWNFZVRlckltNTFqTTljQ3BHelIwckprQ0lnRGM0RkVDMHRIMXQzWjFXVFc5Tkd2Y3RNeUNobUVBeHhvMVNsUklGTVNHRzVvUFFCUlJaWXR3SFdFLzZYcTNBcmZ4V0VwZGhnejgybUlISTRVRmYrdnFTdm00OHV5YndxcHhkYnVaRnJIN3MyZkVib09zMmxOa290ME1HbFN0RWxLcE9Ka2FuY09nZ0l1UlRkMzJ5a2JlTnRzMGNiSTJBWEVvWk5jaklnMVpTdzRLK0w2TkNaU0xxc2pnOUt3UTlnYUROY00xVjBFM2xkR0VvRkZVcjlSMUVYN1ZVRlpJREFodzA0MEJuclNrT05qR1EyU2Q5T0taOUFKQ29BZ3B2MWNqcCs1NElSNlFqUEJBQ0Y2Ky9DY1UyUk4xUDlPRVF3WFlFWFFqUkxXdWV1MWZIM1VFNnNyWFhTNVVUT1hMdEdSNVlkckk3bmxJTDVJQ2RZUjY2ZHR0MmxsTDFobHNsc3cxenFWMzEwS0dEV0c5U0dqbjdmcHV5VmRndTI1VjBqWGg5S2ZTbHAvUjE5cjZuOUQyOTllMit2aGFKN1o2eVhRbGE1K1g5WmJ2ZzI0Vys3eXQwVytVWkhCbGdOR29xR29TUVphRWQrc0d5cERyYmRvcm9aelZpN2Y4SG91M1lxdXl0MGEzM1Zoa3RFWVFJMGZmTDV3MDZxVWtHeSswZDJiRkltRG9sbE9SSmp2N1QwWjJHeDFEbW00M0RiNk5tcFFsVEFYeVV1bE1IK3UyKzdnOGFjdkNlN0U1SU1MTlUxeVNUSXBCWkVOSUJnZzFTMld0QmNIY3NkNFNEdWRPRmdUdHFTdWVKMExwOTlKVEgzZGdnd1hjNDR6RTJ0bHlLalR1c0haN2k0ODJuVHZYTVp1RGhHTWJNbllpdTRuQm1PT0FDczBhMldUalJWV3dQaG5nNEtXWjBUWm5teUxpQjV5QjNHWGVuUzQ1YlJwSTF4ZXFUN0ZXTzFZd3YrWlhOeXFRVEQ5VmdlWk1IM0hISEhkeHd3d0d4aUFnUG90U2RXczVPUkc3M09kSE42THpDMGEwU2N0aXF1bWVTVlFNN0R5STVuZ01QeGR6SUtXRXBrWktSVW1vMWYxSVJtOHdaN0dPWmdkWUhKaHAxM0JONGpBWnNuOW9pdXlOUm80VlVpVHc0YXVha01OeG1OVk9wSTdkN3JRU3hZcmgzb3dTM25PbkNLSjd4WkJSTncyK3Q4c2dqRDQ5YldSL2cxd2c5d0dnNC9oOEZmbnlBcG1tb0lRQUFBQUJKUlU1RXJrSmdnZz09","base64")
};

counter = Object.keys(spriteImages).length;
interval = null;

Number.prototype.clamp = function(min, max)
{
    return Math.min(Math.max(this, min), max);
}

function loadVert(v)
{
    return { x: -v[0], y: v[1], z: (v[2] || null) };
}

function loadWalls(l)
{
    let res = [];
    
    for ( let i = 0; i < l.length; i++ )
        res.push({ begin: loadVert(l[i][0]), offset: geom.point.sub(loadVert(l[i][1]), loadVert(l[i][0])), height: l[i][2] });
    
    return res;
}

function imageLoaded()
{
    counter--;
    
    if ( counter < 1 )
    {
        console.log(spriteImages);
        
        main = function main(map)
        {
            if ( interval != null )
                clearInterval(interval);
            
            var walls = loadWalls(map.walls);
            var sprites = map.sprites;
            
            for ( let i = 0; i < sprites.length; i++ )
            {
                sprites[i].pos = loadVert(sprites[i].pos);
                sprites[i].image = spriteImages[sprites[i].type];
            }

            var camPos = loadVert(map.camera.pos);
            var camAngle = map.camera.angle * Math.PI / 180
            var swipe = map.camera.swipeWidth * Math.PI / 180;
            var camFov = map.camera.fov * Math.PI / 180;
            var mapSprites = map.sprites;

            var curAng = camAngle;
            var angDelta = 0;
            var velocity = { x: 0, y: 0 };
            var fVel = 0;
            var breath = 0;
            var breathDelta = 0;
            
            var i = 0;

            var keys = [];

            var cnv = document.getElementById('rayCanvas');
            var ctx = cnv.getContext('2d');
            
            interval = setInterval(function() {
                raycaster.raycast(cnv, walls, camPos, curAng, camFov, ctx, mapSprites, spriteImages);
                
                if ( checkKey(39) )
                    angDelta -= 0.1;
                
                if ( checkKey(37) )
                    angDelta += 0.1;
                
                if ( checkKey(38) )
                    fVel += 0.7;
                
                if ( checkKey(40) )
                    fVel -= 0.7;
                
                curAng += angDelta;
                
                if ( checkKey(16) )
                {
                    fVel = (fVel * 1.9).clamp(-1.8, 1.8);
                    angDelta = (angDelta * 1.5).clamp(-0.09, 0.09);
                }
                
                else
                {
                    fVel = fVel.clamp(-1, 1);
                    angDelta = angDelta.clamp(-0.05, 0.05);
                }
                
                angDelta *= 0.5;
                fVel *= 0.8;
                
                velocity = geom.point.mul(geom.point.fromAngle(curAng), fVel);
                
                // document.getElementById('camPos').innerHTML = "(" + camPos.x + "," + camPos.y + ")";
                // document.getElementById('camAng').innerHTML = (curAng * 180 / Math.PI) % 360 + " degs";
                
                var collides = false;
                var colliders = [];
                
                if ( Math.abs(fVel) > 0.001 )
                {
                    for ( let i = 0; i < walls.length; i++ )
                        if ( geom.lineSeg.collides(walls[i], camPos, 0.8) && geom.point.dot(velocity, geom.point.sub(geom.lineSeg.closest(walls[i], camPos), camPos)) > 0 )
                        {
                            collides = true;
                            colliders.push(walls[i]);
                            // document.getElementById('colDot').innerHTML = geom.point.dot(velocity, geom.lineSeg.closest(walls[i], camPos));
                        }
                        
                    if ( collides )
                    {
                        if ( colliders.length > 1 || geom.point.dot(geom.point.unit(velocity), geom.point.unit(geom.lineSeg.closest(colliders[0], camPos))) > 0.8 )
                            velocity = { x: 0, y: 0 };
                        
                        else
                        {
                            let slide = geom.point.unit(colliders[0].offset);
                            
                            if ( geom.point.dot(slide, velocity) < 0 )
                                slide = geom.point.inverse(slide);
                            
                            velocity = geom.point.mul(slide, geom.point.len(velocity));
                        }
                        
                        // document.getElementById('slideVel').innerHTML = "(" + velocity.x + "," + velocity.y + ")";
                    }
                    
                    // document.getElementById('camVel').innerHTML = "(" + velocity.x + "," + velocity.y + ")";
                    
                    camPos.x += velocity.x;
                    camPos.y += velocity.y;
                    camPos.z = Math.sin(breath) * 2;
                    breathDelta += geom.point.len(velocity) / 25;
                    breath += breathDelta;
                    breathDelta *= 0.975;
                }
            }, 50);

            function checkKey(c)
            {
                return keys.indexOf(c) != -1;
            }

            keyUp = function keyUp(evt)
            {
                while ( keys.indexOf(evt.keyCode) != -1 )
                    keys.pop(keys.indexOf(evt.keyCode));
            }

            keyDown = function keyDown(evt)
            {
                if ( keys.indexOf(evt.keyCode) == -1 )
                    keys.push(evt.keyCode);
            }

            document.onkeydown = keyDown;
            document.onkeyup = keyUp;
        }

        defmap = JSON.parse("{\"walls\": [[[128, 104], [128, 120], 5], [[128, 120], [144, 120], 5], [[144, 120], [144, 104], 5], [[176, 104], [144, 104], 5], [[176, 104], [176, 64], 5], [[128, 104], [104, 104], 5], [[104, 104], [88, 88], 5], [[88, 88], [64, 88], 5], [[64, 88], [56, 96], 5], [[56, 96], [40, 96], 5], [[40, 96], [32, 88], 5], [[32, 88], [32, 72], 5], [[32, 72], [40, 64], 5], [[40, 64], [56, 64], 5], [[56, 64], [64, 72], 5], [[64, 72], [88, 72], 5], [[88, 72], [104, 56], 5], [[104, 56], [144, 56], 5], [[176, 64], [168, 56], 5], [[168, 56], [160, 56], 5], [[144, 56], [144, 40], 5], [[144, 40], [160, 24], 5], [[160, 56], [160, 48], 5], [[160, 48], [168, 40], 5], [[168, 40], [200, 40], 5], [[160, 24], [200, 24], 5], [[200, 24], [200, -8], 5], [[200, -8], [264, -8], 5], [[200, 40], [200, 72], 5], [[200, 72], [264, 72], 5], [[264, 72], [280, 56], 5], [[264, -8], [280, 8], 5], [[280, 56], [280, 40], 5], [[280, 8], [280, 24], 5], [[280, 24], [304, 24], 5], [[280, 40], [296, 40], 5], [[304, 24], [344, 56], 5], [[296, 40], [320, 56], 5], [[344, 56], [376, 56], 5], [[376, 56], [376, 96], 5], [[320, 56], [320, 96], 5], [[360, 56], [352, 72], 5], [[352, 72], [360, 88], 5], [[360, 88], [352, 96], 5], [[320, 56], [328, 72], 5], [[328, 72], [336, 88], 5], [[336, 88], [328, 96], 5], [[320, 96], [328, 96], 5], [[352, 96], [376, 96], 5], [[352, 96], [352, 120], 5], [[328, 96], [328, 120], 5], [[328, 120], [304, 120], 5], [[352, 120], [376, 120], 5], [[376, 120], [376, 152], 5], [[304, 120], [304, 152], 5], [[328, 120], [328, 144], 5], [[352, 120], [352, 144], 5], [[368, 160], [376, 152], 5], [[312, 160], [304, 152], 5], [[312, 160], [336, 160], 5], [[368, 160], [352, 160], 5], [[352, 160], [352, 184], 5], [[328, 184], [328, 184], 5], [[352, 184], [328, 184], 5], [[328, 184], [328, 160], 5]], \"sprites\": [{\"type\": \"sphere\", \"size\": 2.3, \"pos\": [336, 176]}], \"camera\": {\"pos\": [136, 112], \"angle\": 0, \"fov\": 100}}\n");
        main(defmap);
    }
}

function mapList(host, callback)
{
    if ( "" in host.split(':') )
        return;
    
    let conn = new WebSocket('ws://' + host, ['soap', 'xmpp']);
    
    conn.onopen = function() {
        if ( !callback(conn) )
            conn.onmessage = onMapListMessage;
    }
}

download = function download()
{
    let host = document.getElementById('mlhost').value;
    let id = document.getElementById('m_id').value;
    
    if ( host != '' && id != '' )
    {
        mapList(host, function(conn) {
            conn.send("RETRIEVE:" + id);
            
            conn.onmessage = function(msg, isBin) {
                if ( !isBin )
                {
                    msg = msg.data;
                    
                    let res = msg.split(':')[0];
                    
                    if ( res == "ERR" )
                        document.getElementById('mlstatus').innerHTML = '<b style="color: red;">' + msg.slice(msg.indexOf(':') + 1) + '</b>';
                        
                    else
                    {
                        document.getElementById('mlstatus').innerHTML = "SUCCESS";
                        main(JSON.parse(document.getElementById('jsonin').value = msg.slice(msg.indexOf(':') + 1)));
                    }
                }
            }
        
            return true;
        })
    }
}

for ( let i = 0; i < Object.keys(spriteImages).length; i++ )
{
    let k = Object.keys(spriteImages)[i];
    let src = spriteImages[k];
    
    spriteImages[k] = new Image();
    spriteImages[k].onload = imageLoaded;
    spriteImages[k].src = src;
}

}).call(this,require("buffer").Buffer)
},{"./geometry.js":1,"./raycaster.js":3,"buffer":5}],3:[function(require,module,exports){
var geom = require('./geometry.js');

var fogColor = [0.6, 0.6, 0.6]
var wallColor = [0.95, 0.1, 0.02]
var groundColor = [0.01, 0.01, 0.22]
var ceilColor = [1.0, 0.9, 0.8]
var nearFog = 32;
var farFog = 96;
var darkDist = 72;
var brightDist = 1.5;

function lerp(a, b, x)
{
    return (x * (b - a)) + a;
}

function interpolateColor(a, b, x)
{
    if ( x > 1 )
        x = 1;
    
    if ( x < 0 )
        x = 0;
    
    return [
        a[0] + x * (b[0] - a[0]),
        a[1] + x * (b[1] - a[1]),
        a[2] + x * (b[2] - a[2])
    ];
}

function between(a, b, x)
{
    return ((x - a) / (b - a)).clamp(0, 1);
}

function rayAngle(angle, x, fov, width)
{
    return angle + Math.atan((x / width * 2 - 1) * Math.tan(fov / 2));
}

function angleToX(relAng, fov, width)
{
    return width * (Math.tan(relAng) / Math.tan(fov / 2) + 1) / 2;
}

var l = true;

function rayDist(pos, camAngle, rayAngle, dest)
{
    return geom.point.len(geom.point.sub(pos, dest)) * Math.cos(Math.abs(rayAngle - camAngle));
}

function rowDist(y, height)
{
    return 15 * height / (height - y);
}

var textures = {};

function addTexture(name, href)
{
    var img = new Image();
    img.src = href;
    
    img.onLoad = function() {
        var canv = document.createElement('canvas');
        canv.width = img.width;
        canv.height = img.height;
        
        var ctx = canv.getContext('2d');
        ctx.drawImage(img);
        
        textures[name] = (ctx.data);
    }
}

bLogSpr = false;

function colorHex(number)
{
    number = Math.floor(number * 255);
    
    if (number < 0)
        number = 0xFFFFFFFF + number + 1;

    var res = number.toString(16).toUpperCase();
    
    if ( res.length == 1 ) 
        return "0" + res;
    
    return res;
}

function raycast(canvas, walls, camPos, camAngle, fov, ctx, sprites, spimes) // :D
{
    var id = ctx.createImageData(1, 1);
    var data = id.data;
    var planeX = Math.cos(camAngle - Math.PI / 2) * Math.tan(fov / 2);
    var planeY = Math.sin(camAngle - Math.PI / 2) * Math.tan(fov / 2);
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 1;
    
    var y = null;
    
    for ( y = 0; y < canvas.height / 2; y++ )
    {
        var color = interpolateColor(ceilColor, fogColor, between(nearFog, farFog, rowDist(y, canvas.height / 2)));
        var bright = (darkDist / rowDist(y, canvas.height / 2)).clamp(0, 1);
        
        color[0] *= bright;
        color[1] *= bright;
        color[2] *= bright;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width - 1, y);
        ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2])
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    for (; y < canvas.height; y++ )
    {
        var prog = (canvas.height - y);
        var color = interpolateColor(groundColor, fogColor, between(nearFog, farFog, rowDist(prog, canvas.height / 2)));
        var bright = (darkDist / rowDist(y, canvas.height / 2)).clamp(0, 1);
        
        color[0] *= bright;
        color[1] *= bright;
        color[2] *= bright;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width - 1, y);
        ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2])
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    var nextProx = null;
    var screenDists = [];
    
    for ( let x = 0; x < canvas.width; x++ )
    {
        let ang = rayAngle(camAngle, x, fov * (canvas.width / canvas.height), canvas.width);
        
        let ray = { begin: camPos, dir: geom.point.fromAngle(ang) };
        
        let curDist = 0;
        let realDist = 0;
        let curLine = null;
        let curInter = null;
        
        for ( let j = 0; j < walls.length; j++ )
        {
            let intersection = geom.lineSeg.split(ray, walls[j]);
            
            if ( intersection != null )
            {
                let ipos = geom.ray.intersectionPos(ray, walls[j]);
                let distance = rayDist(camPos, camAngle, ang, intersection);
                let rdist = geom.point.len(geom.point.sub(camPos, intersection));
                
                if ( curLine === null || rdist < realDist )
                {
                    curDist = distance;
                    realDist = rdist;
                    curLine = walls[j]
                    curInter = intersection;
                }
            }
        }
        
        if ( curLine !== null )
        {
            let fog = 1 - between(nearFog, farFog, curDist);
            screenDists.push(curDist);
            
            if ( fog > 0 )
            {
                let normWSize = Math.round(2 * canvas.height / curDist);
                let wsize = Math.round(curLine.height * canvas.height / curDist);
                let startY = Math.floor(canvas.height / 2 - curLine.height * canvas.height / curDist - camPos.z + 1.5 * canvas.height / curDist);
                
                let proxBright = geom.point.len(geom.point.sub(camPos, curInter)).clamp(0, 2.75) / 2.75;
                let bright = (Math.abs(geom.point.dot(geom.lineSeg.normalTo(curLine, camPos), { x: 1, y: 0 })) * 0.7 + 0.3) * proxBright * (1 - (curDist / darkDist)).clamp(0, 1);
                
                if ( nextProx == null )
                    nextProx = proxBright;
                
                if ( proxBright < nextProx )
                    nextProx = proxBright;
                
                let color = Array.from(wallColor);
                
                color[0] *= (bright).clamp(0, 1);
                color[1] *= (bright).clamp(0, 1);
                color[2] *= (bright).clamp(0, 1);
                
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + wsize);
                ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2]) + colorHex(Math.pow(fog, 2));
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // for opacity
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + wsize);
                ctx.globalAlpha = fog;
                ctx.strokeStyle = "#" + colorHex(color[0]) + colorHex(color[1]) + colorHex(color[2]) + colorHex(Math.pow(fog, 2));
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
    }
    
    var spritesToRender = [];
    var theta = rayAngle(camAngle, 0, fov, canvas.width);
    
    for ( let i = 0; i < sprites.length; i++ )
    {
        let sprite = sprites[i];
        let offs = geom.point.sub(sprite.pos, camPos);
        let depth = geom.point.len(offs);
        let ang = Math.atan2(offs.y, offs.x);
        
        // planeX = 0, planeY = tan(fov / 2)
        let invDet = 1.0 / (planeX * Math.sin(camAngle) - Math.cos(camAngle) * planeY)
        
        let transformX = invDet * (Math.sin(camAngle) * offs.x - Math.cos(camAngle) * offs.y);
        let transformY = invDet * (planeX * offs.y - planeY * offs.x);
        
        let absAng = Math.min(Math.abs(ang - camAngle), Math.abs(camAngle - ang));
        let distance = geom.point.len(offs);
        
        let screenSprite = Object.assign(sprite, {});
        screenSprite.camDist = transformY;
        
        if ( transformY > 0.1 )
        {
            screenSprite.renderX = Math.round((canvas.width / 2) * (1 + transformX / transformY) - (spimes[sprite.type].width / 2 / transformY));
          
            if ( screenDists[screenSprite.renderX] > screenSprite.camDist )
            {
                // document.getElementById('shadow').innerHTML = screenSprite.renderX + " (" + offs.x + "," + offs.y + " [" + transformX + "])";
            
                screenSprite.scale = sprite.size * canvas.height / spimes[sprite.type].height / screenSprite.camDist;
                screenSprite.distance = distance;
                
                spritesToRender.push(screenSprite);
            }
        }
    }
    
    spritesToRender.sort(function (a, b) { return b.distance - a.distance; });
    
    for ( let i = 0; i < spritesToRender.length; i++ )
    {
        let spr = spritesToRender[i];
        let img = spimes[spr.type];
        
        let x = spr.renderX;
        let y = (canvas.height + canvas.height / spr.camDist * 3) / 2 - img.height * spr.scale;
        
        let fog = 1 - between(nearFog, farFog, spr.camDist);
        
        if ( !bLogSpr && spritesToRender.length > 0 )
        {
            console.log(spr.type, x, y);
            bLogSpr = true;
        }
        
        if ( fog > 0 )
        {
            ctx.globalAlpha = fog;
            
            ctx.drawImage(img, x, y, img.width * spr.scale, img.height * spr.scale);
            ctx.globalAlpha = 1;
        }
    }
}

module.exports = {
    raycast: raycast,
    addTexture: addTexture
};

},{"./geometry.js":1}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":6}],6:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}]},{},[2]);
